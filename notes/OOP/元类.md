# Metaclasses

[TOC]

元编程(*metaprogramming*)是一种编程技术，采用元编程的计算机程序，能够将程序视为数据。这意味着利用元编程技术可以设计出一种能够读取、生成、分析或改变其它程序的程序，利用元编程技术甚至可以在运行时对自身进行修改。[^1]

Python 支持一种适用于类的元编程形式，即元类(*metaclasses*)。

- 

### 1.1 Old-Style Classes

在旧式类中，实例的 class 和 type 是不同的。

```python
>>> class Foo:
...     pass
...
>>> x = Foo()
>>> x.__class__ # __class__对应类名
<class __main__.Foo at 0x000000000535CC48>
>>> type(x) # 总返回 <type 'instance'>
<type 'instance'>
```

用户定义类的实例的类型总是 `instance`



With old-style classes, class and type are not quite the same thing. An instance of an old-style class is always implemented from a single built-in type called `instance`. If `obj` is an instance of an old-style class, `obj.__class__` designates the class, but `type(obj)` is always `instance`. The following example is taken from Python 2.7:

```
>>> class Foo:
...     pass
...
>>> x = Foo()
>>> x.__class__
<class __main__.Foo at 0x000000000535CC48>
>>> type(x)
<type 'instance'>
```



Old-Style 类仅存在于 Python 2 中，不会默认继承 `object` 类，而是继承 `type` 类。

Python2中的旧类如下面代码所示：

```
class oldStyleClass: # inherits from 'type'
    pass
```

Python2中定义一个新类：

```
class newStyleClass(object): # explicitly inherits from 'object'
    pass
```

在Python3中所有的类均默认继承`object`，所以并不需要显式地指定`object`为基类。

以`object`为基类可以使得所定义的类具有新类所对应的方法（`methods`）和属性（`properties`）。



### New-Style Classes

## 注脚

[^1]: https://en.wikipedia.org/wiki/Metaprogramming
[^2]: 
[^3]: https://wiki.python.org/moin/NewClassVsClassicClass
[^4]: [Metaclasses in Five Minutes](http://www.voidspace.org.uk/python/articles/five-minutes.shtml)
[^4]: 













The term **metaprogramming** refers to the potential for a program to have knowledge of or manipulate itself. Python supports a form of metaprogramming for classes called **metaclasses**.

Metaclasses are an esoteric [OOP concept](https://realpython.com/python3-object-oriented-programming/), lurking behind virtually all Python code. You are using them whether you are aware of it or not. For the most part, you don’t need to be aware of it. Most Python programmers rarely, if ever, have to think about metaclasses.

When the need arises, however, Python provides a capability that not all object-oriented languages support: you can get under the hood and define custom metaclasses. The use of custom metaclasses is somewhat controversial, as suggested by the following quote from Tim Peters, the Python guru who authored the [Zen of Python](https://www.python.org/dev/peps/pep-0020):

## 补充知识点

### 特殊属性

#### \_\_class\_\_

instance.\_\_class\_\_

类实例所属的类，可理解为用于实例化当前对象的模板。

```python
>>> type('whale') # 字符串是str类的实例
<class 'str'>
>>> type(str) # str类是type类的实例
<class 'type'>
>>> type(type) # type类是type类的实例
<class 'type'>
```

#### \_\_bases\_\_

class.\_\_bases\_\_

类对象的基类构成的元组，只包含直接基类，并不是继承链上的所有基类

```python
>>> bool.__bases__
(<class 'int'>,)
>>> int.__bases__
(<class 'object'>,)
```

### built-in types

https://docs.python.org/2.7/library/types.html

#### Python 2.7

https://docs.python.org/2/library/types.html

##### types.TypeType

类型对象的类型，`types.TypeType` 是内置函数 `type` 的别名。
类型对象是指 int、str、list等内置类型，且它们的类型均为 type：

```python
>>> type(int)
<type 'type'>
>>> type(list)
<type 'type'>
```

自定义类(class)的类型均为 `<type 'classobj'>` ，即 `types.ClassType` 类型

```python
>>> class OldCls: pass

>>> type(OldCls)
<type 'classobj'>
```

因为， `types.TypeType` 是内置函数 `type` 的别名，所以同样可以用它构造新式类(class)：

```python
# type只能构造新式类，若第二参数为空，则默认继承object
Other_NewCls = type('X', tuple(), dict(a=1))
print(type(Other_NewCls))  # 输出:<type 'classobj'>
print(Other_NewCls.__class__)  # 输出:<type 'classobj'>
print(Other_NewCls.__bases__)  # 输出:() -> 基类元组为空
```

##### types.ClassType

用户定义的旧式类的类型

```python
'''在types模块中，ClassType的定义如下'''
class _C:
    def _m(self): pass
ClassType = type(_C)
```

可用该类型创建旧式类或新式类

```python
# -*- coding: utf-8 -*-
# in Python 2.7
import types
class OldCls:
    def __init__(self, a_str):
        self.a_str = a_str
print(types.ClassType is type(OldCls))  
# 输出:True -> types.ClassType与<type 'classobj'>等价

print(type(OldCls))  # 输出:<type 'classobj'>
# __class__：自定义旧式类没有该属性
print(OldCls.__bases__)  # 输出:() -> 基类元组为空

# types.ClassType构造旧式类
Other_OldCls = types.ClassType('Other_OldCls', tuple(), dict())
print(type(Other_OldCls))  # 输出:<type 'classobj'>
print(Other_OldCls.__bases__)  # 输出:() -> 基类元组为空

# types.ClassType也可构造新式类，此时和type效果完全相同
Other_NewCls = types.ClassType('X', tuple((object,)), dict(a=1))
print(type(Other_NewCls))  # 输出:<type 'classobj'>
print(Other_NewCls.__class__)  # 输出:<type 'classobj'>
print(Other_NewCls.__bases__)  # 输出:() -> 基类元组为空
```



##### types.InstanceType

用户定义的旧式类的实例的类型

```python
'''在types模块中，InstanceType的定义如下'''
class _C:
    def _m(self): pass
_x = _C()
InstanceType = type(_x)
```

可用该类型创建旧式类的实例

有没有初始化？



### 术语

#### class

用于创建由用户定义的对象的模板。类定义中通常会包含用于操作类实例的方法。

#### type

Python 对象的类型(*type*)决定了对象所属的种类(*kind*)；每个对象都有一个类型。对象的类型(type)可通过 [`__class__`](https://docs.python.org/3.7/library/stdtypes.html#instance.__class__) 属性访问，也可通过 `type(obj)` 访问。

#### metaclass

The class of a class. Class definitions create a class name, a class dictionary, and a list of base classes. The metaclass is responsible for taking those three arguments and creating the class. Most object oriented programming languages provide a default implementation. What makes Python special is that it is possible to create custom metaclasses. Most users never need this tool, but when the need arises, metaclasses can provide powerful, elegant solutions. They have been used for logging attribute access, adding thread-safety, tracking object creation, implementing singletons, and many other tasks.

More information can be found in [Metaclasses](https://docs.python.org/3.7/reference/datamodel.html#metaclasses).

### object

```python
>>> type(object) # 查看object的类型，也就是构造object的模板
<class 'type'>
>>> object.__class__
<class 'type'>
>>> object.__bases__ # object没有父类
()
```



### type

```python
>>> type.__class__
<class 'type'>
>>> type(type)
<class 'type'>
>>> type.__bases__
(<class 'object'>,)
```

type 类中包含了 `__new__` 和 `__init__` ，那么新元类中覆写 `__new__` 的示例是否可通过覆写 `__init__` 完成喃？







```python
# 查看父类元组
>>> object.__bases__
()
>>> type.__bases__
(<class 'object'>,)
>>> int.__bases__
(<class 'object'>,)

# 查看模板
>>> object.__class__
<class 'type'>
```

```python
>>> def fn(self, name='world'):
	print('Hello, %s.' % name)

	
>>> Hello = type('Hello', (object,), dict(hello=fn))
>>> Hello.__bases__
(<class 'object'>,) #object是父类
>>> Hello.__class__
<class 'type'> #type是模板
```

## Old-Style vs. New-Style Classes



在下面的文章中我们会分别基于新类和旧类探讨`__new__`和`__init__`。



----

https://zhuanlan.zhihu.com/p/21379984 只看最后一个有关元类的示例

https://docs.python.org/3.7/glossary.html 术语中有 metaclass

https://docs.python.org/3.7/reference/datamodel.html#metaclasses