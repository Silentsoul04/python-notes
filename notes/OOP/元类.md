# Metaclasses

[TOC]

元编程(*metaprogramming*)是一种编程技术，采用元编程的计算机程序，能够将程序视为数据。这意味着利用元编程技术可以设计出一种能够读取、生成、分析或改变其它程序的程序，利用元编程技术甚至可以在运行时对自身进行修改。[^1]

Python 支持一种适用于类的元编程形式，即元类(*metaclasses*)。

## Type and Class

在 Python 3 中，所有自定义类和内置类型([Built-in Types](https://docs.python.org/3.7/library/stdtypes.html#built-in-types))均是新式类。由于新式类将 "类(*class*)" 和 "类型(*type*)" 的概念进行了统一，所以在 Python 3 中 "类(*class*)" 和 "类型(*type*)" 是同义词，两者并没有任何区别。

> 为什么不讨论旧式类：
>
> 因为旧式类由 `types.ClassType` 构造，



新式(*New-style*)在 Python 2.2 中被引入，将 "类(*class*)" 和 "类型(*type*)" 的概念进行了统一，也就是说在新式类中 "类(*class*)" 和 "类型(*type*)" 是同义词，两者并没有任何区别。

我们通常会将术语 "类型(*type*)" 用于内置类型的实例，而将术语 "类(*class*)" 用于自定义类实例。另外在讨论内置类型和自定义类时，我们也会使用 "类型(*type*)"

```python
>>> type("hello")
<class 'str'>
>>> # 通常我们会说字符串是str类型(type)
>>> 
>>> class NewCls(object):pass

>>> type(NewCls())
<class '__main__.NewCls'>
>>> NewCls().__class__
<class '__main__.NewCls'>
>>> # 通常我们会说NewCls()是NewCls类(class)的实例，
>>> # 但本质上而言，新式类就是一个自定义类型(type)，
>>> # 因此，我们同样可以说NewCls()是NewCls类型

>>> type(NewCls)
<class 'type'>
>>> type(int)
<class 'type'>
>>> # 通常我们会说NewCls的类型是名为type的元类
>>> # 同样也会说int的类型是名为type的元类
```





## 自定义元类

自定义元类继承自 type，通过 type 只能创建新式类。所以自定义元类只能创建新式了，无法创建旧式类。





### New-Style Classes

## 注脚

[^1]: https://en.wikipedia.org/wiki/Metaprogramming
[^2]: 
[^3]: https://wiki.python.org/moin/NewClassVsClassicClass
[^4]: [Metaclasses in Five Minutes](http://www.voidspace.org.uk/python/articles/five-minutes.shtml)
[^4]: 













The term **metaprogramming** refers to the potential for a program to have knowledge of or manipulate itself. Python supports a form of metaprogramming for classes called **metaclasses**.

Metaclasses are an esoteric [OOP concept](https://realpython.com/python3-object-oriented-programming/), lurking behind virtually all Python code. You are using them whether you are aware of it or not. For the most part, you don’t need to be aware of it. Most Python programmers rarely, if ever, have to think about metaclasses.

When the need arises, however, Python provides a capability that not all object-oriented languages support: you can get under the hood and define custom metaclasses. The use of custom metaclasses is somewhat controversial, as suggested by the following quote from Tim Peters, the Python guru who authored the [Zen of Python](https://www.python.org/dev/peps/pep-0020):

## 补充知识点

### 特殊属性

#### \_\_class\_\_

instance.\_\_class\_\_

类实例所属的类，可理解为用于实例化当前对象的模板。

```python
>>> type('whale') # 字符串是str类的实例
<class 'str'>
>>> type(str) # str类是type类的实例
<class 'type'>
>>> type(type) # type类是type类的实例
<class 'type'>
```

另外，用户可修改该属性的值。

#### \_\_bases\_\_

class.\_\_bases\_\_

类对象的基类构成的元组，只包含直接基类，并不是继承链上的所有基类

```python
>>> bool.__bases__
(<class 'int'>,)
>>> int.__bases__
(<class 'object'>,)
```



## 术语

#### classic class

in Glossary of Python 2

Any class which does not inherit from [`object`](https://docs.python.org/2/library/functions.html#object). See [new-style class](https://docs.python.org/2/glossary.html#term-new-style-class). Classic classes have been removed in Python 3.

#### new-style class

Any class which inherits from [`object`](https://docs.python.org/2/library/functions.html#object). This includes all built-in types like `list` and [`dict`](https://docs.python.org/2/library/stdtypes.html#dict). Only new-style classes can use Python's newer, versatile features like `__slots__`, descriptors, properties, and [`__getattribute__()`](https://docs.python.org/2/reference/datamodel.html#object.__getattribute__), class methods, and static methods.

More information can be found in [New-style and classic classes](https://docs.python.org/2/reference/datamodel.html#newstyle).

#### object

Any data with state (attributes or value) and defined behavior (methods). Also the ultimate base class of any [new-style class](https://docs.python.org/3.7/glossary.html#term-new-style-class).

#### class

A template for creating user-defined objects. Class definitions normally contain method definitions which operate on instances of the class.

#### type

The type of a Python object determines what kind of object it is; every object has a type. An object’s type is accessible as its [`__class__`](https://docs.python.org/3.7/library/stdtypes.html#instance.__class__) attribute or can be retrieved with`type(obj)`.

#### metaclass

The class of a class. Class definitions create a class name, a class dictionary, and a list of base classes. The metaclass is responsible for taking those three arguments and creating the class. Most object oriented programming languages provide a default implementation. What makes Python special is that it is possible to create custom metaclasses. Most users never need this tool, but when the need arises, metaclasses can provide powerful, elegant solutions. They have been used for logging attribute access, adding thread-safety, tracking object creation, implementing singletons, and many other tasks.

More information can be found in [Metaclasses](https://docs.python.org/3.7/reference/datamodel.html#metaclasses).

More information can be found in [Customizing class creation](https://docs.python.org/2/reference/datamodel.html#metaclasses).



### object

```python
>>> type(object) # 查看object的类型，也就是构造object的模板
<class 'type'>
>>> object.__class__
<class 'type'>
>>> object.__bases__ # object没有父类
()
```



### type

```python
>>> type.__class__
<class 'type'>
>>> type(type)
<class 'type'>
>>> type.__bases__
(<class 'object'>,)
```

type 类中包含了 `__new__` 和 `__init__` ，那么新元类中覆写 `__new__` 的示例是否可通过覆写 `__init__` 完成喃？







```python
# 查看父类元组
>>> object.__bases__
()
>>> type.__bases__
(<class 'object'>,)
>>> int.__bases__
(<class 'object'>,)

# 查看模板
>>> object.__class__
<class 'type'>
```

```python
>>> def fn(self, name='world'):
	print('Hello, %s.' % name)

	
>>> Hello = type('Hello', (object,), dict(hello=fn))
>>> Hello.__bases__
(<class 'object'>,) #object是父类
>>> Hello.__class__
<class 'type'> #type是模板
```

## 







----

https://zhuanlan.zhihu.com/p/21379984 只看最后一个有关元类的示例

https://docs.python.org/3.7/reference/datamodel.html#metaclasses