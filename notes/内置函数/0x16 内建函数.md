# Built-in Functions

查看内置方法列表：`dir(__builtins__)` 中所有小写单词都属于 BIF 。


# eval()、exec()及其相关函数

## 1. eval( )

```
eval(expression, globals=None, locals=None)
```

Evaluate the given expression in the context of globals and locals.

expression 只能执行表达式类型的代码，不支持赋值操作，不支持 import 操作，不能是复杂的代码。

该函数也可用于执行任意 code 对象 (例如通过 `compile()` 创建的对象)。在这种情况下，expression 表示代码对象，而非字符串。如果 code 对象在编码时，使用了 `exce` 作为模式参数，那么`eval()` 的返回值是 None。

提示：`exec()` 函数支持语句的动态执行。 `globals() ` 和 `locals()` 函数分别返回当前全局字典和本地字典，这在向 `eval()` 或 `exec()` 的变量时可能会有用。

**参数说明**

-   expression：该参数可以是一个字符串，该字符串表示一个 Python 表达式；或是通过 `compile()` 返回的 code 对象。
    当 expression 参数是字符串时，expression 被当作 Python 表达式进行解析和计算，并会使用 globals 和 locals 字典作为全局和本地命名空间。如果存在 globals 字典，但是缺少 `__builtins__` ，则在表达式被解析之前，会将会将当前全局变量复制到全局变量中。这意味着表达式通常可以完全访问标准内建函数模块，并且在受限制的环境中被传播。
    `__builtins__` 包含了所有内建函数和值，但是普通的字典不会包含 `__builtins__` 。

    ```
    In [11]: dic={}

    In [12]: dic.keys()
    Out[12]: dict_keys([])

    In [13]: eval('1',dic)
    Out[13]: 1

    In [14]: dic.keys()
    Out[14]: dict_keys(['__builtins__'])
    ```


-   globals：可选参数，表示全局命名空间（存放全局变量），如果被提供，则必须是一个字典对象。
-   locals：可选参数，表示当前局部命名空间（存放局部变量），如果被提供，可以是任何映射对象。
-   如果 globals 与 locals 均被忽略，便会取用 `eval()` 被调用环境下的 globals 和 locals。如果仅给出 globals ，此时会默认 locals 与 globals 相同。

**返回值**：

-   如果 expression 是一个code对象，且创建该code对象时，compile函数的mode 参数是'exec'，那么`eval()` 函数的返回值是None；
-   否则，如果 expression 是一个输出语句，如print()，则 `eval()` 返回结果为None；
-   否则，expression 的计算结果作为返回值；

示例1，演示全局变量和本地变量：

```
x = 10

def func():
    y = 20
    a = eval('x + y')
    print('a: ', a)
    b = eval('x + y', {'x': 1, 'y': 2})
    print('b: ', b)
    c = eval('x + y', {'x': 1, 'y': 2}, {'y': 3, 'z': 4})
    print('c: ', c)
    d = eval('print(x, y)')
    print('d: ', d)

func()
```

输出结果：

```
a:  30
b:  3
c:  4
10 20
d:  None
```

-   对于变量a，eval函数的globals和locals参数都被忽略了，因此变量x和变量y都取得的是eval函数被调用环境下的作用域中的变量值，即：x = 10, y = 20，a = x + y = 30
-   对于变量b，eval函数只提供了globals参数而忽略了locals参数，因此locals会取globals参数的值，即：x = 1, y = 2，b = x + y = 3
-   对于变量c，eval函数的globals参数和locals都被提供了，那么eval函数会先从全部作用域globals中找到变量x, 从局部作用域locals中找到变量y，即：x = 1, y = 3, c = x + y = 4
-   对于变量d，因为print()函数不是一个计算表达式，没有计算结果，因此返回值为None

示例2：

```
 1 可以把list,tuple,dict和string相互转化。
 2 #################################################
 3 字符串转换成列表
 4 >>>a = "[[1,2], [3,4], [5,6], [7,8], [9,0]]"
 5 >>>type(a)
 6 <type 'str'>
 7 >>> b = eval(a)
 8 >>> print b
 9 [[1, 2], [3, 4], [5, 6], [7, 8], [9, 0]]
10 >>> type(b)
11 <type 'list'>
12 #################################################
13 字符串转换成字典
14 >>> a = "{1: 'a', 2: 'b'}"
15 >>> type(a)
16 <type 'str'>
17 >>> b = eval(a)
18 >>> print b
19 {1: 'a', 2: 'b'}
20 >>> type(b)
21 <type 'dict'>
22 #################################################
23 字符串转换成元组
24 >>> a = "([1,2], [3,4], [5,6], [7,8], (9,0))"
25 >>> type(a)
26 <type 'str'>
27 >>> b = eval(a)
28 >>> print b
29 ([1, 2], [3, 4], [5, 6], [7, 8], (9, 0))
30 >>> type(b)
31 <type 'tuple'>
```

示例3：

```
>>> eval("[x for x in range(10)]")
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

当内存中的内置模块含有os的话，eval同样可以做到命令执行：

```
#!python
>>> import os
>>> eval("os.system('whoami')")
win-20140812chjadministrator
0
```

## 2. exec( )

#### 函数的作用：

动态执行Python代码。也就是说exec可以执行复杂的Python代码，而不像eval函数那么样只能计算一个表达式的值。

#### 函数定义：

```
exec(object[, globals[, locals]])
```

#### 参数说明：

-   object：必选参数，表示需要被指定的Python代码。它必须是字符串或code对象。如果object是一个字符串，该字符串会先被解析为一组Python语句，然后在执行（除非发生语法错误）。如果object是一个code对象，那么它只是被简单的执行。
-   globals：可选参数，同eval函数
-   locals：可选参数，同eval函数

#### 返回值：

exec函数的返回值永远为None.

>   需要说明的是在Python 2中exec不是函数，而是一个内置语句(statement)，但是Python 2中有一个execfile()函数。可以理解为Python 3把exec这个statement和execfile()函数的功能够整合到一个新的exec()函数中去了：

#### eval()函数与exec()函数的区别：

-   eval()函数只能计算单个表达式的值，而exec()函数可以动态运行代码段。
-   eval()函数可以有返回值，而exec()函数返回值永远为None。

#### 实例1：

我们把实例1中的eval函数换成exec函数试试：

```
x = 10

def func():
    y = 20
    a = exec('x + y')
    print('a: ', a)
    b = exec('x + y', {'x': 1, 'y': 2})
    print('b: ', b)
    c = exec('x + y', {'x': 1, 'y': 2}, {'y': 3, 'z': 4})
    print('c: ', c)
    d = exec('print(x, y)')
    print('d: ', d)

func()
```

**输出结果：**

```
a:  None
b:  None
c:  None
10 20
d:  None
```

因为我们说过了，exec函数的返回值永远为None。

#### 实例2：

```
x = 10
expr = """
z = 30
sum = x + y + z
print(sum)
"""
def func():
    y = 20
    exec(expr)
    exec(expr, {'x': 1, 'y': 2})
    exec(expr, {'x': 1, 'y': 2}, {'y': 3, 'z': 4})
    
func()
```

**输出结果：**

```
60
33
34
```

**对输出结果的解释：**

前两个输出跟上面解释的eval函数执行过程一样，不做过多解释。关于最后一个数字34，我们可以看出是：x = 1, y = 3是没有疑问的。关于z为什么还是30而不是4，这其实也很简单，我们只需要在理一下代码执行过程就可以了，其执行过程相当于：

```
x = 1
y = 2

def func():
    y = 3
    z = 4
    
    z = 30
    sum = x + y + z
    print(sum)

func()
```

示例

```
>>> a = 1
>>> exec("a = 2")
>>> a
2
```

## 4. compile( )函数

#### 函数的作用：

将source编译为code对象或AST对象。code对象能够通过exec()函数来执行或者通过eval()函数进行计算求值。

#### 函数定义：

```
compile(source, filename, mode[, flags[, dont_inherit]])
```

#### 参数说明：

-   source：字符串或AST（Abstract Syntax Trees）对象，表示需要进行编译的Python代码
-   filename：指定需要编译的代码文件名称，如果不是从文件读取代码则传递一些可辨认的值（通常是用'<string>'）
-   mode：用于标识必须当做那类代码来编译；如果source是由一个代码语句序列组成，则指定mode='exec'；如果source是由单个表达式组成，则指定mode='eval'；如果source是由一个单独的交互式语句组成，则指定mode='single'。
-   另外两个可选参数暂不做介绍

#### 实例：

```
s = """
for x in range(10):
    print(x, end='')
print()
"""
code_exec = compile(s, '<string>', 'exec')
code_eval = compile('10 + 20', '<string>', 'eval')
code_single = compile('name = input("Input Your Name: ")', '<string>', 'single')

a = exec(code_exec)
b = eval(code_eval)

c = exec(code_single)
d = eval(code_single)

print('a: ', a)
print('b: ', b)
print('c: ', c)
print('name: ', name)
print('d: ', d)
print('name; ', name)
```

输出结果：

```
0123456789
Input Your Name: Tom
Input Your Name: Jerry
a:  None
b:  30
c:  None
name:  Jerry
d:  None
name;  Jerry
```

## 5. 这几个函数的关系

comiple()函数、globals()函数、locals()函数的返回结果可以当作eval()函数与exec()函数的参数使用。

另外，我们可以通过判断globals()函数的返回值中是否包含某个key来判断，某个全局变量是否已经存在（被定义）。