# Built-in Functions

查看内置方法列表：`dir(__builtins__)` 中所有小写单词都属于 BIF 。


# eval()、exec()及其相关函数

## 1. eval( )



## 2. exec( )

#### 函数的作用：

动态执行Python代码。也就是说exec可以执行复杂的Python代码，而不像eval函数那么样只能计算一个表达式的值。

#### 函数定义：

```
exec(object[, globals[, locals]])
```

#### 参数说明：

-   object：必选参数，表示需要被指定的Python代码。它必须是字符串或code对象。如果object是一个字符串，该字符串会先被解析为一组Python语句，然后在执行（除非发生语法错误）。如果object是一个code对象，那么它只是被简单的执行。
-   globals：可选参数，同eval函数
-   locals：可选参数，同eval函数

#### 返回值：

exec函数的返回值永远为None.

>   需要说明的是在Python 2中exec不是函数，而是一个内置语句(statement)，但是Python 2中有一个execfile()函数。可以理解为Python 3把exec这个statement和execfile()函数的功能够整合到一个新的exec()函数中去了：

#### eval()函数与exec()函数的区别：

-   eval()函数只能计算单个表达式的值，而exec()函数可以动态运行代码段。
-   eval()函数可以有返回值，而exec()函数返回值永远为None。

#### 实例1：

我们把实例1中的eval函数换成exec函数试试：

```
x = 10

def func():
    y = 20
    a = exec('x + y')
    print('a: ', a)
    b = exec('x + y', {'x': 1, 'y': 2})
    print('b: ', b)
    c = exec('x + y', {'x': 1, 'y': 2}, {'y': 3, 'z': 4})
    print('c: ', c)
    d = exec('print(x, y)')
    print('d: ', d)

func()
```

**输出结果：**

```
a:  None
b:  None
c:  None
10 20
d:  None
```

因为我们说过了，exec函数的返回值永远为None。

#### 实例2：

```
x = 10
expr = """
z = 30
sum = x + y + z
print(sum)
"""
def func():
    y = 20
    exec(expr)
    exec(expr, {'x': 1, 'y': 2})
    exec(expr, {'x': 1, 'y': 2}, {'y': 3, 'z': 4})
    
func()
```

**输出结果：**

```
60
33
34
```

**对输出结果的解释：**

前两个输出跟上面解释的eval函数执行过程一样，不做过多解释。关于最后一个数字34，我们可以看出是：x = 1, y = 3是没有疑问的。关于z为什么还是30而不是4，这其实也很简单，我们只需要在理一下代码执行过程就可以了，其执行过程相当于：

```
x = 1
y = 2

def func():
    y = 3
    z = 4
    
    z = 30
    sum = x + y + z
    print(sum)

func()
```

示例

```
>>> a = 1
>>> exec("a = 2")
>>> a
2
```

## 4. compile( )函数

#### 函数的作用：

将source编译为code对象或AST对象。code对象能够通过exec()函数来执行或者通过eval()函数进行计算求值。

#### 函数定义：

```
compile(source, filename, mode[, flags[, dont_inherit]])
```

#### 参数说明：

-   source：字符串或AST（Abstract Syntax Trees）对象，表示需要进行编译的Python代码
-   filename：指定需要编译的代码文件名称，如果不是从文件读取代码则传递一些可辨认的值（通常是用'<string>'）
-   mode：用于标识必须当做那类代码来编译；如果source是由一个代码语句序列组成，则指定mode='exec'；如果source是由单个表达式组成，则指定mode='eval'；如果source是由一个单独的交互式语句组成，则指定mode='single'。
-   另外两个可选参数暂不做介绍

#### 实例：

```
s = """
for x in range(10):
    print(x, end='')
print()
"""
code_exec = compile(s, '<string>', 'exec')
code_eval = compile('10 + 20', '<string>', 'eval')
code_single = compile('name = input("Input Your Name: ")', '<string>', 'single')

a = exec(code_exec)
b = eval(code_eval)

c = exec(code_single)
d = eval(code_single)

print('a: ', a)
print('b: ', b)
print('c: ', c)
print('name: ', name)
print('d: ', d)
print('name; ', name)
```

输出结果：

```
0123456789
Input Your Name: Tom
Input Your Name: Jerry
a:  None
b:  30
c:  None
name:  Jerry
d:  None
name;  Jerry
```

## 5. 这几个函数的关系

comiple()函数、globals()函数、locals()函数的返回结果可以当作eval()函数与exec()函数的参数使用。

另外，我们可以通过判断globals()函数的返回值中是否包含某个key来判断，某个全局变量是否已经存在（被定义）。