# Iterables vs. Iterators vs. Generators

[TOC]

## 1. 容器

在某些对象中会包含对其它对象的引用，这样的对象被称作**容器**(*containers*)。我们可以把容器视作用于组织各种元素的数据结构。

下面是一些常见的容器对象：

- list, deque, …
- set, frozensets, …
- dict, defaultdict, OrderedDict, Counter, …
- tuple, namedtuple, …
- str

另外，容器是存储在内存中的数据结构，并且通常会将全部的值都保存在内存中(也有一些特例，并不是所有的元素都放在内存，比如迭代器和生成器对象)。

在大多数情况下，当谈到某个容器的值时，我们谈论的仅是值，而不是所包含的对象的 ID(identities)；但是，在讨论容器的可变性时，则只是在谈论容器中直接包含的对象的 ID。因此，如果不可变容器(比如，元组)中包含了对可变对象的引用，那么当被引用的可变对象发生改变时，相应的容器值也将发生改变。[^1]

从技术角度来说，容器是实现了 `__contains__` 方法的对象[^2]，也就是说容器对象肯定可以执行成员测试。

```python
import collections.abc as abc


class Fib(object):
    def __reset(self):
        self.a = 1
        self.b = 1

    def __init__(self):
        self.__reset()

    def __contains__(self, item):
        print("调用 __contains__")
        self.__reset()
        while True:
            self.a, self.b = self.b, self.a + self.b
            if item == self.a:
                return True
            elif item < self.a:
                return False


a_fib = Fib()
assert isinstance(a_fib, abc.Container)
```

注意：尽管绝大多数容器都提供了某种方式来获取其中包含的每一个元素，但这并不是容器本身提供的能力，而是 iterable 赋予了容器这种能力。容器并不一定都是 iterable，比如：[Bloom filter](https://zh.wikipedia.org/wiki/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8) ，虽然 Bloom filter 可以检测某个元素是否存在于容器中，但是并不能从容器中获取其中的每一个值，因为 Bloom filter 并没有把元素存储在容器中，而是通过一个散列函数映射成一个值保存在数组中。

## 2. 可迭代对象



### 生成器函数

Generator functions

语言参考 - [3.1. Objects, values and types](https://docs.python.org/3.7/reference/datamodel.html#objects-values-and-types)

使用 [`yield`](https://docs.python.org/3.6/reference/simple_stmts.html#yield) 语句的函数或方法被称为生成器函数( *generator function* )——可参考 [The yield statement](https://docs.python.org/3.6/reference/simple_stmts.html#yield) 章节。当调用生成器函数时，总会返回一个迭代器(iterator)对象，迭代器对象被用于执行函数体：调用迭代器的 [`iterator.__next__()`](https://docs.python.org/3.6/library/stdtypes.html#iterator.__next__) 方法将使得函数继续执行，直到函数中 [`yield`](https://docs.python.org/3.6/reference/simple_stmts.html#yield) 语句再次提供一个值为止。当函数执行 [`return`](https://docs.python.org/3.6/reference/simple_stmts.html#return) 语句或者结束时会抛出 [`StopIteration`](https://docs.python.org/3.6/library/exceptions.html#StopIteration) 异常，同时迭代器将抵达集合(集合中包含着要返回的值)的尾部。



------

#### \_\_iter\_\_

语言参考 - [3.3.7. Emulating container types](https://docs.python.org/3.7/reference/datamodel.html#emulating-container-types)

`object.__iter__(self)`

当需要容器提供迭代器(iterator)时，便会调用此方法。该方法会返回一个新的迭代器对象，通过该迭代器对象可遍历容器中的所有对象。

迭代器对象同样需要实现该方法，并通过该方法返回其自身。有关迭代器的更多信息，请看 [Iterator Types](https://docs.python.org/3.7/library/stdtypes.html#typeiter) 。



------

## 4.5. Iterator Types

标准库 - [Iterator Types](https://docs.python.org/3.7/library/stdtypes.html#iterator-types)

Python 支持对容器进行迭代(iteration)。本节会使用两种不同的方法来实现迭代器；通过这两种方法便可使得用户定义(user-defined)类支持迭代。序列(Sequences)始终支持迭代方法，详细描述如下。

需要为容器对象定义一个方法，以使其支持迭代：

- `container.__iter__()`

  该方法会返回一个迭代器(iterator)对象。迭代器对象需要支持下面描述的迭代器协议。如果容器支持不同类型的迭代，则可以提供额外的方法来专门请求这些迭代类型的迭代器(支持多种迭代形式的对象的一个例子是树结构，它支持 breadth-first 和 depth-first 两种遍历方式)。 This method corresponds to the [`tp_iter`](https://docs.python.org/3.7/c-api/typeobj.html#c.PyTypeObject.tp_iter) slot of the type structure for Python objects in the Python/C API. 

迭代器对象自身需要支持以下两个方法，这两个共同构成了迭代器协议：

- `iterator.__iter__()`

  返回迭代器对象本身。必须拥有该方法，才能让容器和迭代器能够配合 [`for`](https://docs.python.org/3.7/reference/compound_stmts.html#for) 和 [`in`](https://docs.python.org/3.7/reference/expressions.html#in) 一同使用。This method corresponds to the [`tp_iter`](https://docs.python.org/3.7/c-api/typeobj.html#c.PyTypeObject.tp_iter) slot of the type structure for Python objects in the Python/C API. 

- `iterator.__next__()`

  返回容器中的下一个项。如果不再有可供返回的项，则会抛出 [`StopIteration`](https://docs.python.org/3.7/library/exceptions.html#StopIteration) 异常。This method corresponds to the [`tp_iternext`](https://docs.python.org/3.7/c-api/typeobj.html#c.PyTypeObject.tp_iternext) slot of the type structure for Python objects in the Python/C API.

Python 定义了多个迭代器对象，以支持对如下类型进行迭代：常规(general)序列类型和特殊(specific)序列类型、字典以及其它专业表单(specialized forms)。除迭代器协议的实现之外，其实特定类型并不重要。

一旦迭代器的 [`__next__()`](https://docs.python.org/3.7/library/stdtypes.html#iterator.__next__) 方法抛出 [`StopIteration`](https://docs.python.org/3.7/library/exceptions.html#StopIteration)，则必须在后续调用中继续抛出异常。不遵从此特性的实现被视为以损坏。

### 4.5.1. Generator Types

生成器([generator](https://docs.python.org/3.7/glossary.html#term-generator))提供了一种实现迭代器协议的便捷方式。如果某个容器对象的 [`__iter__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__iter__) 方法以生成器的方式被实现，那么它将自动返回一个支持 [`__iter__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__iter__) 和 [`__next__()`](https://docs.python.org/3.7/reference/expressions.html#generator.__next__) 方法的迭代器对象——从技术上将，该对象其实属于生成器对象。有关生成器的更多信息请查阅 [the documentation for the yield expression](https://docs.python.org/3.7/reference/expressions.html#yieldexpr). 



------

注脚：

[^1]: 语言参考 - [3.1. Objects, values and types](https://docs.python.org/3.7/reference/datamodel.html#objects-values-and-types)
[^2]: 标准库 8.4. [`collections.abc`](https://docs.python.org/3.6/library/collections.abc.html#module-collections.abc) — Abstract Base Classes for Containers
[^3]: [Iterables vs. Iterators vs. Generators](https://nvie.com/posts/iterators-vs-generators/) | [完全理解 Python 迭代对象、迭代器、生成器](http://python.jobbole.com/87805/)
[^]: 