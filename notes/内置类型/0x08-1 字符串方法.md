# 字符串方法

> 本文涵盖了 [String Methods](https://docs.python.org/3.7/library/stdtypes.html#string-methods) 中的知识点，并补充了具体示例。

字符串属于不可变对象，以下方法并不会修改原字符串对象，而是会返回新的字符串。

## 1. 编码

### encode

🔨 str.encode(*encoding="utf-8"*, *errors="strict"*)

Return an encoded version of the string as a bytes object. Default encoding is `'utf-8'`. *errors* may be given to set a different error handling scheme. The default for *errors* is `'strict'`, meaning that encoding errors raise a [`UnicodeError`](https://docs.python.org/3.7/library/exceptions.html#UnicodeError). Other possible values are `'ignore'`, `'replace'`, `'xmlcharrefreplace'`, `'backslashreplace'` and any other name registered via [`codecs.register_error()`](https://docs.python.org/3.7/library/codecs.html#codecs.register_error), see section [Error Handlers](https://docs.python.org/3.7/library/codecs.html#error-handlers). For a list of possible encodings, see section [Standard Encodings](https://docs.python.org/3.7/library/codecs.html#standard-encodings).

```python
# 对字符串进行编码
field = '鲸'
assert field.encode() == b'\xe9\xb2\xb8'
assert field.encode('ascii', 'ignore') == b''
assert field.encode('ascii', 'replace') == b'?'
# 40120是'鲸'的码点值(10进制)
assert field.encode('ascii', 'xmlcharrefreplace') == b'&#40120;'
# u9cb8是'鲸'的码点值(16进制)
assert field.encode('ascii', 'backslashreplace') == b'\\u9cb8'
field.encode('ascii') # 抛出 UnicodeEncodeError 异常
```

Tips: 在 Python 文档中，"编码(*encoding*)"是指将 Unicode 字符串转换为字节序列的规则，也就是说"编码"包含了从"抽象字符序列"到"字节序列"的全部过程；反之，"解码"则包含了从"字节序列"到"抽象字符序列"的全部过程。

## 2. 大小写转换

### capitalize

🔨 str.capitalize()

Return a copy of the string with its first character capitalized and the rest lowercased.

```python
# 将字符串的首个字符转换为大写，剩余字符转换为小写，不具备大小写样式的字符原样保留
>>> 'abc DEF 鲸'.capitalize()
'Abc def 鲸'
>>> 'à'.capitalize()
'À'
# 如果字符没有大小写形式，则保持不变
>>> '鲸 abc DEF'.capitalize()
'鲸 abc def'
```

### casefold

🔨 str.casefold()

Return a casefolded copy of the string. Casefolded strings may be used for caseless matching.

Casefolding is similar to lowercasing but more aggressive because it is intended to remove all case distinctions in a string. For example, the German lowercase letter `'ß'` is equivalent to `"ss"`. Since it is already lowercase, [`lower()`](https://docs.python.org/3.7/library/stdtypes.html#str.lower) would do nothing to `'ß'`; [`casefold()`](https://docs.python.org/3.7/library/stdtypes.html#str.casefold) converts it to `"ss"`.

The casefolding algorithm is described in section 3.13 of the Unicode Standard.

```python
# 将字符串中具备小写形式的字符全部转换为小写字符，不具备大小写样式的字符原样保留
>>> 'ABC !@#%^\n 鲸'.casefold()
'abc !@#%^\n 鲸'
# 和lower的区别是casefold会将所有字符转换为最终的小写形式
>>> 'ß'.casefold() # 不是最终的小写字符，会继续转换
'ss'
>>> 'ß'.lower() # 已是小写字符，不会继续转换
'ß'
```

### lower

🔨 str.lower()

Return a copy of the string with all the cased characters converted to lowercase.

Cased characters are those with general category property being one of “Lu” (Letter, uppercase), “Ll” (Letter, lowercase), or “Lt” (Letter, titlecase). —— 详见本文附录 Letter 小节。

The lowercasing algorithm used is described in section 3.13 of the Unicode Standard.

```python
# 将字符串中具备小写形式的字符全部转换为小写字符，不具备大小写样式的字符原样保留
>>> 'ABC !@#%^\n 鲸'.lower()
'abc !@#%^\n 鲸'
>>> 'ß'.lower()
'ß'
```

### upper

🔨 str.upper()

Return a copy of the string with all the cased characters converted to uppercase. Note that `s.upper().isupper()` might be `False` if `s` contains uncased characters or if the Unicode category of the resulting character(s) is not “Lu” (Letter, uppercase), but e.g. “Lt” (Letter, titlecase).

Cased characters are those with general category property being one of “Lu” (Letter, uppercase), “Ll” (Letter, lowercase), or “Lt” (Letter, titlecase). —— 详见本文附录 Letter 小节。

```python
# 将字符串中具备大写形式的字符全部转换为大写字符，不具备大小写样式的字符原样保留
>>> 'abc !@#%^\n 鲸'.upper()
'ABC !@#%^\n 鲸'
>>> '!@#%^\n 鲸'.upper().isupper()
False
```

### swapcase

🔨 str.swapcase()

Return a copy of the string with uppercase characters converted to lowercase and vice versa. Note that it is not necessarily true that `s.swapcase().swapcase() == s`.

```python
# 将字符串中具备大写形式的字符全部转换为小写字符,反之亦然；
# 不局部大小写样式的字符原样保留
>>> 'abc ß !@#%^\n 鲸'.swapcase()
'ABC SS !@#%^\n 鲸'
# s.swapcase().swapcase() 不一定等于 s
>>> 'ABC SS !@#%^\n 鲸'.swapcase()
'abc ss !@#%^\n 鲸'

```

### title

🔨 str.title()

Return a titlecased version of the string where words start with an uppercase character and the remaining characters are lowercase.

```python
# 将字符串中每个单词的首字符转换为大写，剩余字符转换为小写，不具备大小写样式的字符原样保留
>>> 'Hello world'.title()
'Hello World'
>>> 'Hello world 鲸鱼 !@$#\n\t'.title()
'Hello World 鲸鱼 !@$#\n\t'
```

The algorithm uses a simple language-independent definition of a word as groups of consecutive letters. The definition works in many contexts but it means that apostrophes in contractions and possessives form word boundaries, which may not be the desired result:

```python
# 该算法将非大小写字符作为单词的分组依据，在部分情况下生成的结果和预期不符
# 例如在字符串中遇到名词所有格时，便会对引号后的字符大写
>>> "they're bill's friends from the UK".title()
"They'Re Bill'S Friends From The Uk"
>>> "hello鲸hello\thello#hello".title()
'Hello鲸Hello\tHello#Hello'
```

非大小写字符是指不属于 Letter 的字符，详见本文附录 Letter 小节。

A workaround for apostrophes can be constructed using regular expressions:

```python
# 可以使用正则表达式构建正确使用撇号的方案
>>> import re
>>> def titlecase(s):
...     return re.sub(r"[A-Za-z]+('[A-Za-z]+)?",
...                   lambda mo: mo.group(0)[0].upper() +
...                              mo.group(0)[1:].lower(),
...                   s)
...
>>> titlecase("they're bill's friends.")
"They're Bill's Friends."
```

还可使用 `string.capwords(s, sep=None)` 方法：

```python
>>> import string
>>> s = "they're bill's friends from the UK"
>>> string.capwords(s)
"They're Bill's Friends From The Uk"
```

## 3. 格式化操作

### expandtabs

🔨 str.expandtabs(*tabsize=8*)

Return a copy of the string where all tab characters are replaced by one or more spaces, depending on the current column and the given tab size. Tab positions occur every *tabsize* characters (default is 8, giving tab positions at columns 0, 8, 16 and so on). To expand the string, the current column is set to zero and the string is examined character by character. If the character is a tab (`\t`), one or more space characters are inserted in the result until the current column is equal to the next tab position. (The tab character itself is not copied.) If the character is a newline (`\n`) or return (`\r`), it is copied and the current column is reset to zero. Any other character is copied unchanged and the current column is incremented by one regardless of how the character is represented when printed.

```python
# 将字符串中的所有制表符替换空格，空格的数量取决于当前列的字符数和tablesize
# tabsize用于指定列宽，每列的宽度需等于tabsize，
# 若当前列的实际宽度＜tabsize，剩余部分用0填充；
# 若当前列的实际长度≥tabsize，则将则当前列的宽度增加至tabsize的倍数，剩余部分用0填充
# 比如'01\t012\t0123\t01234'，有4列:01/012/0123/01234
'01\t012\t0123\t01234'.expandtabs()
# '01      012     0123    01234'
# '01234567012345670123456701234567'每列的宽度是8
'01\t012\t0123\t01234'.expandtabs(4)
# '01  012 0123    01234'
# '012301230123012301230123'每列的宽度是4

# 如果遇到'\n'或'\r'，则会重新计算列宽
'01\t012\t0123\n01\t01234'.expandtabs()
# '01      012     0123\n01      01234'
# '01234567012345670123450123456701234567'每列的宽度是8
```

### center

🔨 str.center(*width*[, *fillchar*])

Return centered in a string of length *width*. Padding is done using the specified *fillchar*(default is an ASCII space). The original string is returned if *width* is less than or equal to `len(s)`.

```python
# 以指定宽度width，对字符串进行居中
>>> 'orca_j35'.center(20)
'      orca_j35      '
# fillchar用于指定填充字符，默认是ASCII空格
>>> 'orca_j35'.center(20,'*')
'******orca_j35******'
# 如果width≤len(s)，则返回原字符串
>>> 'orca_j35'.center(1)
'orca_j35'
```

### ljust

🔨 str.ljust(*width*[, *fillchar*])

Return the string left justified in a string of length *width*. Padding is done using the specified *fillchar* (default is an ASCII space). The original string is returned if *width* is less than or equal to `len(s)`.

```python
# 以指定宽度width，对字符串进行左对齐
>>> 'orca_j35'.ljust(20)
'orca_j35            '
# fillchar用于指定填充字符，默认是ASCII空格
>>> 'orca_j35'.ljust(20,'*')
'orca_j35************'
# 如果width≤len(s)，则返回原字符串
>>> 'orca_j35'.ljust(1)
'orca_j35'
```

### rjust

🔨 str.rjust(*width*[, *fillchar*])

Return the string right justified in a string of length *width*. Padding is done using the specified *fillchar* (default is an ASCII space). The original string is returned if *width* is less than or equal to `len(s)`.

```python
# 以指定宽度width，对字符串进行右对齐
>>> 'orca_j35'.rjust(20)
'            orca_j35'
# fillchar用于指定填充字符，默认是ASCII空格
>>> 'orca_j35'.rjust(20,'*')
'************orca_j35'
# 如果width≤len(s)，则返回原字符串
>>> 'orca_j35'.rjust(1)
'orca_j35'
```

### zfill

🔨 str.zfill(*width*)

Return a copy of the string left filled with ASCII `'0'` digits to make a string of length *width*. A leading sign prefix (`'+'`/`'-'`) is handled by inserting the padding *after* the sign character rather than before. The original string is returned if *width* is less than or equal to `len(s)`.

For example:

``` python
# 在字符串左侧填充'0',直至字符串的长度为width
>>> "42".zfill(5)
'00042'
# '+'/'-'会在'0'之前
>>> "-42".zfill(5)
'-0042'
>>> "+42".zfill(5)
'+0042'
>>> '--'.zfill(5)
'-000-'
>>> ' '.zfill(5)
'0000 '
>>> ''.zfill(5)
'00000'
# 其余符号会在'0'之后
>>> "=42".zfill(5)
'00=42'
# 如果width≤len(s)，则返回原字符串
>>> 'orca_j35'.zfill(5)
'orca_j35'
```



### format

🔨 str.format(\**args*, \*\**kwargs*)

> `str.format()` 和 `string.Formatter` 类均采用格式化字符串语法(*Format String Syntax*)，该该语法和 *f-string* 的语法相似，但存在一些区别。有关格式化字符串语法的详细信息可阅读『string — Common string operations.md』。
>
> *f-string*、`string .format()`、`string.Formatter` 使用相同的格式化说明符([format specifier mini-language](https://docs.python.org/3.7/library/string.html#formatspec))，详见笔记『string — Common string operations.md』-> "Format Specification Mini-Language"。

该方法用于执行字符串格式化操作，字符串对象中需包含：文本字面值和替换字段。替换字段是指被置于花括弧(*curly braces*) `{}` 中的表达式，其中可包含位置实参的数值索引，或包含关键字实参的名称。`str.format` 方法会基于当前字符串创建一个新副本，并用实参替换掉副本中对应的字段。

```python
>>> "The sum of 1 + 2 is {0}".format(1+2)
'The sum of 1 + 2 is 3'
```

有关格式化字符串的详细语法，请阅读  [Format String Syntax](https://docs.python.org/3/library/string.html#formatstrings)；`str.format` 与 `string.Formatter` 拥有相同的实现方式，如果想了解 `str.format` 的实现方式 ，可以参考『string — Common string operations.md』-> "Custom String Formatting"。

> Note - When formatting a number ([`int`](https://docs.python.org/3.7/library/functions.html#int), [`float`](https://docs.python.org/3.7/library/functions.html#float), [`complex`](https://docs.python.org/3.7/library/functions.html#complex), [`decimal.Decimal`](https://docs.python.org/3.7/library/decimal.html#decimal.Decimal) and subclasses) with the `n` type (ex: `'{:n}'.format(1234)`), the function temporarily sets the `LC_CTYPE` locale to the `LC_NUMERIC` locale to decode `decimal_point` and`thousands_sep` fields of `localeconv()` if they are non-ASCII or longer than 1 byte, and the `LC_NUMERIC` locale is different than the `LC_CTYPE` locale. This temporary change affects other threads.

Changed in version 3.7: When formatting a number with the `n` type, the function sets temporarily the `LC_CTYPE` locale to the `LC_NUMERIC` locale in some cases.

### format_map

🔨 str.format_map(*mapping*)

Similar to `str.format(**mapping)`, except that `mapping` is used directly and not copied to a [`dict`](https://docs.python.org/3.7/library/stdtypes.html#dict). This is useful if for example `mapping` is a dict subclass:

```python
# 与str.format(**mapping)的区别在于无需对mapping进行解包
>>> student = dict(name='Joy',age=3)
>>> 'My name is {name},i am {age} old'.format_map(student)
'My name is Joy,i am 3 old'
>>> 'My name is {name},i am {age} old'.format(**student)
'My name is Joy,i am 3 old'
```

This is useful if for example `mapping` is a dict subclass:

```python
>>> class Default(dict):
...     def __missing__(self, key):
...         return key
...
>>> '{name} was born in {country}'.format_map(Default(name='Guido'))
'Guido was born in country'
```

New in version 3.2.

## 4. 剥离字符

### strip

🔨 str.strip([*chars*])

Return a copy of the string with the leading and trailing characters removed. The *chars* argument is a string specifying the set of characters to be removed. If omitted or `None`, the *chars* argument defaults to removing whitespace. The *chars* argument is not a prefix or suffix; rather, all combinations of its values are stripped:

```python
# 如果字符串左右两侧直接包含chars中的字符，则会移除这些字符
# chars的默认值是空白符
>>> '   spacious   \t\n'.strip()
'spacious'
>>> 'www.example.com'.strip('cmowz.')
'example'
```

The outermost leading and trailing *chars* argument values are stripped from the string. Characters are removed from the leading end until reaching a string character that is not contained in the set of characters in *chars*. A similar action takes place on the trailing end. For example:

```python
# 遇到不属于chars的字符便会停止剥离
>>> comment_string = '#....... Section 3.2.1 Issue #32 .......'
>>> comment_string.strip('.#! ')
'Section 3.2.1 Issue #32'
```

### lstrip

🔨 str.lstrip([*chars*])

Return a copy of the string with leading characters removed. The *chars* argument is a string specifying the set of characters to be removed. If omitted or `None`, the *chars*argument defaults to removing whitespace. The *chars* argument is not a prefix; rather, all combinations of its values are stripped:

```python
>>> '   spacious   '.lstrip()
'spacious   '
>>> 'www.example.com'.lstrip('cmowz.')
'example.com'
```

### rstrip

🔨 str.rstrip([*chars*])

Return a copy of the string with trailing characters removed. The *chars* argument is a string specifying the set of characters to be removed. If omitted or `None`, the *chars*argument defaults to removing whitespace. The *chars* argument is not a suffix; rather, all combinations of its values are stripped:

```
>>> '   spacious   '.rstrip()
'   spacious'
>>> 'mississippi'.rstrip('ipz')
'mississ'
```

## 5. 字符映射

### translate

🔨 str.translate(*table*)

Return a copy of the string in which each character has been mapped through the given translation table. The table must be an object that implements indexing via [`__getitem__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__getitem__), typically a [mapping](https://docs.python.org/3.7/glossary.html#term-mapping) or [sequence](https://docs.python.org/3.7/glossary.html#term-sequence). When indexed by a Unicode ordinal (an integer), the table object can do any of the following: return a Unicode ordinal or a string, to map the character to one or more other characters; return `None`, to delete the character from the return string; or raise a [`LookupError`](https://docs.python.org/3.7/library/exceptions.html#LookupError) exception, to map the character to itself.

```python
# 该方法会按照table将字符串中的字符映射为指定的字符或字符串
# 在table中需使用码点作为键或索引
>>> table = {ord('a'): '#', ord('b'): '$$'}
>>> 'abcdabcd'.translate(table)
'#$$cd#$$cd'
# 在table中值为None，将被删除
>>> table = {ord('a'): '#', ord('b'): '$$',ord('c'):None}
>>> 'abcdabcd'.translate(table)
'#$$d#$$d'
```

You can use [`str.maketrans()`](https://docs.python.org/3.7/library/stdtypes.html#str.maketrans) to create a translation map from character-to-character mappings in different formats.

See also the [`codecs`](https://docs.python.org/3.7/library/codecs.html#module-codecs) module for a more flexible approach to custom character mappings.
如果想要了解更多自定义字符映射的方法，可以查看 [`codecs`](https://docs.python.org/3.7/library/codecs.html#module-codecs) 模块。

### maketrans

*🔨 static* str.maketrans(*x*[, *y*[, *z*]])

This **static method** returns a translation table usable for [`str.translate()`](https://docs.python.org/3.7/library/stdtypes.html#str.translate).

If there is only one argument, it must be a dictionary mapping Unicode ordinals (integers) or characters (strings of length 1) to Unicode ordinals, strings (of arbitrary lengths) or `None`. Character keys will then be converted to ordinals.

If there are two arguments, they must be strings of equal length, and in the resulting dictionary, each character in x will be mapped to the character at the same position in y. If there is a third argument, it must be a string, whose characters will be mapped to `None`in the result.

```python
# 生成一个共str.translate()使用的table
# 如果使用单参数形式，则x必须是一个字典，
# 该字典的键是Unicode码点或单个字符；该字典的值是码点或字符串或None，
# 如果键是字符，str.maketrans最终也会将其转换为码点
>>> d={97:'!','b':'##','c':None} # a的码点是97
>>> str.maketrans(d)
{97: '!', 98: '##', 99: None}
>>> 'abc'.translate(str.maketrans(d))
'!##'
# 如果使用双参数形式，则x和y必须是长度相同的字符串,
# x中的字符被逐一用作table字典的键，y中的字符被逐一用作table字典的值
>>> str.maketrans('abc','!@#')
{97: 33, 98: 64, 99: 35}
>>> 'abc'.translate(str.maketrans('abc','!@#'))
'!@#'
# 如果使用三参数形式，x和y与双参数的含义与双参数形式相同；
# z必须是一个字符串，该字符串中的字符会被映射为None，值为None的字符将被删除
>>> str.maketrans('abc','!@#','cde')
{97: 33, 98: 64, 99: None, 100: None, 101: None}
>>> 'abcdefg'.translate(str.maketrans('abc','!@#','cde'))
'!@fg'
```

## 6. 统计/查找/索引/替换

### count

🔨 str.count(*sub*[, *start*[, *end*]])

Return the number of non-overlapping occurrences of substring *sub* in the range [*start*, *end*]. Optional arguments *start* and *end* are interpreted as in slice notation.

```python
# 统计字符串中sub的出现次数
>>> 'a1 a2 a3 a4'.count('a')
4
# 可使用start和end指定索引范围
>>> 'a1 a2 a3 a4'.count('a',2)
3
>>> 'a1 a2 a3 a4'.count('a',2,4)
1
>>> 'a1 a2 a3 a4'.count('a',2,-2) # 可接收负索引
2
```

### find&rfind

🔨 str.find(*sub*[, *start*[, *end*]])

Return the lowest index in the string where substring *sub* is found within the slice `s[start:end]`. Optional arguments *start* and *end* are interpreted as in slice notation. Return `-1` if *sub* is not found.

```python
# 从低索引开始查找子串sub，返回第一次出现sub的索引
>>> 'a1 b2 b3 c4'.find('b')
3
# 可使用start和end指定索引范围
>>> 'a1 b2 b3 c4'.find('b',4,-1)
6
# 如果没有找到sub，则返回-1
>>> 'a1 b2 b3 c4'.find('d')
-1
```

Note: The [`find()`](https://docs.python.org/3.7/library/stdtypes.html#str.find) method should be used only if you need to know the position of*sub*. To check if *sub* is a substring or not, use the [`in`](https://docs.python.org/3.7/reference/expressions.html#in) operator:

```python
>>> 'Py' in 'Python'
True
```

🔨 str.rfind(*sub*[, *start*[, *end*]])

Return the highest index in the string where substring *sub* is found, such that *sub* is contained within `s[start:end]`. Optional arguments *start* and *end* are interpreted as in slice notation. Return `-1` on failure.

```python
# 从高索引开始查找子串sub，返回第一次出现sub的索引
>>> 'a1 b2 b3 c4'.rfind('b')
6
# 可使用start和end指定索引范围
# 如果没有找到sub，则返回-1
```

### index&rindex

🔨 str.index(*sub*[, *start*[, *end*]])

Like [`find()`](https://docs.python.org/3.7/library/stdtypes.html#str.find), but raise [`ValueError`](https://docs.python.org/3.7/library/exceptions.html#ValueError) when the substring is not found.

🔨 str.rindex(*sub*[, *start*[, *end*]])

Like [`rfind()`](https://docs.python.org/3.7/library/stdtypes.html#str.rfind) but raises [`ValueError`](https://docs.python.org/3.7/library/exceptions.html#ValueError) when the substring *sub* is not found.

### replace

🔨 str.replace(*old*, *new*[, *count*])

Return a copy of the string with all occurrences of substring *old* replaced by *new*. If the optional argument *count* is given, only the first *count* occurrences are replaced.

```python
# 将字符串中的old子串替换为new子串
>>> 'ab cd ef ef'.replace('ef','##')
'ab cd ## ##'
# count用于设定替换次数
>>> 'ab cd ef ef'.replace('ef','##',1)
'ab cd ## ef'
>>> 'ab cd ef ef'.replace('ef','##',2)
'ab cd ## ##'
```

## 7. 连接/分拆/拆解

### join

🔨 str.join(*iterable*)

Return a string which is the concatenation of the strings in *iterable*. A [`TypeError`](https://docs.python.org/3.7/library/exceptions.html#TypeError) will be raised if there are any non-string values in *iterable*, including [`bytes`](https://docs.python.org/3.7/library/stdtypes.html#bytes) objects. The separator between elements is the string providing this method.

```python
# 将iterable中字符串进行连接，并以调用该方法的字符串作为分隔符
>>> '-'.join(['ab','cd','ef'])
'ab-cd-ef'
>>> '-'.join(['ab'])
'ab'
>>> '-'.join([])
''
>>> '/'.join(dict(name='joy',age=3))
'name/age'
# 如果iterable中包含非字符串对象，则会抛出TypeError异常
# bytes对象同样会引发TypeError异常
```

### partition&rpartition

🔨 str.partition(*sep*)

Split the string at the first occurrence of *sep*, and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return a 3-tuple containing the string itself, followed by two empty strings.

```python
# 该方法会将字符分拆为三个部分
# 从字符串低位索引开始，在一次遇到sep时对字符串进行分拆，会将字符串分拆为3个字符串：
# sep之前的字符构成第一个字符串，sep构成第二个字符串，sep之后的字符构成第三个字符串
>>> 'abcdabcd'.partition('cd')
('ab', 'cd', 'abcd')
>>> 'abcdabcd'.partition('ab')
('', 'ab', 'cdabcd')
>>> 'abcd'.partition('cd')
('ab', 'cd', '')
# 如果字符串中没有sep，也会返回三个元组：
# 原字符串构成第一个字符串，后两个字符串均为空
>>> 'abcdabcd'.partition('ef')
('abcdabcd', '', '')
```

🔨 str.rpartition(*sep*)

Split the string at the last occurrence of *sep*, and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return a 3-tuple containing two empty strings, followed by the string itself.

```python
# 该方法会将字符分拆为三个部分
# 从字符串高位索引开始，在一次遇到sep时对字符串进行分拆，会将字符串分拆为3个字符串：
# sep之前的字符构成第一个字符串，sep构成第二个字符串，sep之后的字符构成第三个字符串
>>> 'abcdabcd'.rpartition('cd')
('abcdab', 'cd', '')
>>> 'abcdabcd'.rpartition('ab')
('abcd', 'ab', 'cd')
>>> 'abcd'.rpartition('ab')
('', 'ab', 'cd')
# 如果字符串中没有sep，也会返回三个元组：
# 前两个字符串均为空，原字符串构成第三个字符串，
>>> 'abcdabcd'.rpartition('ef')
('', '', 'abcdabcd')
```

### split&rsplit

🔨 str.split(*sep=None*, *maxsplit=-1*)

Return a list of the words in the string, using *sep* as the delimiter string. If *maxsplit* is given, at most *maxsplit* splits are done (thus, the list will have at most `maxsplit+1`elements). If *maxsplit* is not specified or `-1`, then there is no limit on the number of splits (all possible splits are made).

If *sep* is given, consecutive delimiters are not grouped together and are deemed to delimit empty strings (for example, `'1,,2'.split(',')` returns `['1', '', '2']`). The *sep*argument may consist of multiple characters (for example, `'1<>2<>3'.split('<>')`returns `['1', '2', '3']`). Splitting an empty string with a specified separator returns `['']`.

```python
# 该方法会以sep作为分隔符，对字符串进行拆解，并返回拆解后的列表
# 拆解操作始于字符的左侧
>>> '1,2,3'.split(',')
['1', '2', '3']
# maxsplit用于指定分解次数；默认值是-1，表示进行最大限度的拆解
>>> '1,2,3'.split(',', maxsplit=1)
['1', '2,3']
>>> ''.split('-')
['']
>>> 'bcd'.split('a')
['bcd']
# 连续的分隔符和尾部的分隔符，均会产生空字符串
>>> '1,2,,,3,'.split(',')
['1', '2', '', '', '3', '']
# sep可以包含多个字符
>>> '1<>2<>3'.split('<>')
['1', '2', '3']
```

If *sep* is not specified or is `None`, a different splitting algorithm is applied: runs of consecutive whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the string has leading or trailing whitespace. Consequently, splitting an empty string or a string consisting of just whitespace with a `None` separator returns `[]`.

```python
# 如果sep的值为None，则会将连续的空白符视为分隔符
>>> '1 2 3'.split()
['1', '2', '3']
>>> '1\t2\n3'.split()
['1', '2', '3']
>>> '1,2,3'.split()
['1,2,3']
>>> '1 2 3'.split(maxsplit=1)
['1', '2 3']
# 字符串的头部和尾部的空白符，不会产生空字符串
>>> '   1   2   3   '.split()
['1', '2', '3']
# 拆解仅包含空白符的字符串会返回一个空列表
>>> '  '.split()
[]
>>> ''.split()
[]
```

🔨 str.rsplit(*sep=None*, *maxsplit=-1*)

Return a list of the words in the string, using *sep* as the delimiter string. If *maxsplit* is given, at most *maxsplit* splits are done, the *rightmost* ones. If *sep* is not specified or `None`, any whitespace string is a separator. Except for splitting from the right, [`rsplit()`](https://docs.python.org/3.7/library/stdtypes.html#str.rsplit)behaves like [`split()`](https://docs.python.org/3.7/library/stdtypes.html#str.split) which is described in detail below.

```python
# 该方法会以sep作为分隔符，对字符串进行拆解，并返回拆解后的列表
# 拆解操作始于字符的右侧，其余行为和split()一致
>>> '1,2,3'.rsplit(',', maxsplit=1)
['1,2', '3']
>>> ',1,2,,3,'.rsplit(',')
['', '1', '2', '', '3', '']
>>> '1 2 3'.rsplit(maxsplit=1)
['1 2', '3']
```

### splitlines

🔨 str.splitlines([*keepends*])

Return a list of the lines in the string, breaking at line boundaries. Line breaks are not included in the resulting list unless *keepends* is given and true.

该方法会将行边界符作为分拆点，将字符串拆解为由多字符串组成的列表。当 *keepends* 为 `True·` 时，则会在结果中保留行边界符。

以下是作为分拆依据的行边界符(*line boundaries*)。注意，行边界符是通用换行符('\n','\r\n','\r')的超集([*universal* *newlines*](https://docs.python.org/3.7/glossary.html#term-universal-newlines))

| Representation | Description                 |
| -------------- | --------------------------- |
| `\n`           | Line Feed                   |
| `\r`           | Carriage Return             |
| `\r\n`         | Carriage Return + Line Feed |
| `\v` or `\x0b` | Line Tabulation             |
| `\f` or `\x0c` | Form Feed                   |
| `\x1c`         | File Separator              |
| `\x1d`         | Group Separator             |
| `\x1e`         | Record Separator            |
| `\x85`         | Next Line (C1 Control Code) |
| `\u2028`       | Line Separator              |
| `\u2029`       | Paragraph Separator         |

Changed in version 3.2: `\v` and `\f` added to list of line boundaries.

```python
# \r\n 被视作一个整体
>>> 'ab c\n\nde fg\rkl\r\n'.splitlines()
['ab c', '', 'de fg', 'kl']
>>> 'ab c\n\nde fg\rkl\r\n'.splitlines(keepends=True)
['ab c\n', '\n', 'de fg\r', 'kl\r\n']
```

Unlike [`split()`](https://docs.python.org/3.7/library/stdtypes.html#str.split) when a delimiter string *sep* is given, this method returns an empty list for the empty string, and a terminal line break does not result in an extra line:

```python
# 在遇到空字符串时，splitlines会返回一个空列表
>>> "".splitlines()
[]
>>> "One line\n".splitlines()
['One line']
```

对比 `split('\n')` :

```python
# 在给定sep时，split会在遇到空字符串时返回一个包含空字符串的列表
>>> ''.split('\n')
['']
>>> 'Two lines\n'.split('\n')
['Two lines', '']
```

## 8. 条件判断

### endswith

🔨 str.endswith(*suffix*[, *start*[, *end*]])

Return `True` if the string ends with the specified *suffix*, otherwise return `False`. *suffix* can also be a tuple of suffixes to look for. With optional *start*, test beginning at that position. With optional *end*, stop comparing at that position.

```python
# 测试字符串是否以suffix结尾
text = 'stop comparing at that position'
assert text.endswith('tion') is True
assert text.endswith(('tom', 'tion')) is True
# 测试 suffix 是否等于 str_obj[start:end]
assert text.endswith('top', 1, 4) is True
assert text.endswith('top', 1, 3) is False
```

### startswith

🔨 str.startswith(*prefix*[, *start*[, *end*]])

Return `True` if string starts with the *prefix*, otherwise return `False`. *prefix* can also be a tuple of prefixes to look for. With optional *start*, test string beginning at that position. With optional *end*, stop comparing string at that position.

```python
# 测试字符串是否以suffix开头
# 测试 suffix 是否等于 str_obj[start:end]
```

### isascii

🔨 str.isascii()

Return true if the string is empty or all characters in the string are ASCII, false otherwise. ASCII characters have code points in the range U+0000-U+007F.

New in version 3.7.

```python
# 测试字符是否只包含ASCII字符
from string import printable
assert r"""!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~""".isascii() is True
assert printable.isascii() is True
assert '¡'.isascii() is False
# 空字符串也会返回 True
assert ''.isascii() is True
```

### isalnum

🔨 str.isalnum()

Return true if all characters in the string are alphanumeric and there is at least one character, false otherwise. A character `c` is alphanumeric if one of the following returns `True`: `c.isalpha()`, `c.isdecimal()`, `c.isdigit()`, or `c.isnumeric()`.

```python
# 测试字符串是否只包含数字和字母
assert 'abc123'.isalnum() is True
assert '逆戟鲸'.isalnum() is True
assert 'abc_123'.isalnum() is False
assert 'abc 123'.isalnum() is False
assert '!'.isalnum() is False
```

### isalpha

🔨 str.isalpha()

Return true if all characters in the string are alphabetic and there is at least one character, false otherwise. Alphabetic characters are those characters defined in the Unicode character database as “Letter”, i.e., those with general category property being one of “Lm”, “Lt”, “Lu”, “Ll”, or “Lo”. Note that this is different from the “Alphabetic” property defined in the Unicode Standard. —— 关于 “Letter” 和 “Lm”, “Lt”, “Lu”, “Ll”, or “Lo”，详见本文附录 Letter 小节。

```python
# 测试字符串是否只包含字母: Lu|Ll|Lt|Lm|Lo
assert 'abc'.isalpha() is True
assert '逆戟鲸'.isalpha() is True
assert 'abc def'.isalnum() is False
assert '123'.isalpha() is False
assert '!'.isalpha() is False
```

### isdecimal

🔨 str.isdecimal()

Return true if all characters in the string are **decimal** characters and there is **at least one** character, false otherwise. Decimal characters are those that can be used to form numbers in base 10, e.g. U+0660, ARABIC-INDIC DIGIT ZERO. Formally a decimal character is a character in the Unicode General Category “Nd”. 

```python
# 测试字符串是否只包含十进制字符:0,1,2,3,4,5,6,7,8,9
assert '0123456789'.isdecimal() is True
assert '0123456789abcdef'.isdecimal() is False
assert '1+j1'.isdecimal() is False
assert '6.1'.isdecimal() is False
# 包括各种语言中表示0,1,2,3,4,5,6,7,8,9的字符
# U+0660~U+0669表示ARABIC-INDIC语系中的0~9
assert ''.join([chr(i) for i in range(0x660, 0x66A)]).isdecimal() is True
```

就笔者目前的知识而言，我认为 **Nd** 属性和 **Numeric_Type=Decimal** 是充要条件。也就是说，当 Numeric_Type=Decimal 时，`isdecimal()` 必定返回 `True`。关于 Nd 和 Numeric_Type，详见本文附录部分。

因为 Decimal ⊂ Digit ⊂ Numeric，所以当 `isdecimal()` 为真，`isdigit()` 和 `isnumeric()` 必定为真：

```python
# 十进制字符
assert '0123456789'.isdecimal() is True
assert '0123456789'.isdigit() is True
assert '0123456789'.isnumeric() is True
# 上标'⁸'
assert '⁸'.isdecimal() is False
assert '⁸'.isdigit() is True
assert '⁸'.isnumeric() is True
# 分数
assert '⅕'.isdecimal() is False
assert '⅕'.isdigit() is False
assert '⅕'.isnumeric() is True
```

### isdigit

🔨 str.isdigit()

Return true if all characters in the string are digits and there is at least one character, false otherwise. Digits include decimal characters and digits that need special handling, such as the compatibility superscript digits. This covers digits which cannot be used to form numbers in base 10, like the Kharosthi(Kharoshthi) numbers. Formally, a digit is a character that has the property value **Numeric_Type=Digit** or **Numeric_Type=Decimal** —— 详见本文附录Numeric_Type。

```python
# 测试字符串是否只包含：十进制字符和需要特殊处理的数字(例如兼容性上标数字)
assert '0123456789'.isdigit() is True
assert '⁸'.isdigit() is True
# 包括不是基于10进制构建数值的数字，如U+10A40表示Kharoshthi语系中的数字1
# 即 '\U00010A40' -> '𐩀'
assert '\U00010A40'.isdecimal() is False
assert '\U00010A40'.isdigit() is True
assert '\U00010A40'.isnumeric() is True
```

Kharosthi(Kharoshthi) 语系的计数方式不是十进制，只有数字 1、2、3、4、10、20、100、1000，详细介绍可查看[Kharosthi - 维基百科](https://en.wikipedia.org/wiki/Kharosthi#Numerals)。

因为 Decimal ⊂ Digit ⊂ Numeric，所以当 `isdigit()` 为真，则 `isnumeric()` 必定为真：

```python
# 十进制字符
assert '0123456789'.isdecimal() is True
assert '0123456789'.isdigit() is True
assert '0123456789'.isnumeric() is True
# 上标'⁸'
assert '⁸'.isdecimal() is False
assert '⁸'.isdigit() is True
assert '⁸'.isnumeric() is True
# 分数
assert '⅕'.isdecimal() is False
assert '⅕'.isdigit() is False
assert '⅕'.isnumeric() is True
```

### isnumeric

🔨 str.isnumeric()

Return true if all characters in the string are numeric characters, and there is at least one character, false otherwise. Numeric characters include digit characters, and all characters that have the Unicode numeric value property, e.g. U+2155, VULGAR FRACTION ONE FIFTH. Formally, numeric characters are those with the property value **Numeric_Type=Digit**, **Numeric_Type=Decimal** or **Numeric_Type=Numeric**. —— 详见本文附录Numeric_Type。

```python
assert '⅕'.isnumeric() is True
assert 'Ⅵ'.isnumeric() is True
assert '贰'.isnumeric() is True
```

因为 Decimal ⊂ Digit ⊂ Numeric，所以当 `isnumeric()` 为真，`isdecimal` 和 `isdigit` 不一定为真：

```python
# 十进制字符
assert '0123456789'.isdecimal() is True
assert '0123456789'.isdigit() is True
assert '0123456789'.isnumeric() is True
# 上标'⁸'
assert '⁸'.isdecimal() is False
assert '⁸'.isdigit() is True
assert '⁸'.isnumeric() is True
# 分数
assert '⅕'.isdecimal() is False
assert '⅕'.isdigit() is False
assert '⅕'.isnumeric() is True
# 罗马数字
assert 'Ⅵ'.isdecimal() is False
assert 'Ⅵ'.isdigit() is False
assert 'Ⅵ'.isnumeric() is True
# 中文
assert '贰'.isdecimal() is False
assert '贰'.isdigit() is False
assert '贰'.isnumeric() is True
```

### isidentifier

🔨 str.isidentifier()

Return true if the string is a valid identifier according to the language definition, section [Identifiers and keywords](https://docs.python.org/3.7/reference/lexical_analysis.html#identifiers).

Use [`keyword.iskeyword()`](https://docs.python.org/3.7/library/keyword.html#keyword.iskeyword) to test for reserved identifiers such as [`def`](https://docs.python.org/3.7/reference/compound_stmts.html#def) and [`class`](https://docs.python.org/3.7/reference/compound_stmts.html#class).

```python
# 测试字符串是否是合法标识符
assert 'if'.isidentifier() is True
assert '_orca_j35'.isidentifier() is True
assert '123_abc'.isidentifier() is False
# keyword.iskeyword()用于测试是否是保留标识符
import keyword
assert keyword.iskeyword('def') is True
```

### isprintable

🔨 str.isprintable()

Return true if all characters in the string are printable or the string is empty, false otherwise. Nonprintable characters are those characters defined in the Unicode character database as “**Other**” or “**Separator**”, excepting the ASCII space (0x20) which is considered printable. (Note that printable characters in this context are those which should not be escaped when [`repr()`](https://docs.python.org/3.7/library/functions.html#repr) is invoked on a string. It has no bearing on the handling of strings written to [`sys.stdout`](https://docs.python.org/3.7/library/sys.html#sys.stdout) or [`sys.stderr`](https://docs.python.org/3.7/library/sys.html#sys.stderr).) —— 关于 “Other” 或 “Separator”，详见本文附录 Separator&Other 小节。

注意，这里所说的可打印字符是指 `repr()` 函数不会转义的字符，与如何处理字符串的写入([`sys.stdout`](https://docs.python.org/3.7/library/sys.html#sys.stdout) 或 [`sys.stderr`](https://docs.python.org/3.7/library/sys.html#sys.stderr) )无关。

```python
# 测试字符串是否只包含可打印字符
assert 'orca_j35'.isprintable() is True
# Unicode字符集中Other或Separator被定义为不可打印字符，但ASCII空格(0x20)除外
assert '\t'.isprintable() is False
assert ' '.isprintable() is True
# 空字符串也会返回 True
assert ''.isprintable() is True
```

### isspace

🔨 str.isspace()

Return true if there are only whitespace characters in the string and there is at least one character, false otherwise. Whitespace characters are those characters defined in the Unicode character database as “**Other**” or “**Separator**” and those with [bidirectional property](https://www.compart.com/en/unicode/bidiclass) being one of “**WS**”, “**B**”, or “**S**”. —— 关于 “Other” 或 “Separator”，详见本文附录 Separator&Other 小节；关于 [bidirectional property](https://www.compart.com/en/unicode/bidiclass)，可阅读 [Bidi_Class](http://unicode.org/reports/tr44/#Bidi_Class) 和 [Bidirectional Class Values](http://unicode.org/reports/tr44/#Bidi_Class_Values) 

```python
# 测试字符串是否只包含空白字符
# Unicode字符集中Other或Separator被定义为空白字符，以及具备双向属性(WS,B,S)的字符
assert ' \t\n\r\v\f'.isspace() is True
assert 'orca_j35'.isspace() is False
# 空字符串会返回False
assert ''.isspace() is False
```

### istitle

🔨 str.istitle()

Return true if the string is a titlecased string and there is at least one character, for example uppercase characters may only follow uncased characters and lowercase characters only cased ones. Return false otherwise.

```python
# 测试字符串是否是首字母大写的字符串
# 大写字符只能位于非大小字符之后，小写字符只能位于小写字符之后
assert 'A'.istitle() is True
assert 'Orca 8@Orca 🐳逆戟鲸Orca'.istitle() is True
assert 'Orca ORca'.istitle() is False
assert 'Orca orca'.istitle() is False
assert 'Orca O#rca'.istitle() is False
assert '35orca'.istitle() is False
# 首字母可以是 Lt 中的字符，详见本文附录 Letter 小节。
assert 'ᾯabc'.istitle() is True
# 汉字属于非大小写字符
assert '逆戟鲸 Orca'.istitle() is True
assert '逆戟鲸orca'.istitle() is False
```

非大小写字符是指不属于 Letter 的字符，详见本文附录 Letter 小节。

### islower

🔨 str.islower()

Return true if all cased characters in the string are lowercase and there is at least one cased character, false otherwise.

Cased characters are those with general category property being one of “Lu” (Letter, uppercase), “Ll” (Letter, lowercase), or “Lt” (Letter, titlecase). —— 详见本文附录 Letter 小节。

```python
# 测试字符串是否只包含小写字符Ll和非大小写字符
assert 'a'.islower() is True
assert 'ƺ'.islower() is True # Latin Small Letter Ezh with Tail
assert 'orca j35 逆戟鲸 !@\n\t'.islower() is True
# 至少需要一个小写字符
assert '逆戟鲸'.islower() is False
```

非大小写字符是指不属于 Letter 的字符，详见本文附录 Letter 小节。

### isupper

🔨 str.isupper()

Return true if all cased characters [[4\]](https://docs.python.org/3.7/library/stdtypes.html#id15) in the string are uppercase and there is at least one cased character, false otherwise.

Cased characters are those with general category property being one of “Lu” (Letter, uppercase), “Ll” (Letter, lowercase), or “Lt” (Letter, titlecase). —— 详见本文附录 Letter 小节。

```python
# 测试字符串是否只包含Lu大写字符和非大小写字符
assert 'A'.isupper() is True
assert 'Æ'.isupper() is True  # Latin Capital Letter Ae
assert 'ORCA J35 逆戟鲸 !@\n\t'.isupper() is True
assert 'Orca'.isupper() is False
# 至少需要一个大写字符
assert '逆戟鲸'.islower() is False
assert '_35'.isupper() is False
```

非大小写字符是指不属于 Letter 的字符，详见本文附录 Letter 小节。



## A. 附录

### Letter

在 [General_Category Values](http://unicode.org/reports/tr44/#GC_Values_Table) 中列举了一般分类属性(*general category property*)，其中关于 "Letter" 的部分如下：

| Abbr | Long                                                         | Description                                       |
| ---- | ------------------------------------------------------------ | ------------------------------------------------- |
| L    | Letter                                                       | Lu \| Ll \| Lt \| Lm \| Lo                        |
| LC   | Cased_Letter                                                 | Lu \| Ll \| Lt                                    |
| Lu   | [Uppercase_Letter](https://www.compart.com/en/unicode/category/Lu) | an uppercase letter                               |
| Ll   | [Lowercase_Letter](https://www.compart.com/en/unicode/category/Ll) | a lowercase letter                                |
| Lt   | [Titlecase_Letter](https://www.compart.com/en/unicode/category/Lt) | a digraphic character, with first part uppercase  |
| Lm   | Modifier_Letter                                              | a modifier letter                                 |
| Lo   | Other_Letter                                                 | other letters, including syllables and ideographs |

字符的第 3 个字段便是其一般分类属性(这里的字段是指 [UnicodeData.txt](https://www.unicode.org/Public/UCD/latest/ucd/) 中每个码点后的字段)，详见 [General_Category](http://unicode.org/reports/tr44/#General_Category)。示例：

```
# 下面是拉丁小写字母'a'/'b'/'c'/'d'
0061;LATIN SMALL LETTER A;Ll;0;L;;;;;N;;;0041;;0041
0062;LATIN SMALL LETTER B;Ll;0;L;;;;;N;;;0042;;0042
0063;LATIN SMALL LETTER C;Ll;0;L;;;;;N;;;0043;;0043
0064;LATIN SMALL LETTER D;Ll;0;L;;;;;N;;;0044;;0044
```

"[Alphabetic](http://unicode.org/reports/tr44/#Alphabetic)" 是一个枚举属性，由 Lowercase + Uppercase + Lt + Lm + Lo + Nl + Other_Alphabetic 构成 —— 欲了解 "Alphabetic " 的详细信息，可阅读 [Property Table](http://unicode.org/reports/tr44/#Property_List_Table) - [Alphabetic](http://unicode.org/reports/tr44/#Alphabetic)。

可见，在标准 Unicode 中 "[Alphabetic](http://unicode.org/reports/tr44/#Alphabetic)" 涵盖范围大于 "Letter"。

欲了解 Unicode 一般分类属性，可阅读：

- https://www.compart.com/en/unicode/category
- http://www.fileformat.info/info/unicode/category/index.htm

### Nd

在 [General_Category Values](http://unicode.org/reports/tr44/#GC_Values_Table) 中列举了一般分类属性，其中关于 "Number" 的部分如下：

| Abbr | Long                                                         | Description                       |
| ---- | ------------------------------------------------------------ | --------------------------------- |
| N    | Number                                                       | Nd \| Nl \| No                    |
| Nd   | [Decimal_Number](https://www.compart.com/en/unicode/category/Nd) | a decimal digit                   |
| Nl   | [Letter_Number](https://www.compart.com/en/unicode/category/Nl) | a letterlike numeric character    |
| No   | [Other_Number](https://www.compart.com/en/unicode/category/No#UNC_CAT) | a numeric character of other type |

字符的第 3 个字段便是其一般分类属性(这里的字段是指 [UnicodeData.txt](https://www.unicode.org/Public/UCD/latest/ucd/) 中每个码点后的字段)，详见 [General_Category](http://unicode.org/reports/tr44/#General_Category)。

如果需要查看 Nd 中的码点和抽象字符，可阅读 [List of Unicode Characters of Category “Decimal Number”](https://www.compart.com/en/unicode/category/Nd#UNC_CAT)

### Separator&Other

在 [General_Category Values](http://unicode.org/reports/tr44/#GC_Values_Table) 中列举了一般分类属性(*general category property*)，其中关于 "Separator" 和 "Other" 的部分如下：

| Abbr | Long                                                         | Description                                        |
| ---- | ------------------------------------------------------------ | -------------------------------------------------- |
| Zs   | [Space_Separator](https://www.compart.com/en/unicode/category/Zs) | a space character (of various non-zero widths)     |
| Zl   | Line_Separator                                               | U+2028 LINE SEPARATOR only                         |
| Zp   | Paragraph_Separator                                          | U+2029 PARAGRAPH SEPARATOR only                    |
| Z    | **Separator**                                                | Zs \| Zl \| Zp                                     |
| Cc   | Control                                                      | a C0 or C1 control code                            |
| Cf   | Format                                                       | a format control character                         |
| Cs   | Surrogate                                                    | a surrogate code point                             |
| Co   | Private_Use                                                  | a private-use character                            |
| Cn   | Unassigned                                                   | a reserved unassigned code point or a noncharacter |
| C    | **Other**                                                    | Cc \| Cf \| Cs \| Co \| Cn                         |



### Numeric_Type

Decimal、Digit、Numeric 三者的关系是：Decimal⊂Digit⊂Numeric

#### Decimal

如果字符的 Numeric_Type 属性等于 **Decimal**，那么该字符的 6、7、8 三个字段都会包含同一个数字(这里的字段是指 [UnicodeData.txt](https://www.unicode.org/Public/UCD/latest/ucd/) 中每个码点后的字段)，且该数字是位于 0~9 之间的某个值。也就是说 Numeric_Type=Decemal 的字符是指用于十进制计数系统的字符。详见 [Numeric_Type](http://unicode.org/reports/tr44/#Numeric_Type)。

Numeric_Type=Decemal 的示例，这些字符的 6、7、8 三个字段均包含同一个数字：

![decemal](0x06-1 字符串方法.assets/decemal.png)

```
# 下面是常见的10进制数字
0030;DIGIT ZERO;Nd;0;EN;;0;0;0;N;;;;;
0031;DIGIT ONE;Nd;0;EN;;1;1;1;N;;;;;
0032;DIGIT TWO;Nd;0;EN;;2;2;2;N;;;;;
0033;DIGIT THREE;Nd;0;EN;;3;3;3;N;;;;;
0034;DIGIT FOUR;Nd;0;EN;;4;4;4;N;;;;;
0035;DIGIT FIVE;Nd;0;EN;;5;5;5;N;;;;;
0036;DIGIT SIX;Nd;0;EN;;6;6;6;N;;;;;
0037;DIGIT SEVEN;Nd;0;EN;;7;7;7;N;;;;;
0038;DIGIT EIGHT;Nd;0;EN;;8;8;8;N;;;;;
0039;DIGIT NINE;Nd;0;EN;;9;9;9;N;;;;;
# 下面是Kharoshthi语系中的数字
0660;ARABIC-INDIC DIGIT ZERO;Nd;0;AN;;0;0;0;N;;;;;
0661;ARABIC-INDIC DIGIT ONE;Nd;0;AN;;1;1;1;N;;;;;
0662;ARABIC-INDIC DIGIT TWO;Nd;0;AN;;2;2;2;N;;;;;
0663;ARABIC-INDIC DIGIT THREE;Nd;0;AN;;3;3;3;N;;;;;
0664;ARABIC-INDIC DIGIT FOUR;Nd;0;AN;;4;4;4;N;;;;;
0665;ARABIC-INDIC DIGIT FIVE;Nd;0;AN;;5;5;5;N;;;;;
0666;ARABIC-INDIC DIGIT SIX;Nd;0;AN;;6;6;6;N;;;;;
0667;ARABIC-INDIC DIGIT SEVEN;Nd;0;AN;;7;7;7;N;;;;;
0668;ARABIC-INDIC DIGIT EIGHT;Nd;0;AN;;8;8;8;N;;;;;
0669;ARABIC-INDIC DIGIT NINE;Nd;0;AN;;9;9;9;N;;;;;
```

#### Digit

如果字符的 Numeric_Type 属性等于 **Digit**，那么该字符的 7、8  两个字段会包含同一个数字，但字段 6 为空(这里的字段是指 [UnicodeData.txt](https://www.unicode.org/Public/UCD/latest/ucd/) 中每个码点后的字段)，且该数字是位于 0~9 之间的某个值。在 Decimal 的基础上包含需要特殊处理的数字(例如兼容性上标数字)。

从 Unicode 6.3.0 开始，不会给新编码的数字字符赋予 Numeric_Type=Digit，也不会将具备 Numeric_Type=Numeric 的现有字符字符改为 Numeric_Type=Digit，Digit 和 Numeric 之间的区别不再有实际意义。详见 [Numeric_Type](http://unicode.org/reports/tr44/#Numeric_Type)。

Numeric_Type=Digit  的示例，这些字符的 7、8 两个字段包含同一个数字，字段 6 为空：

![digit](0x06-1 字符串方法.assets/digit.png)

```
# 下面是上标'⁸'和'⁹'
2078;SUPERSCRIPT EIGHT;No;0;EN;<super> 0038;;8;8;N;SUPERSCRIPT DIGIT EIGHT;;;;
2079;SUPERSCRIPT NINE;No;0;EN;<super> 0039;;9;9;N;SUPERSCRIPT DIGIT NINE;;;;
# 下面是下标'₀'和'₁'
2080;SUBSCRIPT ZERO;No;0;EN;<sub> 0030;;0;0;N;SUBSCRIPT DIGIT ZERO;;;;
2081;SUBSCRIPT ONE;No;0;EN;<sub> 0031;;1;1;N;SUBSCRIPT DIGIT ONE;;;;
```

#### Numeric

如果字符的 Numeric_Type 属性等于 **Numeric**，那个该字符的仅字段 8 会包含一个数值，字段 6、7 为空(这里的字段是指 [UnicodeData.txt](https://www.unicode.org/Public/UCD/latest/ucd/) 中每个码点后的字段)。在 Digit 的基础上包含了正(负)整数或有理数——包括分数，例如 U+2155 表示分数 '⅕'，详见 [Numeric_Type](http://unicode.org/reports/tr44/#Numeric_Type)。在 Unihan 中某些字符也具备此属性，见 [Numeric_Type, Han](http://unicode.org/reports/tr44/#Numeric_Type_Han)。

Numeric_Type=Numeric 的示例，这些字符仅字段 8 会包含一个数值，字段 6、7 为空：

![Numeric](0x06-1 字符串方法.assets/Numeric.png)

```
# 下面是一些分数
2150;VULGAR FRACTION ONE SEVENTH;No;0;ON;<fraction> 0031 2044 0037;;;1/7;N;;;;;
2151;VULGAR FRACTION ONE NINTH;No;0;ON;<fraction> 0031 2044 0039;;;1/9;N;;;;;
2152;VULGAR FRACTION ONE TENTH;No;0;ON;<fraction> 0031 2044 0031 0030;;;1/10;N;;;;;
2153;VULGAR FRACTION ONE THIRD;No;0;ON;<fraction> 0031 2044 0033;;;1/3;N;FRACTION ONE THIRD;;;;
2154;VULGAR FRACTION TWO THIRDS;No;0;ON;<fraction> 0032 2044 0033;;;2/3;N;FRACTION TWO THIRDS;;;;
2155;VULGAR FRACTION ONE FIFTH;No;0;ON;<fraction> 0031 2044 0035;;;1/5;N;FRACTION ONE FIFTH;;;;
```

## B. 参考

- [Python 的内置字符串方法（收藏专用）](https://segmentfault.com/a/1190000004598007)





