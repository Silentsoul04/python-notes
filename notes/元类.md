# Metaclasses







特殊属性

- instance.\_\_class\_\_

  类实例所属的类，可理解为当前实例的模板

  ```python
  >>> type('whale') # 字符串是str类的实例
  <class 'str'>
  >>> type(str) # str类是type类的实例
  <class 'type'>
  >>> type(type) # type类是type类的实例
  <class 'type'>
  ```

- class.\_\_bases\_\_

  类对象的基类构成的元组，只包含直接基类，并不是继承链上的所有基类

  ```python
  >>> bool.__bases__
  (<class 'int'>,)
  >>> int.__bases__
  (<class 'object'>,)
  ```



```python
# 查看父类元组
>>> object.__bases__
()
>>> type.__bases__
(<class 'object'>,)
>>> int.__bases__
(<class 'object'>,)

# 查看模板
>>> object.__class__
<class 'type'>
```

```python
>>> def fn(self, name='world'):
	print('Hello, %s.' % name)

	
>>> Hello = type('Hello', (object,), dict(hello=fn))
>>> Hello.__bases__
(<class 'object'>,) #object是父类
>>> Hello.__class__
<class 'type'> #type是模板
```

## Old-Style vs. New-Style Classes

Old-Style 类仅存在于 Python 2 中，不会默认继承 `object` 类，而是继承 `type` 类。

Python2中的旧类如下面代码所示：

```
class oldStyleClass: # inherits from 'type'
    pass
```

Python2中定义一个新类：

```
class newStyleClass(object): # explicitly inherits from 'object'
    pass
```

在Python3中所有的类均默认继承`object`，所以并不需要显式地指定`object`为基类。

以`object`为基类可以使得所定义的类具有新类所对应的方法（`methods`）和属性（`properties`）。

在下面的文章中我们会分别基于新类和旧类探讨`__new__`和`__init__`。



----

https://zhuanlan.zhihu.com/p/21379984 只看最后一个有关元类的示例



