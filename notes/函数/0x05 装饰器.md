# 0x05 装饰器

Decorator

> GitHub@[orca-j35](https://github.com/orca-j35)，所有笔记均托管于 [python_notes](https://github.com/orca-j35/python_notes) 仓库
>
> 参考：
>
> - ﹝流畅的 Python﹞-> 第 7 章 函数装饰器和闭包
>
> 扩展阅读：
>
> - [Primer on Python Decorators – Real Python](https://realpython.com/primer-on-python-decorators/) ⭐
> - [装饰器 — Intermediate Python](https://eastlakeside.gitbooks.io/interpy-zh/content/decorators/)
> - [会打扮的装饰器 · Python 之旅](https://funhacks.net/explore-python/Functional/decorator.html)
> - [DRY Principles through Python Decorators](http://y.tsutsumi.io/dry-principles-through-python-decorators.html)
> - [装饰器 - 廖雪峰](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014318435599930270c0381a3b44db991cd6d858064ac0000)
> - [Python 的闭包和装饰器](https://segmentfault.com/a/1190000004461404)
> - http://www.cnblogs.com/vamei/archive/2013/02/16/2820212.html
> - [PEP 318 -- Decorators for Functions and Methods](https://www.python.org/dev/peps/pep-0318/)
> - [PEP 318: Decorators for Functions and Methods - What’s New in Python 2.4](https://docs.python.org/3.7/whatsnew/2.4.html?highlight=classmethod#pep-318-decorators-for-functions-and-methods)
> - [PEP 3129 -- Class Decorators](https://www.python.org/dev/peps/pep-3129/)
> - See the documentation for [function definitions](https://docs.python.org/3.7/reference/compound_stmts.html#function) and [class definitions](https://docs.python.org/3.7/reference/compound_stmts.html#class) for more about decorators.

装饰器([*decorator*](https://docs.python.org/3.7/glossary.html#term-decorator))是可调用的对象，可通过函数或类实现；装饰器参数可以是另一个函数(函数装饰器)，也可以是某个类(类装饰器)。关于类装饰器，详见﹝流畅的 Python﹞-> 第 21 章 类元编程，这里只介绍函数装饰器。

假设已有名为 `decorate` 的装饰器：

```python
@decorate
def target():
    print('running target()')
```

那么，上述代码与下面的代码等效：

```python
def target():
    print('running target()')

target = decorate(target)
```

装饰器以另一个函数作为参数，装饰器的返回值可以是任意可调用对象，例如：

```python
def deco(func):
    def inner():
         print('running inner()')
    return inner # 需以可调用对象作为返回值

@deco
def target():
    print('running target()')

# 因为装饰器将inner作为返回值，所以在调用target时，其实会运行inner
target() #> running inner()
# target现在指向inner
target #> <function __main__.deco.<locals>.inner>
```

严格来说，装饰器只是语法糖。如前所示，装饰器可以像常规的可调用对象那样调用，其参数是另一个函数。

## 叠放装饰器

```python
@d1
@d2
def f():
    print('f')
```

等效于：

```python
def f():
    print('f')
f = d1(d2(f))
```

## 何时执行装饰器

装饰器会在被装饰的函数定义后立即运行，因此装饰器会在加载模块时立即执行，但是被装饰的函数只有在调用时才会被执行。

```python
# registration.py
# BEGIN REGISTRATION

registry = []  # 保存被@register装饰过的函数的引用

def register(func):  # 装饰器以函数作为参数
    print('running register(%s)' % func)
    registry.append(func)
    return func

@register # 在定义f1之后，立即进行装饰
def f1():
    print('running f1()')

@register
def f2():
    print('running f2()')

def f3():
    print('running f3()')

def main():
    print('running main()')
    print('registry ->', registry)
    f1()
    f2()
    f3()

if __name__=='__main__':
    main()

# END REGISTRATION
```

作为脚本运行时，`$ python3 registration.py`：

```python
running register(<function f1 at 0x0000026286F5BAE8>)
running register(<function f2 at 0x0000026287038F28>)
running main()
registry -> [<function f1 at 0x0000026286F5BAE8>, <function f2 at 0x0000026287038F28>]
running f1()
running f2()
running f3()
```

作为模块导入时：

```python
>>> import registration
running register(<function f1 at 0x10063b1e0>)
running register(<function f2 at 0x10063b268>)
```

## 实现简单的装饰器

```python
# clockdeco.py
import time
def clock(func):
    def clocked(*args):
        t0 = time.time()
        result = func(*args) # func是clocked的自由变量
        elapsed = time.time() - t0
        name = func.__name__
        arg_str = ', '.join(repr(arg) for arg in args)
        print('[%0.8fs] %s(%s) -> %r' % (elapsed, name, arg_str, result))
        return result
    return clocked # 用clocked替换func
```

使用 `clock` 装饰器：

```python
# clockdeco_demo.py

import time
from clockdeco import clock

@clock
def snooze(seconds):
    time.sleep(seconds)

@clock
def factorial(n):
    return 1 if n < 2 else n*factorial(n-1)
'''等价于
def factorial(n):
    return 1 if n < 2 else n*factorial(n-1)
factorial = clock(factorial)
'''

if __name__=='__main__':
    print('*' * 40, 'Calling snooze(.123)')
    snooze(.123)
    print('*' * 40, 'Calling factorial(6)')
    print('6! =', factorial(6))
    print(factorial) # factorial已指向clock
```

输出：

```python
**************************************** Calling snooze(.123)
[0.12399006s] snooze(0.123) -> None
**************************************** Calling factorial(6)
[0.00000000s] factorial(1) -> 1
[0.00022674s] factorial(2) -> 2
[0.00036836s] factorial(3) -> 6
[0.00044465s] factorial(4) -> 24
[0.00044465s] factorial(5) -> 120
[0.00094700s] factorial(6) -> 720
6! = 720
<function clock.<locals>.clocked at 0x000001D45933C7B8>
```

`clockdeco.py` 中实现的 `clock` 装饰器有几个缺点：不支持关键字参数，而且遮盖了被装饰函数的 `__name__` 和 `__doc__` 属性。下面使用 [`functools.wraps`](https://docs.python.org/3.6/library/functools.html#functools.wraps) 装饰器把相关的属性从 `func` 复制到 `clocked` 中。此外，这个新版还能正确处理关键字参数。

```python
# clockdeco2.py

import time
import functools

def clock(func):
    @functools.wraps(func)
    def clocked(*args, **kwargs): # 支持关键字参数
        t0 = time.time()
        result = func(*args, **kwargs)
        elapsed = time.time() - t0
        name = func.__name__
        arg_lst = []
        if args:
            arg_lst.append(', '.join(repr(arg) for arg in args))
        if kwargs:
            pairs = ['%s=%r' % (k, w) for k, w in sorted(kwargs.items())]
            arg_lst.append(', '.join(pairs))
        arg_str = ', '.join(arg_lst)
        print('[%0.8fs] %s(%s) -> %r ' % (elapsed, name, arg_str, result))
        return result
    return clocked
```

### 示例

创建了一个 `retry` 装饰器，如果在运行中抛出了任何错误，它就会尝试重新运行，直到最大次数 5 次，并且每次运行期间都会有一定的延迟。这在对一台远程计算机进行网络调用的情况十分有用：

```python
# 该示例来自﹝byte-of-python﹞
from time import sleep
from functools import wraps
import logging
logging.basicConfig()
log = logging.getLogger("retry")


def retry(f):
    @wraps(f)
    def wrapped_f(*args, **kwargs):
        MAX_ATTEMPTS = 5
        for attempt in range(1, MAX_ATTEMPTS + 1):
            try:
                return f(*args, **kwargs)
            except:
                log.exception("Attempt %s/%s failed : %s",
                              attempt,
                              MAX_ATTEMPTS,
                              (args, kwargs))
                sleep(10 * attempt)
        log.critical("All %s attempts failed : %s",
                     MAX_ATTEMPTS,
                     (args, kwargs))
    return wrapped_f


counter = 0


@retry
def save_to_database(arg):
    print("Write to a database or make a network call or etc.")
    print("This will be automatically retried if exception is thrown.")
    global counter
    counter += 1
    # 这将在第一次调用时抛出异常
    # 在第二次运行时将正常工作（也就是重试）
    if counter < 2:
        raise ValueError(arg)


if __name__ == '__main__':
    save_to_database("Some bad value")
```

输出：

```
$ python more_decorator.py
Write to a database or make a network call or etc.
This will be automatically retried if exception is thrown.
ERROR:retry:Attempt 1/5 failed : (('Some bad value',), {})
Traceback (most recent call last):
  File "more_decorator.py", line 14, in wrapped_f
    return f(*args, **kwargs)
  File "more_decorator.py", line 39, in save_to_database
    raise ValueError(arg)
ValueError: Some bad value
Write to a database or make a network call or etc.
This will be automatically retried if exception is thrown.
```

## 标准库中的装饰器

> 详见：
>
> - ﹝流畅的 Python﹞-> 7.8　标准库中的装饰器
>
> - [functools — 函数操作工具箱](https://pythoncaff.com/docs/pymotw/functools-function-operation-toolbox/92)

Python 有三个内置装饰器函数：`@property` , `@classmethod` , `@staticmethod`。

使用 `@abc.abstractmethod` 可实现抽象方法，见笔记﹝抽象方法.md﹞

在标准库的 `functools` 模块中也提供了一些装饰器，这里介绍三个常见的：

- 🔨 @functools.lru_cache(*maxsize=128*, *typed=False*)

  该装饰器实现了备忘(memoization)功能，会让某函数具有最近最小缓存机制。所有传递过来的参数都会被哈希化，用于后续结果的映射。之后再次调用相同的参数时会从缓存中直接调取出结果而不再经过函数运算。同时此装饰器还给原函数加了一个用于检测缓存状态的方法(`cache_info()`)和一个清空缓存的方法(`cache_clear()`)。

- 🔨 @functools.singledispatch

  在动态类型语言(如 Python)中，经常有在执行时需要辨别不同类型的参数的需求，比如要处理的是一个列表里的数据还是一个单个的数据。直接检测参数的类型当然简单，但不同的功能也可以写到不同的函数中，所以 `functools` 提供了 `singledispatch()` 装饰器来让我们注册 *泛型函数* 以自动基于类型进行切换。

- 🔨 @functools.wraps(*wrapped*, *assigned=WRAPPER_ASSIGNMENTS*, *updated=WRAPPER_UPDATES*)

  使用装饰器时，原函数名会指向装饰器返回的函数，因此 `__name__` 等属性也会发生变化，例如：

  ```python
  def log(func):
      def wrapper(*args, **kw):
          print('call %s():' % func.__name__)
          return func(*args, **kw) 
      return wrapper
      
  @log
  def now():
      print('2017-7-21')
  
  now.__name__ #> 'wrapper'
  now()
  #> call now():
     2017-7-21
  ```

  这会导致某些依赖函数签名的代码，在执行时出错。为了避免这样的错误，需要把原 `now` 函数对象中的 `__name__` 等属性复制到 `wrapper` 函数对象中。`functools.wraps` 装饰器可把相关的属性从 `now` 复制到 `wrapper` 中，并不需要额外编写 `wrapper.__name__ = func.__name__` 这样的代码。

  因此，一个完整的装饰器的写法如下：

  ```python
  import functools
  
  def log(func):
      @functools.wraps(func)
      def wrapper(*args, **kw):
          print('call %s():' % func.__name__)
          return func(*args, **kw)
      return wrapper
  ```

  `@functools.wraps` 还有一个重要的特点：可以通过 `__wrapped__` 再次访问原函数，如 `func.__wrapped__(*args,**kwargs)`。需要注意的是：

  - 如果有多个装饰器同时用上述方法装饰某个函数，则 `__wrapped__` 得到的结果不可预知。也可能是原函数，或解除一个装饰器效果。
  - 内置的装饰器 `@staticmethod` 和 `@classmethod` 就没有遵循这个约定 (它们把原始函数存储在属性 `__func__` 中)。


## 参数化装饰器

创建一个装饰器工厂函数，把参数传给它，返回一个装饰器，然后再把它应用到要装饰的函数上。

为了便于理解，先给出一个无参数的装饰器：

```python
# registration.py 
registry = []

def register(func):
    print('running register(%s)' % func)
    registry.append(func)
    return func

@register
def f1():
    print('running f1()')

print('running main()')
print('registry ->', registry)
f1()
```

为了便于启用或禁用 `register` 执行的函数注册功能，我们为它提供一个可选的 `active` 参数，设为 `False` 时，不注册被装饰的函数。但是从概念上看，下面这个新的 `register` 函数并不是装饰器，而是装饰器工厂函数。需要调用它才会返回真正的装饰器，这才是应用到目标函数上的装饰器。

```python
# BEGIN REGISTRATION_PARAM

registry = set()  # 使用set，可获得更快的添加和删除速度

def register(active=True):  # 装饰器工厂函数，可接受参数
    def decorate(func):  # 这才是真正的装饰器，它的参数是一个函数。
        print('running register(active=%s)->decorate(%s)'
              % (active, func))
        if active:   # <4>
            registry.add(func)
        else:
            registry.discard(func)  # <5>
            
        return func  # 装饰器必须返回一个可调用对象
    return decorate  # 装饰器工厂函数会返回一个装饰器

@register(active=False)  # 必需调用工厂函数
def f1():
    print('running f1()')

@register()  # 必需调用工厂函数
def f2():
    print('running f2()')

def f3():
    print('running f3()')

# END REGISTRATION_PARAM
```

输出：

```python
running register(active=False)->decorate(<function f1 at 0x000002A30EFDC950>)
running register(active=True)->decorate(<function f2 at 0x000002A30EFDC9D8>)
```

如果不使用 `@` 句法，那就要像常规函数那样使用 `register`；若想把 `f` 添加到 `registry` 中，则装饰 `f` 函数的句法是 `register()(f)`；不想添加（或把它删除）的话，句法是 `register(active=False)(f)`。

下面来看一个复杂一点的例子：

```python
import functools
def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw): # 增加了一层函数
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
```

## 基于类的装饰器

同样可以基于类来实现装饰器，例如：

```python
class Bold(object):
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        return '<b>' + self.func(*args, **kwargs) + '</b>'

@Bold
def hello(name):
    return 'hello %s' % name

>>> hello('world')
'<b>hello world</b>'
```

可以看到，类 `Bold` 有两个方法：

- `__init__()`：它接收一个函数作为参数，也就是被装饰的函数
- `__call__()`：让类对象可调用，就像函数调用一样，在调用被装饰函数时被调用

还可以让类装饰器带参数：

```python
class Tag(object):
    def __init__(self, tag):
        self.tag = tag

    def __call__(self, func):
        def wrapped(*args, **kwargs):
            return "<{tag}>{res}</{tag}>".format(
                res=func(*args, **kwargs), tag=self.tag
            )
        return wrapped

@Tag('b')
def hello(name):
    return 'hello %s' % name
```

需要注意的是，如果类装饰器有参数，则 `__init__` 接收参数，而 `__call__` 接收 `func`。

### 参数化

下面这个示例展示了如何将基于类的装饰器参数化：

```python
from functools import wraps

class logit(object):
    def __init__(self, logfile='out.log'):
        self.logfile = logfile

    def __call__(self, func):
        @wraps(func) # wraps
        def wrapped_function(*args, **kwargs):
            log_string = func.__name__ + " was called"
            print(log_string)
            # 打开logfile并写入
            with open(self.logfile, 'a') as opened_file:
                # 现在将日志打到指定的文件
                opened_file.write(log_string + '\n')
            # 现在，发送一个通知
            self.notify()
            return func(*args, **kwargs)
        return wrapped_function

    def notify(self):
        # logit只打日志，不做别的
        pass
```

参考自: https://eastlakeside.gitbooks.io/interpy-zh/content/decorators/deco_class.html

## 使用场景

用装饰器实现设计模式中的单例模式(singleton)

```
def singleton(cls, *args, **kwargs):
    instance = {}

    def __singleton():
        if cls not in instance:
            instance[cls] = cls
        return instance[cls]

    return __singleton


@singleton
class MyClass:
    kind = "type"

    def __init__(self, name):
        self.name = name


@singleton
class MyAnotherClass:
    name = "another"

    def __init__(self, age):
        self.age = age


one = MyClass()
two = MyClass()
print(id(one))
print(id(two))


another_one = MyAnotherClass()
another_two = MyAnotherClass()
print(id(another_one))
print(id(another_two))
```

## 类装饰器

```python
def decorator(aClass):
    class newClass:
        def __init__(self, age):
            self.total_display   = 0
            self.wrapped = aClass(age)
        def display(self):
            self.total_display += 1
            print("total display", self.total_display)
            self.wrapped.display()
    return newClass

@decorator
class Bird:
    def __init__(self, age):
        self.age = age
    def display(self):
        print("My age is",self.age)

eagleLord = Bird(5)
for i in range(3):
    eagleLord.display()
```



