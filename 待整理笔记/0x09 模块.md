# 0x09 模块

Modules

[TOC]

## 1. 组织模块的结构 Packsges 

Packages 是通过 “dotted module names” 来构造 Python 模块命名空间的一种方式。例如，模块名 A.B 表示 A 的 package 中的 B 子模块。

Packages 是按目录**组织模块**的方法，不同目录中可以存在相同名称的模块。
Package 作为放置模块的文件夹，拥有一个名为 `__init__.py` 的特殊文件。
该文件向 Python 表明这是一个内含模块的特殊文件夹。

命名模块时，不能和 Python 自带的模块名称冲突。
例如，系统自带了 `sys`  模块。此时自己所写的模块便不可以命名为 `sys.py` ，否则将无法导入系统自带的 `sys` 模块。

### \_\_init\_\_.py

每个 Package 目录下都会有一个名为 `__ini__.py` 的特殊文件。
该文件向 Python 表明这是一个内含模块的特殊文件夹。
该文件必须存在，否则 Python 便会将其视为普通目录。

`__init__.py` 本身就是一个模块，其名称就是 Package 的名称。
它可以是空文件，也可以执行 Package 的初始化代码，或者设置 `__all__ ` 变量。

下例中，`__init__.py` 的名称便是 `mycompany`

```
- <some folder present in the sys.path>/
    - mycompany/
        - __init__.py
        - abc.py
        - xyz.py
```

### 多级目录

Packages 可以拥有多级目录结构。

```
- <some folder present in the sys.path>/
    - mycompany/
        - __init__.py
        - abc.py
        - xyz.py
        - web/
        	- __init__.py
        	www.py
        	utils.py
```

两个 `utils.py` 的模块名分别是 `mycompany.utils` 和 `mycompany.web.utils` 。
`mycompany.web` 也是一个模块，该模块对应 `mycompany.web.__init__.py` 文件。

### 避免命名冲突

通过 Package 按目录对模块进行组织。
可以有效避免命名冲突。

```
- <some folder present in the sys.path>/
    - mycompany/
        - __init__.py
        - abc.py
        - xyz.py
```

当 `abc.py` 和 `xyz.py` 与其它模块名冲突时，可将这两个模块放入包中。
只要顶层包 `mycompany` 保证唯一性，即可有效避免模块冲突。
注意：此时模块的名称发生了改变：`abc.py` 变为 `mycompany.abc.py` 。

### 包导入

#### import vs from...import

如下，设计了一个用于处理声音文件和声音数据的模块集合(package)。

```
sound/                          Top-level package
      __init__.py               Initialize the sound package
      formats/                  Subpackage for file format conversions
              __init__.py
              wavread.py
              wavwrite.py
              aiffread.py
              aiffwrite.py
              auread.py
              auwrite.py
              ...
      effects/                  Subpackage for sound effects
              __init__.py
              echo.py
              surround.py
              reverse.py
              ...
      filters/                  Subpackage for filters
              __init__.py
              equalizer.py
              vocoder.py
              karaoke.py
              ...
```

-   从 package 中导入单个模块：

```
import sound.effects.echo

# This loads the submodule sound.effects.echo. It must be referenced with its full name.
>>> sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)
```

-   导入子模块的另一种方式：

```
from sound.effects import echo

# This also loads the submodule echo, and makes it available without its package prefix, so it can be used as follows:
>>> echo.echofilter(input, output, delay=0.7, atten=4)
```

-   最后一种是直接导入所需的函数或变量：

```
from sound.effects.echo import echofilter

#Again, this loads the submodule echo, but this makes its function echofilter() directly available:
>>> echofilter(input, output, delay=0.7, atten=4)
```

Note that when using `from package import item`, the item can be either a **submodule** (or subpackage) of the package, or some other name defined in the package, like **a function, class or variable**. The `import` statement first tests whether the item is defined in the package; if not, it assumes it is a module and attempts to load it. If it fails to find it, an [`ImportError`](https://docs.python.org/3/library/exceptions.html#ImportError) exception is raised.

Contrarily, when using syntax like `import item.subitem.subsubitem`, each item except for the last must be a package; the last item can be a module or a package but **can’t be a class or function or variable** defined in the previous item.



#### from Package import *

现在来仔细研究下 `from sound.effects import *` 语句。
理想情况下，我们希望 `sound.effects` 被以某种方式发送到文件系统，然后查找 Package 中存在子模块，并将其全部导入。这可能需要很长的时间，并且当子模块被明确导入时，这些子模块可能会产生不必要的副作用。

对于包作者而言，唯一的解决方案就是提供明确的包索引。
 [`import`](https://docs.python.org/3/reference/simple_stmts.html#import) 语句遵循如下约定：如果某个包的 `__init__.py` 中定义了名为 `__all__` 的列表。当遇到 `from packageimport *` 时，则将该列表视为应导入的模块名称的列表。当新版本的包被发布时，包作者应该保存对此表的更新。如果认为 importing * from package 没什么用处的话，包作者也可不支持该列表。
示例： `sound/effects/__init__.py`  若包含如下代码：

```
__all__ = ["echo", "surround", "reverse"]
```

这表示 `from sound.effects import *` 将会导入 `sound` 包的三个子模块。

如果没有定义 `__all__` ， `from sound.effects import *` 并不会将 `sound.effects` 包中所有子模块导入到当前命名空间中；该代码只能保证 `sound.effects` 包被导入(possibly running any initialization code in `__init__.py`)，然后导入包中定义的任何名称。这包括通过 `__init__.py` 定义的任何名称 (and submodules explicitly明确 loaded)。还同时包含任何之前通过  [`import`](https://docs.python.org/3/reference/simple_stmts.html#import) 语句明确加载的 package 的子模块。

考虑如下代码：

```
import sound.effects.echo
import sound.effects.surround
from sound.effects import *
```

In this example, the `echo` and `surround` modules are imported in the current namespace because they are defined in the `sound.effects` package when the `from...import` statement is executed. (This also works when `__all__` is defined.)

Although certain modules are designed to export only names that follow certain patterns when you use `import *`, it is still considered bad practice in production code.

Remember, there is nothing wrong with using `from Package import specific_submodule`! In fact, this is the recommended notation unless the importing module needs to use submodules with the same name from different packages.

#### Intra-package References

When packages are structured into subpackages (as with the `sound` package in the example), you can use absolute imports to refer to submodules of siblings packages. For example, if the module `sound.filters.vocoder` needs to use the `echo` module in the `sound.effects` package, it can use `from sound.effects import echo`.

You can also write relative相对 imports, with the `from module import name` form of import statement. These imports use leading dots to indicate the current and parent packages involved in the relative import. From the `surround` module for example, you might use:

```
from . import echo #从当前模块所在文件夹导入echo
from .. import formats
from ..filters import equalizer
```

Note that relative imports are based on the name of the current module. Since the name of the main module is always `"__main__"`, modules intended for use as the main module of a Python application must always use absolute imports.

1. 文件夹中必须有 `__init__.py` 文件，该文件可以为空，但必须存在该文件。

2. 如果模块的某个文件夹中的 `.py` 文件使用了相对导入，那么该文件夹中的 `.py` 文件都不可作为顶层模块来执行（即不能作为主函数的入口）。否则相对导入不能正常运行。因为顶层模块不在被视作 package，所以解释器无法正确解释相对路径。使用 `-m` 也不行

   

### Packages in Multiple Directories

Packages support one more special attribute, [`__path__`](https://docs.python.org/3/reference/import.html#__path__). 
This is initialized to be a list containing the name of the directory holding the package’s `__init__.py` before the code in that file is executed. 在该文件中的代码被执行之前，它被初始化为包含保存包的 `__init__.py` 的目录的名称的列表。 
This variable can be modified; doing so affects future searches for modules and subpackages contained in the package.

While this feature is not often needed, it can be used to extend the set of modules found in a package.

```
>>> import learn_py

>>> learn_py.__path__
['C:\\Users\\iwhal\\Documents\\learn_py']
```



## 2. 初识模块

Python 程序包含一个或多个模块(module)。模块就是包含 Python 代码的一个 `.py` 文件，其中可以包含语句、函数定义和类定义。简短的 Python 程序也称为脚本(script)，可以包含在一个模块之中。较为复杂的程序通常会包含一个主模块和一个或多个支持模块——主模块包含了程序执行的起点，支持模块则包含了函数定义和类定义。

模块等级的语句被用于初始化模块，会在第一次导入(`import`) 模块时被执行——如果直接运行模块，同样会执行这些语句。

- 模块中位于函数定义和类定义之外的语句会直接执行
- 模块等级的函数定义和类定义语句会将函数名和类名导入模块的全局符号表中。

下面这个示例中，module_1.py 和 module_2.py 位于同一目录下：

```python
# module_1.py 内容如下
import module_2
print("模块1")
class ClassDef_1(object):
    print("模块1：类定义")
def funDef_2(args):
    print("模块1：函数定义")
print(dir().__str__() +"\n")
print(dir(module_2))

# module_2.py 内容如下
print("模块2")
class ClassDef_2(object):
    print("模块2：类定义")
    def function(args):
        print("模块2：函数定义")
def funDef_2(args):
    print("模块2：函数定义")
```

运行 `module_1.py` 输出如下：

```python
模块2
模块2：类定义
模块1
模块1：类定义
['ClassDef_1', '__builtins__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'funDef_2', 'module_2']

['ClassDef_2', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'funDef_2']
```

在不同的模块中可以使用相同的函数名和变量名，但尽量不要与 [内置函数](https://docs.python.org/3/library/functions.html#built-in-functions) 冲突。

每个模块都有自己的**私有符号表**，模块内所有函数定义都会将模块的私有符号表当作**全局符号表**使用。因此，模块的作者可以在模块内部使用全局变量，而无需担心它与某个用户的全局变量意外冲突。可以使用 `modname.itemname` 访问模块的全局变量。

### 模块的注释

示例，以内建的`sys`模块为例，编写一个`hello`的模块：

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

' a test module '

__author__ = 'Michael Liao'
__version__ = '0.1'

import sys

def test():
    args = sys.argv
    if len(args)==1:
        print('Hello, world!')
    elif len(args)==2:
        print('Hello, %s!' % args[1])
    else:
        print('Too many arguments!')

if __name__=='__main__':
    test()
```

-   第1行和第2行是标准注释，第1行注释可以让该 `hello.py` 文件直接在Unix/Linux/Mac 上运行，第2行注释表示 `.py` 文件本身使用标准UTF-8编码；
-   第4行是一个字符串，表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释；
-   第6行使用 `__author__` 变量表示作者名。
-   第7行使用 `__version__` 变量表示版本。

以上就是 Python 模块的标准文件模板，当然也可以全部删掉不写，但是，按标准办事肯定没错。

### 作用域

在模块中，通常会定义很多的函数和变量。
部分函数和变量会提供给别人使用，但是另外一些函数和变量则仅能在模块内部使用。

#### 公共名称的作用域

公共 - public
正常的函数和变量名属于 public，可以**被直接引用**，比如：`abc`，`x123`，`PI` 等；

类似 `__xxx__` 这样的变量名用于表示特殊变量，也可**被直接引用**。
比如： `__name__` 表示模块的名称；`__author__` 表示作者名称；`__doc__` 表示模块注释。
注意：自定义的名称一般不要使用特殊变量名。

#### 私有名称的作用域

私有 private
类似 `_xxx` 和 `__xxx` 这样的名称属于 private。
“不应该” 直接引用私有名称。
注意：Python 中并没有一种方法可以完全限制对私有函数或私有变量的访问。
但从编程习惯上而言，“不应该” 引用这些私有函数或私有变量。

同 OOP 中的私有变量 `__xxx` 不同，模块中的 `__xxx` 可直接被访问。
并不会被像 OOP 中的 `__xxx`  一样，会被自动修改名称。

##### 私有函数/变量的用途：

```
def _private_1(name):
    return 'Hello, %s' % name

def _private_2(name):
    return 'Hi, %s' % name

def greeting(name):
    if len(name) > 3:
        return _private_1(name)
    else:
        return _private_2(name)
```

`greeting()` 属于公共函数，但其内部逻辑被两个私有函数进行了隐藏。
因此，调用 `greeting()` 函数时，不用关心模块内部私有函数的实现细节。

这是一种非常有用的代码封装和抽象的方法。
即：外部不需要引用的函数全部定义成 private，只有外部需要引用的函数才定义为public。

### \_\_name\_\_ 属性

A module's `__name__` 

每个 Python 模块都内含一组内建模块变量，当加载该模块时，Python 虚拟机会自动为这些变量赋值。

如果某个模块独立运行，其全局变量 `__name__` 会被设置为`"__main__"` ；如果通过 `import` 语句导入了某个模块，被导入的模块的 `__name__` 变量会被设置为该模块的名称。

```
In [18]: import time

In [19]: time.__name__
Out[19]: 'time'
```

在一些特殊情况下这非常有用。
比如用来确定模块的运行状态（独立运行，或被导入）。
当模块第一次被导入时，它所包含的代码会被执行。
此时，使用 `__name__` 属性，便可让模块以不同的方式执行。

Example (save as `module_using_name.py`):

```
if __name__ == '__main__':
    print('This program is being run by itself')
else:
    print('I am being imported from another module')
```

Output:

```
# 将module_using_name.py文件当作脚本执行
C:\Users\iwhal\Documents>python module_using_name.py
This program is being run by itself

# 将xxx.py文件当模块启动
C:\Users\iwhal\Documents>python -m module_using_name.py
I am being imported from another module
C:\Python361\python.exe: Error while finding module specification for 'learn.py' (AttributeError: module 'learn' has no attribute '__path__')

# 将xxx.py文件作为模块导入
C:\Users\iwhal\Documents>python
Python 3.6.1 (v3.6.1:69c0db5, Mar 21 2017, 18:41:36) [MSC v.1900 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> import learn
I am being imported from another module
```

### 编译后的.pyc文件

“Compiled” Python files / Byte-compiled .pyc files

**旧版本**的 Python 中通常会在与 `.py` 文件相同的目录下创建 `.pyc` 文件。
如果 Python 没有相应目录的写入权限，则无法创建 `.pyc` 文件。

>   To speed up loading modules, Python caches the compiled version of each module in the `__pycache__` directory under the name `module.version.pyc`, where the version encodes the format of the compiled file; it generally contains the Python version number. For example, in CPython release 3.3 the compiled version of `spam.py` would be cached as `__pycache__/spam.cpython-33.pyc`. This naming convention allows compiled modules from different releases and different versions of Python to coexist.

为了更快加载模块，Python 将每个模块的编译版本缓存在 `__pycache__` 目录中的名称为 `module.version.pyc` 的文件内，这里的 version 编码了文件编译后的格式；version 中通常包含了 Python 的版本号。例如，在 CPython 发布 3.3 中 `spam.py` 的编译版本将被缓存为 `__pycache__/spam.cpython-33.pyc`。这种命名约定允许由不同发布和不同版本的 Python 编译的模块同时存在。

>   Python checks the modification date of the source against the compiled version to see if it’s out of date and needs to be recompiled. This is a completely automatic process. Also, the compiled modules are platform-independent, so the same library can be shared among systems with different architectures.

Python 针对编译版本，特别检查源的修改日期，以查看它是否过期，并需要重新编译。这是一个完全自动的过程。此外，编译的模块是与平台无关的，因此可以在具有不同架构的系统之间共享相同的库。

>   Python does not check the cache in two circumstances. First, it always recompiles and does not store the result for the module that’s loaded directly from the command line. Second, it does not check the cache if there is no source module. To support a non-source (compiled only) distribution, the compiled module must be in the source directory, and there must not be a source module.

Python 在两种情况下不检查缓存。首先，对于直接总命令行加载的模块，Python 总是重新编译并且不会储存结果。第二，如果没有源模块，它不检查缓存。要支持没有源文件（仅编译版）的分发，编译的模块必须位于源目录中，并且不能有源模块。

>   Some tips for experts:
>
>   -   You can use the [`-O`](../using/cmdline.html#cmdoption-O) or [`-OO`](../using/cmdline.html#cmdoption-OO) switches on the Python command to reduce the size of a compiled module. The `-O` switch removes assert statements, the `-OO` switch removes both assert statements and `__doc__` strings. Since some programs may rely on having these available, you should only use this option if you know what you’re doing. “Optimized” modules have an `opt-` tag and are usually smaller. Future releases may change the effects of optimization. 
>   -   A program doesn’t run any faster when it is read from a `.pyc` file than when it is read from a `.py` file; the only thing that’s faster about `.pyc` files is the speed with which they are loaded. 
>   -   The module [`compileall`](../library/compileall.html#module-compileall) can create .pyc files for all modules in a directory. 
>   -   There is more detail on this process, including a flow chart of the decisions, in PEP 3147. 

给专家的提示：

-   您可以在 Python 命令中使用 [`-O`](../using/cmdline.html#cmdoption-O) or [`-OO`](../using/cmdline.html#cmdoption-OO) 开关来减小已编译模块的大小。  `-O` 开关删除 assert 语句， `-OO` 开关删除assert语句和 `__doc__` 字符串。由于一些程序可能依赖于这些变量的可用性，你应该只在确定无误的场合使用这一选项。

    “优化” 模块有一个 `opt-` 标签，并且通常较小。未来的版本可能会改变优化的效果。

-   程序从 `.pyc` 文件读取时不会比从 `.py` 文件读取时运行的更快；关于`.pyc` 文件的唯一的一点是它们的加载速度。

-   模块 [`compileall`](../library/compileall.html#module-compileall) 可以为目录中的所有模块创建 .pyc 文件。

-   在PEP 3147 中有关于这个过程的更多细节，包括决策的流程图。

### 标准模块

Standard Modules

>   Python comes with a library of standard modules, described in a separate document, the Python Library Reference (“Library Reference” hereafter). Some modules are built into the interpreter; these provide access to operations that are not part of the core of the language but are nevertheless built in, either for efficiency or to provide access to operating system primitives such as system calls. The set of such modules is a configuration option which also depends on the underlying platform. For example, the [`winreg`](https://docs.python.org/3/library/winreg.html#module-winreg) module is only provided on Windows systems. One particular module deserves some attention: [`sys`](https://docs.python.org/3/library/sys.html#module-sys), which is built into every Python interpreter. The variables `sys.ps1` and `sys.ps2` define the strings used as primary and secondary prompts:

Python 附带了一个标准模块库，在另一个单独的文档中描述，Python Library Reference（以下简称“Library Reference” ）。 一些模块内置在解释器中；库引用提供了对内置操作的访问，这些内置操作不是核心语言的一部分，这既是为了提高效率，也是为了提供对操作系统原生访问（例如系统调用）。这样的模块集合是也取决于底层平台的配置选项。 例如， [`winreg`](https://docs.python.org/3/library/winreg.html#module-winreg) 模块仅在Windows 系统上提供。 一个特定的模块值得一些注意:  [`sys`](https://docs.python.org/3/library/sys.html#module-sys)，它是内置到每个Python解释器。 变量 `sys.ps1` 和 `sys.ps2` 定义用作主提示和辅助提示的字符串：

```
>>> import sys
>>> sys.ps1
'>>> '
>>> sys.ps2
'... '
>>> sys.ps1 = 'C> '
C> print('Yuck!')
Yuck!
C>
```

>   These two variables are only defined if the interpreter is in interactive mode.

这两个变量只在解释器处于交互模式时才被定义。

>   The variable `sys.path` is a list of strings that determines the interpreter’s search path for modules. It is initialized to a default path taken from the environment variable [`PYTHONPATH`](https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH), or from a built-in default if [`PYTHONPATH`](https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH) is not set. You can modify it using standard list operations:

```
import sys
sys.path.append('/ufs/guido/lib/python')
```





## 3. 模块的使用

### 模块重载

**Note**:  出于效率的原因，每个模块在每个解释器会话中只导入一次。 
因此，如果模块进行了更改，则必须重新启动解释器；
或者重载该模块 `importlib.reload()`, 

```
import importlib

importlib.reload(modulename)
```



### 将 .py 作为脚本执行

Executing modules as scripts

使用命令 `python fibo.py <arguments>` 运行 Python 模块时。
模块中的代码会被执行，如同使用 `import` 导入一样。
但是此时模块的 `__name__` 会被设置为 `"__main__"` ，并且当前模块所处的路径不会被添加到 `sys.path` 中。

示例：

```
# learn.py

if __name__ == '__main__':
    import sys
    print('This program is being run by itself')
    print(sys.argv[1])
    print('__name__=',__name__)
else:
    print('I am being imported from another module')
    print('__name__=',__name__)
```

若向模块添加 `if __name__ == "__main__":` 代码，便可使得 `learn.py` 即可作为脚本运行，也可作为模块被启动，或作为模块被导入。

```
# 作为脚本运行
C:\Users\iwhal\Documents>python learn.py hello
This program is being run by itself
hello
__name__= __main__

# 作为模块启动
C:\Users\iwhal\Documents>python -m  learn.py
I am being imported from another module
__name__= learn
C:\Python361\python.exe: Error while finding module specification for 'learn.py' (AttributeError: module 'learn' has no attribute '__path__')

# 作为模块导入
C:\Users\iwhal\Documents>python
Python 3.6.1 (v3.6.1:69c0db5, Mar 21 2017, 18:41:36) [MSC v.1900 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> import learn
I am being imported from another module
__name__= learn
```

这通常用于为模块提供便捷的用户接口，或用于测试目的(running the module as a script executes a test suite)。

### 将模块作为脚本执行

﹝将模块作为脚本执行(python -m).md﹞

### 将 .py 作为模块导入

#### import

在 `A` 模块中导入 `B` 模块时，`B` 模块的名称会被放置到 `A` 模块的全局符号表中。

```
>>> dir()
['__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__']

# 导入模块
>>> import sys
>>> dir
<built-in function dir>
>>> dir()
['__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', 'sys']

```

 `import` 语句并不会向**当前作用域**中直接导入 `sys` 模块中定义的函数名/变量名，仅仅是将 `sys` 的模块名，添加到了当前作用域中。

如果某函数很常用，则可将其分配给本地名称：

```
>>> path_=sys.path
>>> dir()
['__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', 'path_', 'sys']
```

如果需要重命名被导入的模块，可以使用 `as` 限定符：

```
import sys as sys_rename
sys_rename.path
```



#### from...import

直接将模块中的相应名称导入到当前作用域中。
注意：此方法不会向**当前作用域**的**本地符号表**中引入被导入模块的名称。

警告：应该尽量避免使用 `from..import` 语句，而是使用`import` 语句。这样可避免命名冲突，并且也更易阅读。

Example:

```
from math import sqrt
print("Square root of 16 is", sqrt(16))
```



####  from moduleName import *

这种方法会向**当前作用域**的**本地符号表**中导入 `moduleName ` 下，除下划线 `_` 开头的所有名称。

在大多数情况下，不要使用该语句。
因为它会向解释器中引入了一组未知的名称，这可能会与当前作用域中已定义的名称相冲突。




## 5. 为模块构建“发布”

在 PyPI 上共享自己编写的模块时，需要为模块准备一个“发布”。
“发布 distribution” 是指一个文件集合，该集合会有效组织其中的文件，以允许构建/打包/发布模块。构建好 distribution 后，便可把相应的模块安装到本地 Py 副本中，也可以把模块上传到 PyPI。

利用发布工具允许将模块转换为可共享的包。

PyPI (Python Package Index) : Python 包索引是第三方 Python 模块的储存库

### 构建“发布”

-   首先将模块放入相应的文件夹中；

-   再在该文件夹中创建 `setup.py` 文件，此文件包含有关发布的元数据 metadata ，用于构建、安装和上传打包的 “发布”。

    ```
    from distutils.core import setup
    setup(
        name='nester',
        version='1.0.0',
        py_modules=['nester'],
        author='hfpython',
        author_email='zxcvb@xc.com',
        url='http://www.dad.com',
        description='A simple printer of nested lists'
    )
    ```

    此时，文件夹中只有两个文件

    ```
    - nester/
        - nester.py #源代码
        - setup.py #元数据
    ```

-   构建 ’发布‘，在命令行中输入 `python setup.py sdist` ，在mac中可能是 `python3 setup.py sdist ` 。

    ```
    C:\Users\iwhal\Desktop\learn_python\nester>python setup.py sdist
    running sdist
    running check
    warning: sdist: manifest template 'MANIFEST.in' does not exist (using default file list)

    warning: sdist: standard file not found: should have one of README, README.txt

    writing manifest file 'MANIFEST'
    creating nester-1.0.0
    making hard links in nester-1.0.0...
    hard linking nester.py -> nester-1.0.0
    hard linking setup.py -> nester-1.0.0
    creating dist
    Creating tar archive
    removing 'nester-1.0.0' (and everything under it)
    ```

    此时会增加相应文件：

    ```
    - nester/
        - nester.py #源代码
        - setup.py #元数据
        - MANIFEST #‘发布’中的文件列表
        - dist/
        	- nester-1.0.0.tar.gz #distribution package
    ```

### 将“发布”安装到本地

将’发布‘安装到本地的 Py 副本中： `python setup.py install` ，在mac中可能是 `sudo python3 setup.py install ` 

```
​```
C:\Users\iwhal\Desktop\learn_python\nester>python setup.py install
running install
running build
running build_py
creating build
creating build\lib
copying nester.py -> build\lib
running install_lib
copying build\lib\nester.py -> C:\Python361\Lib\site-packages
byte-compiling C:\Python361\Lib\site-packages\nester.py to nester.cpython-36.pyc
running install_egg_info
Writing C:\Python361\Lib\site-packages\nester-1.0.0-py3.6.egg-info
​```
```

此时会增加更多文件：

```
​```
- nester/
    - nester.py #源代码
    - setup.py #元数据
    - MANIFEST #‘发布’中的文件列表
    - dist/
    	- nester-1.0.0.tar.gz #distribution package
    - build/
    	- lib/
    		nester.py #源代码
​```
```

完成以上步骤后，便成功将模块安装到了本地 Py 副本中，此时只需要 `import nester` 便可正常使用该模块了。  

### 将“发布”上传到PyPI

在命令行中输入 `python setup.py register` ，登陆PyPI。
登陆完成后，输入 `python setup.py sdlist upload` ，上传发布。
注意，上传后得到`Server response (200): OK` ，才表示上传成功。

## 补充

### sys.argv

`sys.argv` 使用列表存储命令行的所有参数。
`sys.argv` 至少有一个元素，因为第一个参数永远是该 .py 文件的名称。

例如：
运行 `python3 hello.py` 时 `sys.argv = ['hello.py']`；
运行 `python3 hello.py Michael` 时 `sys.argv = ['hello.py', 'Michael]`。

### os.getcwd( )

Return a unicode string representing the current working directory.

```
In [12]: import os

In [13]: os.getcwd()
Out[13]: 'C:\\Users\\iwhal\\Documents'
```

