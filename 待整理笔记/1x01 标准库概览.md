# 标准库概览

[TOC]

-   导入模块时，使用类似 `import os` 的方式，不要使用 `from os import *` 。因为这样可能会覆盖内置函数，比如 `os.open()` 会应为不恰当的导入方式，而覆盖了内置函数 `open()` 。
-   内建函数 `dir()` 和 `help()` 可作为用于了解模块相关信息。

Python 展现了 “batteries included” 的哲学。

-   [`xmlrpc.client`](../library/xmlrpc.client.html#module-xmlrpc.client) 和 [`xmlrpc.server`](../library/xmlrpc.server.html#module-xmlrpc.server) 模块使得 “implementing remote procedure calls” 变得轻而易举。尽管模块名称含有 xml，用户无需直接拥有 XML 的知识或处理 XML。
-   [`email`](../library/email.html#module-email) 包是一个用于管理电子邮件的库，包括 MIME 和 其它基于 RFC 2822 的信息文档。不同于实际发送和接受信息的 [`smtplib`](../library/smtplib.html#module-smtplib) 和 [`poplib`](../library/poplib.html#module-poplib) 模块，email 包具有构建或解码复杂消息的结构（包括附件）以及用于实现互联网编码和报头协议的完整工具集。
-   [`json`](../library/json.html#module-json) 包提供了强大支持来解析这种流行的数据交换格式。 [`csv`](../library/csv.html#module-csv) 模块支持以逗号分隔值格式直接读取和写入文件，通常由数据库和电子表格支持。XML  处理由 [`xml.etree.ElementTree`](../library/xml.etree.elementtree.html#module-xml.etree.ElementTree), [`xml.dom`](../library/xml.dom.html#module-xml.dom) 和 [`xml.sax`](../library/xml.sax.html#module-xml.sax) 包提供支持。这些模块和软件包一起大大简化了 Python 应用程序和其它工具之间的数据交换。
-   [`sqlite3`](../library/sqlite3.html#module-sqlite3) 模块是 SQLite 数据库封装器库，提供了可以使用稍微非标准的 SQL 语法进行更新和访问的持久性数据库。
-   Python 的国际化由许多模块支持，包括 [`gettext`](../library/gettext.html#module-gettext), [`locale`](../library/locale.html#module-locale), 和 [`codecs`](../library/codecs.html#module-codecs) 包。


推荐参考内容：

-   [Python 3 Module of the Week](https://pymotw.com/3/#python-3-module-of-the-week)
-   [Python documentation](http://docs.python.org/3/) 官方文档
-   [Python Standard Library documentation](http://docs.python.org/3/library/) 官方文档


## 6. Text Processing Services

### 6.4. `textwrap` — Text wrapping and filling 

Text wrapping and filling 
`textwrap` 模块会格式化文本段落，以使其适应屏幕的宽度

```
>>> import textwrap
>>> doc = """The wrap() method is just like fill() except that it returns
... a list of strings instead of one big string with newlines to separate
... the wrapped lines."""
...
>>> print(textwrap.fill(doc, width=40))
The wrap() method is just like fill()
except that it returns a list of strings
instead of one big string with newlines
to separate the wrapped lines.
```

## 7. Binary Data Services

## 8. Data Types

### 8.1. `datetime` — Basic date and time types 

`datetime` 模块提供了操作日期和时间的各种方式。
虽然支持日期和时间算法，但实现的重点是提取 有效成员，并对成员进行格式化和各种处理。
The module also supports objects that are timezone aware.

```
>>> # dates are easily constructed and formatted
>>> from datetime import date
>>> now = date.today()
>>> now
datetime.date(2003, 12, 2)
>>> now.strftime("%m-%d-%y. %d %b %Y is a %A on the %d day of %B.")
'12-02-03. 02 Dec 2003 is a Tuesday on the 02 day of December.'

>>> # dates support calendar arithmetic
>>> birthday = date(1964, 7, 31)
>>> age = now - birthday
>>> age.days
14368
```

-   *class* datetime.**datetime**(*year*, *month*, *day*, *hour=0*, *minute=0*, *second=0*, *microsecond=0*, *tzinfo=None*, \*, *fold=0*) 

    用于构造 `datetime` 实例对象，该对象包含了来自[`date`](https://docs.python.org/3/library/datetime.html#datetime.date) 对象和 [`time`](https://docs.python.org/3/library/datetime.html#datetime.time) 对象的所有信息。同 `date` 对象一样，`datetime` 假定当前 Gregorian calendar 在两个方向上延伸；同 `time` 对象一样，`datetime` 假定每天恰好为 3600*24 seconds。

    可用于构造指定日期和时间：

    ```
    >>> from datetime import datetime
    >>> dt = datetime(2015, 4, 19, 12, 20)
    >>> print(dt)
    2015-04-19 12:20:00
    ```

-   *classmethod* datetime.**now**(*tz=None*)

    Return the current local date and time. 
    `.now` 是 `datetime.datetime` 类的方法。

    ```
    >>> from datetime import datetime
    >>> now = datetime.now() # 获取当前datetime
    >>> print(now)
    2015-05-18 16:28:07.198690
    >>> print(type(now))
    <class 'datetime.datetime'>
    ```

    当前本地日期和时间，是指当前操作系统设定的时间。
    例如北京时区是东 8 区，那么本地时间：`2015-04-19 12:20:00` 。
    实际上就是 UTC+8:00 时区的时间：`2015-04-19 12:20:00 UTC+8:00` 。
    此时格林威治标准时间(UTC+0:00)是：`2015-04-19 04:20:00 UTC+0:00` 。

-   datetime <==> timestamp

    在计算机内，时间以数字表示。
    计算机把 1970年1月1日 00:00:00 UTC+00:00 这一时间点，称为epoch time 新纪元时间，并将其标记为 0。当前时间便是相对于 epoch time 的秒数，称为时间戳 (timestamp) 。1970年以前的时间的时间戳 (timestamp) 为负数。可以认为：`timestamp is 0 = 1970-1-1 00:00:00 UTC+0:00` 
    相应北京时间：`timestamp is 0 = 1970-1-1 08:00:00 UTC+8:00` 
    时间戳的值与时区毫没有联系。时间戳一旦确定，UTC 时间就确定了，转换到任意时区的时间也是完全确定的，这就是为什么计算机存储的当前时间是以timestamp表示的，因为全球各地的计算机在任意时刻的 timestamp 都是完全相同的（假定时间已校准）。
    `datetime`表示的时间需要时区信息才能确定一个特定的时间，否则只能视为本地时间。

    如果要存储`datetime`，最佳方法是将其转换为`timestamp` 再存储，因为 `timestamp` 的值与时区完全无关。

    -   datetime.**timestamp**()

        `datetime` 实例的 `timestamp()` 方法可实现 datetime to timestamp。

        ```
        >>> from datetime import datetime
        >>> dt = datetime(2015, 4, 19, 12, 20) # 用指定日期时间创建datetime
        >>> dt.timestamp() # 把datetime转换为timestamp
        1429417200.0
        ```

        python 中的时间戳是浮点数，小数位数表示毫秒数。
        某些编程语言（如Java和JavaScript）的timestamp使用整数表示毫秒数，这种情况下只需要把timestamp除以1000就得到Python的浮点表示方法。

    -   classmethod datetime.fromtimestamp(timestamp, tz=None)

        `datetime` 类的 `fromtimestamp()` 方法可实现 timestamp to datetime

        ```
        >>> from datetime import datetime
        >>> t = 1429417200.0
        >>> print(datetime.fromtimestamp(t))
        2015-04-19 12:20:00
        ```

        因为时间戳和时区无关，但是 datetime 与时区有关。
        所以上述代码是将时间戳转换为本地时间。
        时间戳也可直接被转换为 UTC 标准时区的时间：
        (UTC时间指UTC+0:00时区的时间)

        ```
        >>> from datetime import datetime
        >>> t = 1429417200.0
        >>> print(datetime.fromtimestamp(t)) # 本地时间
        2015-04-19 12:20:00
        >>> print(datetime.utcfromtimestamp(t)) # UTC时间
        2015-04-19 04:20:00
        ```

-   str <==> datetime

    | 实 参  | 含 义                 |
    | ---- | ------------------- |
    | %A   | 星期的名称，如Monday       |
    | %B   | 月份名，如January        |
    | %m   | 用数字表示的月份（ 01~12）    |
    | %d   | 用数字表示月份中的一天（ 01~31） |
    | %Y   | 四位的年份，如2015         |
    | %y   | 两位的年份，如15           |
    | %H   | 24小时制的小时数（ 00~23）   |
    | %I   | 12小时制的小时数（ 01~12）   |
    | %p   | am或pm               |
    | %M   | 分钟数（ 00~59）         |
    | %S   | 秒数（ 00~61）          |

    -   *classmethod* datetime.strptime(*date_string*, *format*)

        Return a datetime corresponding to *date_string*, parsed according to *format*.  *format* 的[详细说明](https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior) 。转换后的 datetime 没有时区信息。

        ```
        >>> from datetime import datetime
        >>> cday = datetime.strptime('2015-6-1 18:19:59', '%Y-%m-%d %H:%M:%S')
        >>> print(cday)
        2015-06-01 18:19:59
        ```

    -   datetime.strftime(*format*)

        Return a string representing the date and time, controlled by an explicit format string. For a complete list of formatting directives, see [strftime() and strptime() Behavior](https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior).

        ```
        >>> from datetime import datetime
        >>> now = datetime.now()
        >>> print(now.strftime('%a, %b %d %H:%M'))
        Mon, May 05 16:28
        ```

-   datetime 加减 - timedelta

    对日期和时间进行加减实际上就是把 datetime 往后或往前计算，得到新的datetime。加减可以直接用`+`和`-`运算符，不过需要导入`timedelta`这个类：

    ```
    >>> from datetime import datetime, timedelta
    >>> now = datetime.now()
    >>> now
    datetime.datetime(2015, 5, 18, 16, 57, 3, 540997)
    >>> now + timedelta(hours=10)
    datetime.datetime(2015, 5, 19, 2, 57, 3, 540997)
    >>> now - timedelta(days=1)
    datetime.datetime(2015, 5, 17, 16, 57, 3, 540997)
    >>> now + timedelta(days=2, hours=12)
    datetime.datetime(2015, 5, 21, 4, 57, 3, 540997)
    ```


-   本地时间 to UTC
    本地时间是指系统设定时区的时间，例如北京时间是UTC+8:00时区的时间，而UTC时间指UTC+0:00时区的时间。
    `datetime` 类型具有 `tzinfo` 属性，默认为 `None` 。因此无法辨识 `datetime` 实例所属的时区，需要手动为实例对象设置 `tzinfo` 属性。

    ```
    >>> from datetime import datetime, timedelta, timezone
    >>> tz_utc_8 = timezone(timedelta(hours=8)) # 创建时区UTC+8:00
    >>> now = datetime.now()
    >>> now
    datetime.datetime(2015, 5, 18, 17, 2, 10, 871012)
    >>> dt = now.replace(tzinfo=tz_utc_8) # 强制设置为UTC+8:00
    >>> dt
    datetime.datetime(2015, 5, 18, 17, 2, 10, 871012, tzinfo=datetime.timezone(datetime.timedelta(0, 28800)))
    ```

    如果系统时区恰好是UTC+8:00，那么上述代码正常，否则，不能强制设置为UTC+8:00时区。

-   时区转换
    需要转换时区时，可先通过 `utcnow()` 获得当前的 UTC 时间，再转换为任意时区的时间：

    ```
    # 拿到UTC时间，并强制设置时区为UTC+0:00:
    >>> utc_dt = datetime.utcnow().replace(tzinfo=timezone.utc)
    >>> print(utc_dt)
    2015-05-18 09:05:12.377316+00:00
    # astimezone()将转换 UTC 时区为北京时间:
    >>> bj_dt = utc_dt.astimezone(timezone(timedelta(hours=8)))
    >>> print(bj_dt)
    2015-05-18 17:05:12.377316+08:00
    # astimezone()将转换 UTC 时区为东京时间:
    >>> tokyo_dt = utc_dt.astimezone(timezone(timedelta(hours=9)))
    >>> print(tokyo_dt)
    2015-05-18 18:05:12.377316+09:00
    # astimezone()将bj_dt转换时区为东京时间:
    >>> tokyo_dt2 = bj_dt.astimezone(timezone(timedelta(hours=9)))
    >>> print(tokyo_dt2)
    2015-05-18 18:05:12.377316+09:00
    ```

    时区转换的关键在于，要获得一个包含时区信息的 `datetime` 实例。
    然后再利用该实例对象进行转换。
    注意：任何带时区信息的 `datetime` 都可以正确转换，例如上述 `bj_dt` 到 `tokyo_dt` 的转换。

    ​

    时区转换的关键在于，拿到一个`datetime`时，要获知其正确的时区，然后强制设置时区，作为基准时间。

    利用带时区的`datetime`，通过`astimezone()`方法，可以转换到任意时区。

    注：不是必须从UTC+0:00时区转换到其他时区，任何带时区的`datetime`都可以正确转换，例如上述`bj_dt`到`tokyo_dt`的转换。

    ​

    ​

    ​




### 8.3. `collections` — 容器数据类型

Container datatypes 

#### namedtuple()

factory function for creating tuple subclasses with named fields
可以通过属性引用实例中的元素，同时具备 tuple 的不变性。

如果使用 `namedtuple` 构造一个二维坐标，会比直接使用 tuple 更加直观，也比定义一个 class 更简洁。

```
>>> from collections import namedtuple
>>> Point = namedtuple('Point', ['x', 'y'])
>>> p = Point(1, 2)
>>> p.x
1
>>> p.y
2

# 验证实例类型
>>> isinstance(p, Point)
True
>>> isinstance(p, tuple)
True
```

#### deque	

list-like container with fast appends and pops on either end
该对象类似于可以在左侧快速 append 和 pop 项目的 list。
同时支持：`append()` / `pop()` / `appendleft()` / `popleft()`
但是在 `deque()` 对象内部查询时相对较慢。
`deque()` 对象非常适合实现队列和 breadth first tree searches：

```
>>> from collections import deque
>>> d = deque(["task1", "task2", "task3"])
>>> d.append("task4")
>>> print("Handling", d.popleft())
Handling task1
```

```
unsearched = deque([starting_node])
def breadth_first_search(unsearched):
    node = unsearched.popleft()
    for m in gen_moves(node):
        if is_goal(m):
            return m
        unsearched.append(m)
```

#### Counter( ) 

Counter: dict subclass for counting hashable objects 

`Counter`是一个简单的计数器，例如，统计字符出现的个数：

```
>>> from collections import Counter
>>> c = Counter('programming')
>>> c
Counter({'g': 2, 'm': 2, 'r': 2, 'a': 1, 'i': 1, 'o': 1, 'n': 1, 'p': 1})
```

#### OrderedDict( )

OrderedDict: dict subclass that remembers the **order entries were added** 

`dict` 中的 key 是无需的。

```
>>> from collections import OrderedDict
>>> d = dict([('a', 1), ('b', 2), ('c', 3)])
>>> d # dict的Key是无序的
{'a': 1, 'c': 3, 'b': 2}
>>> od = OrderedDict([('a', 1), ('b', 2), ('c', 3)])
>>> od # OrderedDict的Key是有序的
OrderedDict([('a', 1), ('b', 2), ('c', 3)])
```

注意，`OrderedDict` 的 Key 按照添加顺序排列，不是 Key 本身排序：

```
>>> od = OrderedDict()
>>> od['z'] = 1
>>> od['y'] = 2
>>> od['x'] = 3
>>> list(od.keys()) # 按照插入的Key的顺序返回
['z', 'y', 'x']
```

`OrderedDict` 可以实现一个FIFO（先进先出）的dict，当容量超出限制时，先删除最早添加的Key：

```
from collections import OrderedDict

class LastUpdatedOrderedDict(OrderedDict):

    def __init__(self, capacity):
        super(LastUpdatedOrderedDict, self).__init__()
        self._capacity = capacity

    def __setitem__(self, key, value):
        containsKey = 1 if key in self else 0
        if len(self) - containsKey >= self._capacity:
            last = self.popitem(last=False)
            print('remove:', last)
        if containsKey:
            del self[key]
            print('set:', (key, value))
        else:
            print('add:', (key, value))
        OrderedDict.__setitem__(self, key, value)
```

#### defaultdict( )

*class* collections.defaultdict([*default_factory*[, *...*]])
defaultdict: dict subclass that calls a factory function to supply missing values 

当引用的 key 不存在时，dict 会抛出 `KeyError` ，而 `defaultdict()` 则会调用 *default_factory* 。

```
>>> from collections import defaultdict
>>> dd = defaultdict(lambda: 'N/A')
>>> dd['key1'] = 'abc'
>>> dd['key1'] # key1存在
'abc'
>>> dd['key2'] # key2不存在，返回默认值
'N/A'
```

除了在Key不存在时返回默认值，`defaultdict`的其他行为跟`dict`是完全一样的。

### 8.5. `heapq` — 堆队列算法

Heap queue algorithm 

`heapq` 模块提供了基于常规 list 实现堆的功能。

>   The lowest valued entry is always kept at position zero. This is useful for applications which repeatedly access the smallest element but do not want to run a full list sort:

最低值条目始终保持在位置零。 这对于重复访问最小元素但不想运行完整列表排序的应用程序很有用：

```
>>> from heapq import heapify, heappop, heappush
>>> data = [1, 3, 5, 7, 9, 2, 4, 6, 8, 0]
>>> heapify(data)               # rearrange the list into heap order
								
>>> heappush(data, -5)                 # add a new entry 
>>> data
[-5, 0, 2, 6, 1, 5, 4, 7, 8, 9, 3]
>>> [heappop(data) for i in range(3)]  
# fetch the three smallest entries 
								
[-5, 0, 1]
```

### 8.6. `bisect` — 数组二分算法

Array bisection algorithm 

`bisect` 模块可用于操作列表的排序。

```
>>> import bisect
>>> scores = [(100, 'perl'), (200, 'tcl'), (400, 'lua'), (500, 'python')]
>>> bisect.insort(scores, (300, 'ruby'))
>>> scores
[(100, 'perl'), (200, 'tcl'), (300, 'ruby'), (400, 'lua'), (500, 'python')]
```



### 8.7. [`array`](#module-array) — 高效的数值数组

Efficient arrays of numeric values

built-in list type 可以满足许多数据结构的需求。
但是，有时需要在不同性能的实现方式中做出选择。

`array` 模块提供了 `array()` 对象，该对象好比一个只存储同构数据的 list，并且储存的方式更加紧凑。下面的示例展示了用于储存 2 字节无符号二进制数 (typecode `"H"`) 的 array。这不同于每个条目通常有 16 字节的 python int 对象的常规 list。

```
>>> from array import array
>>> a = array('H', [4000, 10, 700, 22222])
>>> sum(a)
26932
>>> a[1:3]
array('H', [10, 700])
```

### 8.8. weakref — 弱引用

Weak references 

Python 执行自动内存管理（对大多数对象都有引用计数和 [垃圾回收](../glossary.html#term-garbage-collection) ，以消除循环）。 在最后一个引用被除去后，内存被立即释放。

>   This approach works fine for most applications but occasionally there is a need to track objects only as long as they are being used by something else. 
>
>   Unfortunately, just tracking them creates a reference that makes them permanent. The [`weakref`](../library/weakref.html#module-weakref) module provides tools for tracking objects without creating a reference. When the object is no longer needed, it is automatically removed from a weakref table and a callback is triggered for weakref objects. Typical applications include caching objects that are expensive to create:

这种方法适用于大多数引用程序。
但只要对象被别的东西正在使用，那么就需要跟踪该对象。

不幸的是，仅仅是为了跟踪对象也需要创建引用，该引用会使得对象永久存在。
`weakref` 模块提供了用于跟踪对象，但不会创建引用的工具。 当不再需要该对象时，它会自动从 weakref  table 中被删除，并触发 weakref 对象的回调。  典型的应用场合包括创建开销很大缓存对象：

```
>>> import weakref, gc
>>> class A:
...     def __init__(self, value):
...         self.value = value
...     def __repr__(self):
...         return str(self.value)
...
>>> a = A(10)                   # create a reference
>>> d = weakref.WeakValueDictionary()
>>> d['primary'] = a            # does not create a reference
>>> d['primary']                # fetch the object if it is still alive
10
>>> del a                       # remove the one reference
>>> gc.collect()                # run garbage collection right away
0
>>> d['primary']                # entry was automatically removed
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
    d['primary']                # entry was automatically removed
  File "C:/python35/lib/weakref.py", line 46, in __getitem__
    o = self.data[key]()
KeyError: 'primary'
```

### 8.11. `pprint` — Data pretty printer 

`pprint` 模块提供了更加复杂的打印控制，以解释器可读的方式打印内置对象和用户自定义对象。
当结果超过一行时，“pretty printer” 会自动添加换行符和缩进，以更加清晰的方式显示数据结构：

```
>>> import pprint
>>> t = [[[['black', 'cyan'], 'white', ['green', 'red']], [['magenta',
...     'yellow'], 'blue']]]
...
>>> pprint.pprint(t, width=30)
[[[['black', 'cyan'],
   'white',
   ['green', 'red']],
  [['magenta', 'yellow'],
   'blue']]]
```

### 8.12. `reprlib` — 替代repr()的实现

Alternate repr() implementation 

`reprlib` 模块可看作 `repr()` 的定制版本。
用于为大型容器或深度嵌套的容器提供缩略显示。

```
>>> import reprlib
>>> reprlib.repr(set('supercalifragilisticexpialidocious'))
"{'a', 'c', 'd', 'e', 'f', 'g', ...}"
```



## 9. Numeric and Mathematical Modules

### 9.2. `math` — 数学运算函数库

Mathematical functions
The `math` module gives access to the underlying C library functions for floating point math:

```
>>> import math
>>> math.cos(math.pi / 4)
0.70710678118654757
>>> math.log(1024, 2)
10.0
```

### 9.4. `decimal` — 十进制固定浮点和浮点运算

Decimal fixed point and floating point arithmetic 

`decimal` 模块提供了用于十进制浮点运算的 `Decimal` 数据类型。
 相对于实现的二进制浮点运算的内置 [`float`](../library/functions.html#float) 类型，该类在以下几方面特别有用：

-   金融应用程序和其他需要精确十进制表示的用途，
-   控制精度，
-   控制舍入以满足法律或法规要求，
-   跟踪重要的小数位，或
-   用户期望结果与手动计算相匹配的应用程序。

例如，如果在 70 美分的手机费中有 5% 的税金，此时使用十进制浮点和二进制浮点同时计算，会给出不同的结果。 如果结果以分作为精确度来舍入的话, 这种差异就会变得很重要:

```
>>> from decimal import *
>>> round(Decimal('0.70') * Decimal('1.05'), 2)
Decimal('0.74')
>>> round(.70 * 1.05, 2)
0.73
```

>   The [`Decimal`](../library/decimal.html#decimal.Decimal) result keeps a trailing zero, automatically inferring four place significance from multiplicands with two place significance. Decimal reproduces mathematics as done by hand and avoids issues that can arise when binary floating point cannot exactly represent decimal quantities.

 [`Decimal`](../library/decimal.html#decimal.Decimal) 的结果总是保有结尾的 0，自动从含有两位小数位的两个被乘数，得出结果应有四位有效小数位。Decimal 重现了手工的数学运算，并避免了当二进制浮点不能精确表示十进制数时可能出现的问题。

>   Exact representation enables the [`Decimal`](../library/decimal.html#decimal.Decimal) class to perform modulo calculations and equality tests that are unsuitable for binary floating point:

精确表示使 [`Decimal`](../library/decimal.html#decimal.Decimal) 类能够执行不适合二进制浮点数的模计算和等式测试：

```
>>> Decimal('1.00') % Decimal('.10')
Decimal('0.00')
>>> 1.00 % 0.10
0.09999999999999995

>>> sum([Decimal('0.1')]*10) == Decimal('1.0')
True
>>> sum([0.1]*10) == 1.0
False
```

>   The [`decimal`](../library/decimal.html#module-decimal) module provides arithmetic with as much precision as needed:

 [`decimal`](../library/decimal.html#module-decimal) 模块提供具有所需精度的算术：

```
>>> getcontext().prec = 36
>>> Decimal(1) / Decimal(7)
Decimal('0.142857142857142857142857142857142857')
```

### 9.6. `random` — 生成伪随机数

Generate pseudo-random numbers

The [`random`](../library/random.html#module-random) module provides tools for making random selections:

```
>>> import random
>>> random.choice(['apple', 'pear', 'banana'])
'apple'
>>> random.sample(range(100), 10)   # sampling without replacement 无需替换的采样
[30, 83, 16, 4, 8, 81, 41, 50, 18, 33]
>>> random.random()    # random float 随机浮点
0.17970987693706186
>>> random.randrange(6)    # random integer chosen from range(6) 从range(6) 中选择随机整型
4
```

### 9.7. `statistics` — 数学统计功能

Mathematical statistics functions

 `statistics` 模块用于计算数值数据的基本统计特性（平均值、中值、方差等）：

```
>>> import statistics
>>> data = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]
>>> statistics.mean(data)
1.6071428571428572
>>> statistics.median(data)
1.25
>>> statistics.variance(data)
1.3720238095238095
```

SciPy 项目 [https://scipy.org](https://scipy.org) 还有许多其它用于数值计算的模块。

## 10. Functional Programming Modules

[10. Functional Programming Modules](https://docs.python.org/3/library/functional.html) 函数式编程模块

### 10.1. itertools — 创建迭代器

Functions creating iterators for efficient looping

`itertools` 模块用于构造并返回迭代器。
这些被返回的迭代器对象中，部分属于无限迭代器。
无限迭代器并不会事先生成无限个元素，迭代器是惰性的，只有用 `for` 循环迭代时才真正进行计算。

#### itertools.count(*start=0*, *step=1*)[¶](https://docs.python.org/3/library/itertools.html#itertools.count)

生成的迭代器对象会从 *start* 参数的值开始，每次会返回以 *step* 增长数值，属于无线迭代器。
通常用作 `map()` 的参数用来生成 consecutive data points。
配合 `zip()` 可用于添加 sequence numbers。

Roughly equivalent to:

```
def count(start=0, step=1):
    # count(10) --> 10 11 12 13 14 ...
    # count(2.5, 0.5) -> 2.5 3.0 3.5 ...
    n = start
    while True:
        yield n
        n += step
```

```
>>> import itertools
>>> naturals = itertools.count(1)
>>> for n in natuals:
...     print(n)
...
1
2
3
...
```

因为`count()`会创建一个无限的迭代器，所以上述代码会打印出自然数序列，根本停不下来，只能按 `Ctrl+C` 退出。

#### itertools.cycle(*iterable*)

Make an iterator returning elements from the *iterable* and saving a copy of each(保存每个元素的副本). When the iterable is exhausted耗尽, return elements from the saved copy. Repeats重复 indefinitely. Roughly equivalent to:

```
def cycle(iterable):
    # cycle('ABCD') --> A B C D A B C D A B C D ...
    saved = []
    for element in iterable:
        yield element
        saved.append(element)
    while saved:
        for element in saved:
              yield element
```

Note, this member of the toolkit may require significant auxiliary storage (depending on the length of the iterable).请注意，该工具包的成员可能需要大量的辅助存储（取决于迭代的长度）。

`cycle()` 会把 *iterable* 无限重复下去：

```
>>> import itertools
>>> cs = itertools.cycle('ABC') # 注意字符串也是序列的一种
>>> for c in cs:
...     print(c)
...
'A'
'B'
'C'
'A'
'B'
'C'
...
```

#### itertools.repeat(*object*[, *times*])[¶](https://docs.python.org/3/library/itertools.html#itertools.repeat)

Make an iterator that returns *object* over and over again. Runs indefinitely unless the *times* argument is specified指定. Used as argument to [`map()`](https://docs.python.org/3/library/functions.html#map) for invariant不变 parameters to the called function. Also used with [`zip()`](https://docs.python.org/3/library/functions.html#zip) to create an invariant part of a tuple record.

Roughly equivalent to:

```
def repeat(object, times=None):
    # repeat(10, 3) --> 10 10 10
    if times is None:
        while True:
            yield object
    else:
        for i in range(times):
            yield object
```

A common use for repeat is to supply a stream of constant常数 values to map or zip:

```
>>> list(map(pow, range(10), repeat(2)))
>>> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

`repeat()` 会把 *object* 无限重复下去，除非 *times* 被给定。

```
>>> ns = itertools.repeat('A', 3)
>>> for n in ns:
...     print(n)
...
A
A
A
```

#### itertools.takewhile(*predicate*, *iterable*)[¶](https://docs.python.org/3/library/itertools.html#itertools.takewhile)

Make an iterator that returns elements from the *iterable* as long as只要 the *predicate* is true. Roughly equivalent to:

```
def takewhile(predicate, iterable):
    # takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4
    for x in iterable:
        if predicate(x):
            yield x
        else:
            break
```

无限序列虽然可以无限迭代下去，但是通常我们会通过`takewhile()`等函数根据条件判断来截取出一个有限的序列：

```
>>> natuals = itertools.count(1)
>>> ns = itertools.takewhile(lambda x: x <= 10, natuals)
>>> list(ns)
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

```

`itertools` 提供的几个迭代器操作函数更加有用：

#### itertools.chain(\**iterables*)[¶](https://docs.python.org/3/library/itertools.html#itertools.chain)

Make an iterator that returns elements from the first iterable until it is exhausted, then proceeds to the next iterable, until all of the iterables are exhausted. Used for treating consecutive sequences as a single sequence. Roughly equivalent to:

```
def chain(*iterables):
    # chain('ABC', 'DEF') --> A B C D E F
    for it in iterables:
        for element in it:
            yield element
```

`chain()` 可以把一组迭代对象串联起来，形成一个更大的迭代器：

```
>>> for c in itertools.chain('ABC', 'XYZ'):
...     print(c)
# 迭代效果：'A' 'B' 'C' 'X' 'Y' 'Z'
```

#### itertools.groupby(*iterable*, *key=None*)

`groupby()` 把迭代器中相邻的重复元素挑出来放在一起：

```
>>> for key, group in itertools.groupby('AAABBBCCAAA'):
...     print(key, list(group))
...
A ['A', 'A', 'A']
B ['B', 'B', 'B']
C ['C', 'C']
A ['A', 'A', 'A']
```

实际上挑选规则是通过函数完成的，只要作用于函数的两个元素返回的值相等，这两个元素就被认为是在一组的，而函数返回值作为组的key。如果我们要忽略大小写分组，就可以让元素`'A'`和`'a'`都返回相同的key：

```
>>> for key, group in itertools.groupby('AaaBBbcCAAa', lambda c: c.upper()):
...     print(key, list(group))
...
A ['A', 'a', 'a']
B ['B', 'B', 'b']
C ['c', 'C']
A ['A', 'A', 'a']
```



## 11. 文件和目录访问

[11. File and Directory Access](https://docs.python.org/3/library/filesys.html)

### 11.7. `glob` — 文件通配符

[11.7. `glob` — Unix style pathname pattern expansion](https://docs.python.org/3/library/glob.html)
Unix 风格的路径名称模式扩展

`glob` 模块可根据 Unix shell 使用的规则，查找与指定模式匹配的所有路径名称。但对返回结果的排序是随机的，并不按照固定顺序排序。
No tilde expansion is done, but `*`, `?`, and character ranges expressed with `[]` will be correctly matched. 

File Wildcards 文件通配符

| Pattern  | Meaning                            |
| -------- | ---------------------------------- |
| `*`      | matches everything                 |
| `?`      | matches any single character       |
| `[seq]`  | matches any character in *seq*     |
| `[!seq]` | matches any character not in *seq* |

 [`glob`](../library/glob.html#module-glob) 模块提供了利用 “目录通配符” 搜索创建文件列表的功能：

```
>>> import glob
>>> glob.glob('*.py')
['primes.py', 'random.py', 'quote.py']
```

| Pattern  | Meaning        |
| -------- | -------------- |
| `./**/`  | 当前目录下的所有目录     |
| `/**/`   | 根目录下的所有目录      |
| `../**/` | 当前目录的父目录下的所有目录 |

See also:
The [`pathlib`](https://docs.python.org/3/library/pathlib.html#module-pathlib) module offers high-level path objects.
Module [`fnmatch`](https://docs.python.org/3/library/fnmatch.html#module-fnmatch) : Shell-style filename (not path) expansion

### 11.10. `shutil` — 文件和目录管理

11.10. `shutil` — High-level file operations

对于日常的文件和目录管理任务， `shutil` 模块提供了更高级别的接口。主要用于文件的复制 / 移动等操作。

```
>>> import shutil
>>> shutil.copyfile('data.db', 'archive.db')
'archive.db'
>>> shutil.move('/build/executables', 'installdir')
'installdir'
```



## 13. 数据压缩和归档

Data Compression and Archiving

Common data archiving and compression formats are directly supported by modules including: `zlib`, `gzip`, `bz2`, `lzma`, `zipfile` and `tarfile`.

```
>>> import zlib
>>> s = b'witch which has which witches wrist watch'
>>> len(s)
41
>>> t = zlib.compress(s)
>>> len(t)
37
>>> zlib.decompress(t)
b'witch which has which witches wrist watch'
>>> zlib.crc32(s)
226805979
```



## 15. Cryptographic Services 加密服务

[15. Cryptographic Services](https://docs.python.org/3/library/crypto.html)

### 15.1. hashlib — Secure hashes and message digests

hash 算法又称散列算法 / 摘要算法，通过 hash 函数 `f()` ，把任意长度的数据转换为一个固定长度的摘要 `digest`(通常用 16 进制的字符串表示)。目的是为了确定原始数据是否被人篡改过。

hash 算法之所以能指出数据是否被篡改过，是因为摘要函数是一个单向函数，计算`f(data)`很容易，但通过`digest`反推`data`却非常困难。而且，对原始数据做一个bit的修改，都会导致计算出的摘要完全不同。

另外，因为任何摘要算法都是把无限多的数据集合映射到一个有限的集合中，所以不同文件可能会有相同的摘要。这种情况被称为碰撞。

#### MD5

我们以常见的摘要算法MD5为例，计算出一个字符串的MD5值。
MD5 是最常见的摘要算法，速度很快，生成结果是固定的128 bit字节，通常用一个32位的16进制字符串表示。

```
In [85]: import hashlib
In [86]: md5 = hashlib.md5()
In [87]: md5.update('how to use md5 in python hashlib?'.encode('utf-8'))
In [88]: print(md5.hexdigest())
d26a53750bc40b38b65a520292f69306
```

如果数据量很大，可以分块多次调用`update()`，最后计算的结果是一样的：

```
import hashlib

md5 = hashlib.md5()
md5.update('how to use md5 in '.encode('utf-8'))
md5.update('python hashlib?'.encode('utf-8'))
print(md5.hexdigest())
```

#### SHA1

另一种常见的摘要算法是SHA1，调用SHA1和调用MD5完全类似：

```
import hashlib

sha1 = hashlib.sha1()
sha1.update('how to use sha1 in '.encode('utf-8'))
sha1.update('python hashlib?'.encode('utf-8'))
print(sha1.hexdigest())
```

SHA1的结果是160 bit字节，通常用一个40位的16进制字符串表示。

比SHA1更安全的算法是SHA256和SHA512，不过越安全的算法不仅越慢，而且摘要长度更长。

-   摘要算法的应用

    任何允许用户登录的网站都会存储用户登录的用户名和口令。如何存储用户名和口令呢？方法是存到数据库表中：

    ```
    name    | password
    --------+----------
    michael | 123456
    bob     | abc999
    alice   | alice2008
    ```

    如果以明文保存用户口令，如果数据库泄露，所有用户的口令就落入黑客的手里。此外，网站运维人员是可以访问数据库的，也就是能获取到所有用户的口令。

    正确的保存口令的方式是不存储用户的明文口令，而是存储用户口令的摘要，比如MD5：

    ```
    username | password
    ---------+---------------------------------
    michael  | e10adc3949ba59abbe56e057f20f883e
    bob      | 878ef96e86145580c38c87f0410ad153
    alice    | 99b1c2188db85afee403b1536010c2c9
    ```

    当用户登录时，首先计算用户输入的明文口令的MD5，然后和数据库存储的MD5对比，如果一致，说明口令输入正确，如果不一致，口令肯定错误。

    存储MD5的好处是即使运维人员能访问数据库，也无法获知用户的明文口令。

    设计一个验证用户登录的函数，根据用户输入的口令是否正确，返回True或False：

    ```
    db = {
        'michael': 'e10adc3949ba59abbe56e057f20f883e',
        'bob': '878ef96e86145580c38c87f0410ad153',
        'alice': '99b1c2188db85afee403b1536010c2c9'
    }

    def login(user, password):
        pass
    ```

    采用MD5存储口令是否就一定安全呢？也不一定。假设你是一个黑客，已经拿到了存储MD5口令的数据库，如何通过MD5反推用户的明文口令呢？暴力破解费事费力，真正的黑客不会这么干。

    考虑这么个情况，很多用户喜欢用`123456`，`888888`，`password`这些简单的口令，于是，黑客可以事先计算出这些常用口令的MD5值，得到一个反推表：

    ```
    'e10adc3949ba59abbe56e057f20f883e': '123456'
    '21218cca77804d2ba1922c33e0151105': '888888'
    '5f4dcc3b5aa765d61d8327deb882cf99': 'password'
    ```

    这样，无需破解，只需要对比数据库的MD5，黑客就获得了使用常用口令的用户账号。

    对于用户来讲，当然不要使用过于简单的口令。但是，我们能否在程序设计上对简单口令加强保护呢？

    由于常用口令的MD5值很容易被计算出来，所以，要确保存储的用户口令不是那些已经被计算出来的常用口令的MD5，这一方法通过对原始口令加一个复杂字符串来实现，俗称“加盐”：

    ```
    def calc_md5(password):
        return get_md5(password + 'the-Salt')
    ```

    经过Salt处理的MD5口令，只要Salt不被黑客知道，即使用户输入简单口令，也很难通过MD5反推明文口令。

    但是如果有两个用户都使用了相同的简单口令比如`123456`，在数据库中，将存储两条相同的MD5值，这说明这两个用户的口令是一样的。有没有办法让使用相同口令的用户存储不同的MD5呢？

    如果假定用户无法修改登录名，就可以通过把登录名作为Salt的一部分来计算MD5，从而实现相同口令的用户也存储不同的MD5。

    摘要算法在很多地方都有广泛的应用。要注意摘要算法不是加密算法，不能用于加密（因为无法通过摘要反推明文），只能用于防篡改，但是它的单向计算特性决定了可以在不存储明文口令的情况下验证用户口令。

## 16. 通用操作系统服务

[16. Generic Operating System Services](https://docs.python.org/3/library/allos.html)

### 16.1. `os` — 操作系统接口

[16.1. `os` — Miscellaneous operating system interfaces](https://docs.python.org/3/library/os.html)

在学习笔记 0x12 IO编程 中也有讲到该模块。

`os` 模块提供了许多与操作系统交互的功能：

```
>>> import os
# Return the current working directory 'C:\\Python35'
>>> os.getcwd()
'/Users/barryp/Documents'

# Change current working directory
# '.'表示当前目录，'..'表示切换到上级目录
>>> os.chdir('../HeadFirstPython/chapter3')
>>> os.getcwd()
'/Users/barryp/HeadFirstPython/chapter3'

# Run the command mkdir in the system shell 创建名为today的文件夹。
>>> os.system('mkdir today')   

#检测目标文件是否存在
>>> os.path.exists('sketch.txt')
```

### 16.3. [`time`](https://docs.python.org/3/library/time.html#module-time) — 时间访问和转换

Time access and conversions

## 19. Internet Data Handling

### 19.6. `base64` — 数据编码

Base16, Base32, Base64, Base85 Data Encodings 

该模块提供了将 binary data 编码为 printable ASCII 字符，并将此类编码解码回二进制数据的功能。该模块为 [**RFC 3548**](https://tools.ietf.org/html/rfc3548.html) 中规定的编码提供了编码和解码功能，该模块定义了 Base16, Base32, and Base64，以及 de-facto standard Ascii85 and Base85 编码。

Base64 是一种用 64 个字符来表示任意二进制数的编码方法，常用于在 URL / Cookie / Web 中传输少量二进制数据。

计算机中的数据都是按 ASCII 码存储的，但是 ASCII 码的 128~255 之间的值是不可见字符。在网络上交换数据时，被传输的数据往往要经过多个路由设备。由于不同的设备对字符的处理方式不完全相同，这个使得不可见字符可能被错误处理。因此，可利用 Base64 对数据编码，让数据的内容全部变为可见字符，这样可大大降低传输过程中出错的可能性。

Base64 适用于小段内容的编码，比如数字证书签名、Cookie的内容等。

下面是一个包含 64 个字符的 Base64 编码表：

|   码值 | 字符   |   码值 | 字符   |   码值 | 字符   |   码值 | 字符   |
| ---: | :--- | ---: | ---- | ---: | ---- | ---: | ---- |
|    0 | A    |   16 | Q    |   32 | g    |   48 | w    |
|    1 | B    |   17 | R    |   33 | h    |   49 | x    |
|    2 | C    |   18 | S    |   34 | i    |   50 | y    |
|    3 | D    |   19 | T    |   35 | j    |   51 | z    |
|    4 | E    |   20 | U    |   36 | k    |   52 | 0    |
|    5 | F    |   21 | V    |   37 | l    |   53 | 1    |
|    6 | G    |   22 | W    |   38 | m    |   54 | 2    |
|    7 | H    |   23 | X    |   39 | n    |   55 | 3    |
|    8 | I    |   24 | Y    |   40 | o    |   56 | 4    |
|    9 | J    |   25 | Z    |   41 | p    |   57 | 5    |
|   10 | K    |   26 | a    |   42 | q    |   58 | 6    |
|   11 | L    |   27 | b    |   43 | r    |   59 | 7    |
|   12 | M    |   28 | c    |   44 | s    |   60 | 8    |
|   13 | N    |   29 | d    |   45 | t    |   61 | 9    |
|   14 | O    |   30 | e    |   46 | u    |   62 | +    |
|   15 | P    |   31 | f    |   47 | v    |   63 | /    |

在有了编码表后，需要将原二进制字符串以3个字节为单位进行分组，每组是 3\*8=24 bit。然后将这 24 bit 以 6 bit为单位，分为 4 组。最后依据 6bit 表示的值作为码值进行编码。
所以 Base64 编码会把 3 字节的二进制数据编码为 4 字节的文本数据，虽然长度增加33%，但是编码后的数据全是可见字符。

如果原二进制数据不是 3 的倍数，Base64 会用`\x00` 字节在末尾补足，再在编码后的字符串的尾部增加相应数量的 `=` 。

```
>>> import base64
>>> base64.b64encode(b'binary\x00string')
b'YmluYXJ5AHN0cmluZw=='
>>> base64.b64decode(b'YmluYXJ5AHN0cmluZw==')
b'binary\x00string'
```

标准 Base64 编码中的 `+` / `/` 在 URL 中不能直接作为参数，此时需要使用 URL Safe 的 Base64 编码，将 `+` / `/` 改为 `-` / `_` 。

```
>>> base64.b64encode(b'i\xb7\x1d\xfb\xef\xff')
b'abcd++//'
>>> base64.urlsafe_b64encode(b'i\xb7\x1d\xfb\xef\xff')
b'abcd--__'
>>> base64.urlsafe_b64decode('abcd--__')
b'i\xb7\x1d\xfb\xef\xff'
```

由于 `=` 字符也可能出现在Base64编码中，但 `=` 用在URL、Cookie里面会造成歧义，所以，很多Base64编码后会把 `=` 去掉：

```
# 标准Base64:
'abcd' -> 'YWJjZA=='
# 自动去掉=:
'abcd' -> 'YWJjZA'
```

因为 Base64 编码的长度永远是 4 的倍数，在没有等号等情况下，只要保持倍数关系，即可正常解码。

## 20. Structured Markup Processing Tools

[20. Structured Markup Processing Tools](https://docs.python.org/3/library/markup.html) 结构化标记处理工具

### 20.2. html.parser — 简单的HTML/XHTML解析器

Simple HTML and XHTML parser
此模块定义了 `HTMLParser` class。该类作为解析以 HTML (HyperText Mark-up Language) and XHTML 文本文件的基础。利用HTMLParser，可以把网页中的文本、图像等解析出来。

HTML 本质上是 XML 的子集，但是 HTML 的语法却没有 XML 那么严格，所以不能用标准的 DOM 或 SAX 进行解析。

-   *class* html.parser.HTMLParser(\*, *convert_charrefs=True*)

    Create a parser instance able to parse invalid无效 markup.

    If *convert_charrefs* is `True` (the default), all character references (except the ones in `script`/`style` elements) are automatically converted to the corresponding Unicode characters.

    当遇见  start tags, end tags, text, comments, and other markup elements 时， [`HTMLParser`](https://docs.python.org/3/library/html.parser.html#html.parser.HTMLParser) 实例会收到 HTML data，并调用相应处理方法。用户应该将 `HTMLParser` 子类化，并在子类中覆写相应的方法以实现所需的行为。

    This parser does not check that end tags match start tags or call the end-tag handler for elements which are closed implicitly by closing an outer element.

    Changed in version 3.4: *convert_charrefs* keyword argument added.

    Changed in version 3.5: The default value for argument *convert_charrefs* is now `True`.

```
from html.parser import HTMLParser

class MyHTMLParser(HTMLParser):
    def handle_starttag(self, tag, attrs):
        print("Encountered a start tag:", tag)

    def handle_endtag(self, tag):
        print("Encountered an end tag :", tag)

    def handle_data(self, data):
        print("Encountered some data  :", data)

parser = MyHTMLParser()
parser.feed('<html><head><title>Test</title></head>'
            '<body><h1>Parse me!</h1></body></html>')
```

The output will then be:

```
Encountered a start tag: html
Encountered a start tag: head
Encountered a start tag: title
Encountered some data  : Test
Encountered an end tag : title
Encountered an end tag : head
Encountered a start tag: body
Encountered a start tag: h1
Encountered some data  : Parse me!
Encountered an end tag : h1
Encountered an end tag : body
Encountered an end tag : html
```

更多示例，请看 [`html.parser`](https://docs.python.org/3/library/html.parser.html#module-html.parser) 。
`feed()` 可多次调用，不必一次把整个 HTML 字符串都塞进去。
HTML 中有两种特殊字符：一种是英文表示的`&nbsp;`，一种是数字表示的`&#1234;`，这两种字符都可以通过Parser解析出来。


### 20.13. xml.parsers.expat — 利用Expat快速解析XML

[20.13. `xml.parsers.expat` — Fast XML parsing using Expat](https://docs.python.org/3/library/pyexpat.html)

Expat 是一个基于SAX模型的、非验证(默认，v1.2开始提供验证接口，需要用户手动处理)的轻量级XML解释器。
目前XML的解析主要有两大模型：SAX和DOM。

-   SAX - Simple API for XML：是一种基于事件的解析方法。基本工作原理是分析 XML文档，通过触发事件来通知用户解析的结果。这种方式占用内存少，速度快，但用户程序相应得会比较复杂，需要用户自己处理事件。
-   DOM - Document Object Model 文档对象模型：一次性将整个XML文档进行分析，在内存中以树结构保存解析结果。同时，向用户提供一系列的接口来访问和编辑该树结构。这种方式占用内存大，速度往往慢于SAX，但可以给用户提供一个面向对象的访问接口，对用户更为友好，可以任意遍历树的节点。

利用 Expat 解析 XML 非常简洁，通常需要设置 `start_element` / `end_element` / `char_data` 三个事件。为这些事件设置好相应的函数后，便可以对 XML 进行解析了。

比如在解析 `<a href="/">python</a>` 时：
读取 `<a href="/">` 时会产生 `start_element` 事件；读取 `python` 时会产生 `char_data` 事件；读取 `</a>` 时会产生 `end_element` 事件。

```
from xml.parsers.expat import ParserCreate

class DefautSaxHandler(object):
    def start_element(self, name, attrs):
        print('sax:star_element: %s, attrs: %s' % (name, str(attrs)))

    def end_element(self, name):
        print('sax:end_element: %s' % name)

    def char_data(self, text):
        print('sax:char_data: %s' % text)


xml = r'''<?xml version="1.0"?>
<ol>
    <li><a href="/python">Python</a></li>
    <li><a href="/ruby">Ruby</a></li>
</ol>
'''

handler = DefautSaxHandler()
parser = ParserCreate()
parser.StartElementHandler = handler.start_element
parser.EndElementHandler = handler.end_element
parser.CharacterDataHandler = handler.char_data
parser.Parse(xml)
```

-   xml.parsers.expat.ParserCreate(*encoding=None*, *namespace_separator=None*)

    创建并返回一个新的 xmlparser 对象。

-   xmlparser.StartElementHandler(*name*, *attributes*)[¶](https://docs.python.org/3/library/pyexpat.html#xml.parsers.expat.xmlparser.StartElementHandler) 

    Called for the start of every element. *name* is a string containing the element name, and *attributes* is the element attributes. If [`ordered_attributes`](https://docs.python.org/3/library/pyexpat.html#xml.parsers.expat.xmlparser.ordered_attributes) is true, this is a list (see[`ordered_attributes`](https://docs.python.org/3/library/pyexpat.html#xml.parsers.expat.xmlparser.ordered_attributes) for a full description). Otherwise it’s a dictionary mapping names to values.

-   xmlparser.EndElementHandler(*name*)[¶](https://docs.python.org/3/library/pyexpat.html#xml.parsers.expat.xmlparser.EndElementHandler)

    Called for the end of every element.

-   xmlparser.CharacterDataHandler(*data*)

    Called for character data. This will be called for normal character data, CDATA marked content, and ignorable whitespace. Applications which must distinguish these cases can use the [`StartCdataSectionHandler`](https://docs.python.org/3/library/pyexpat.html#xml.parsers.expat.xmlparser.StartCdataSectionHandler), [`EndCdataSectionHandler`](https://docs.python.org/3/library/pyexpat.html#xml.parsers.expat.xmlparser.EndCdataSectionHandler), and [`ElementDeclHandler`](https://docs.python.org/3/library/pyexpat.html#xml.parsers.expat.xmlparser.ElementDeclHandler) callbacks to collect the required information.

#### 生成 XML

通常需要生成的 XML 结构都非常简单。因此，拼接字符串往往是最简单也是最有效的生成XML的方法。

```
L = []
L.append(r'<?xml version="1.0"?>')
L.append(r'<root>')
L.append(encode('some & data'))
L.append(r'</root>')
return ''.join(L)
```

若是要生成复杂的 XML，则建议改用 JSON。

## 21. Internet Protocols and Support

### 21.2. `cgi` — Common Gateway Interface support 

利用 CGI 模块访问表单(HTML中的表单)发给Web服务器的数据。

```
​``` HTML 中的代码
<form action="cgi-bin/process-time.py" method="POST">
Enter a timing value:
<input type="Text" name="TimeValue" size=40>
<br />
<input type="Submit" value="Send">
</form>'''

import cgi
form = cgi.FieldStorage() # 从CGI脚本访问发送至WEB服务器的数据
timing_value = form["TimeValue"].value
```

-   CGI 跟踪模块 cgitb

CGI 标准指出服务器端程序（CGI脚本）生成的任何输出都会由Web服务器捕获并发送到等待的 Web 浏览器。具体来说，会捕获发送到 STDOUT 标准输出的所有内容。当 CGI 脚本产生异常时，Python 将把错误消息发送到 STDERR 标准错误输出。CGI 机制便会忽略异常输出，因为它只要 CGI 脚本的标准输出。但是当启用 cgitb 时，就会在 Web 浏览器上显示详细的错误消息。

```
import cgitb
cgitb.enable()
```



### 21.5. `urllib` — URL handling modules

`urllib` is a package that collects several modules for working with URLs:

-   [`urllib.request`](https://docs.python.org/3/library/urllib.request.html#module-urllib.request) for opening and reading URLs
-   [`urllib.error`](https://docs.python.org/3/library/urllib.error.html#module-urllib.error) containing the exceptions raised by [`urllib.request`](https://docs.python.org/3/library/urllib.request.html#module-urllib.request)
-   [`urllib.parse`](https://docs.python.org/3/library/urllib.parse.html#module-urllib.parse) for parsing URLs
-   [`urllib.robotparser`](https://docs.python.org/3/library/urllib.robotparser.html#module-urllib.robotparser) for parsing `robots.txt` files

`urllib` 能够使程序完成各种 HTTP 请求。
比如要模拟浏览器完成特定功能，可以把请求伪装成浏览器使用的格式。
可以先监控浏览器的请求格式，根据其 `User-Agent` 进行伪装。



### 21.6. `urllib.request` — URLs的扩展库

Extensible library for opening URLs 

`request` 模块用于打开和读取 URL 的内容。

#### 发送 GET 请求

示例，查询东部时间：

```
>>> from urllib.request import urlopen
>>> with urlopen('http://tycho.usno.navy.mil/cgi-bin/timer.pl') as response:
...     for line in response:
...         line = line.decode('utf-8')  # Decoding the binary data to text.
...         if 'EST' in line or 'EDT' in line: # look for Eastern Time
...             print(line)

<BR>Nov. 25, 09:43:32 PM EST
```

示例，抓取 web 服务器响应的内容：

```
from urllib import request

with request.urlopen('https://api.douban.com/v2/book/1234567') as f:
    data = f.read()
    print('Status:', f.status, f.reason)
    for k, v in f.getheaders():
        print('%s: %s' % (k, v))
    print('Data:', data.decode('utf-8'))
```

响应内容如下，可以看到 HTTP 响应头和 JSON 数据。

```
Status: 200 OK
Date: Fri, 11 Aug 2017 03:09:20 GMT
Content-Type: application/json; charset=utf-8
Content-Length: 1441
Connection: close
Vary: Accept-Encoding
X-Ratelimit-Remaining2: 94
X-Ratelimit-Limit2: 100
Expires: Sun, 1 Jan 2006 01:00:00 GMT
Pragma: no-cache
Cache-Control: must-revalidate, no-cache, private
Set-Cookie: bid=GsXYOrsUV8o; Expires=Sat, 11-Aug-18 03:09:20 GMT; Domain=.douban.com;
Path=/
X-DOUBAN-NEWBID: GsXYOrsUV8o
X-DAE-Node: sindar1c
X-DAE-App: book
Server: dae
Data: {"rating":{"max":10,"numRaters":3,"average":"0.0","min":0},"subtitle":"","author
":["余昌菊 于渤 李学丹 等"],"pubdate":"1987-8","tags":[{"count":1,"name":"龙应台","tit
le":"龙应台"},{"count":1,"name":"散文","title":"散文"}...}
```

若要模拟特定浏览器发送的 GET 请求。需要创建一个 `Request` 对象，并向对象中添加响应的 HTTP 头。这里模拟 iPhone 6 去请求豆瓣首页。

```
from urllib import request

req = request.Request('http://www.douban.com/')
req.add_header('User-Agent', 'Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25')
with request.urlopen(req) as f:
    print('Status:', f.status, f.reason)
    for k, v in f.getheaders():
        print('%s: %s' % (k, v))
    print('Data:', f.read().decode('utf-8'))
```

此时，会返回适合iPhone的移动版网页：

```
...
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0">
    <meta name="format-detection" content="telephone=no">
    <link rel="apple-touch-icon" sizes="57x57" href="http://img4.douban.com/pics/cardkit/launcher/57.png" />
...
```

#### 发送 POST 请求

如果要以POST发送一个请求，只需要把参数`data`以bytes形式传入。

我们模拟一个微博登录，先读取登录的邮箱和口令，然后按照weibo.cn的登录页的格式以`username=xxx&password=xxx`的编码传入：

```
from urllib import request, parse

print('Login to weibo.cn...')
email = input('Email: ')
passwd = input('Password: ')
login_data = parse.urlencode([
    ('username', email),
    ('password', passwd),
    ('entry', 'mweibo'),
    ('client_id', ''),
    ('savestate', '1'),
    ('ec', ''),
    ('pagerefer', 'https://passport.weibo.cn/signin/welcome?entry=mweibo&r=http%3A%2F%2Fm.weibo.cn%2F')
])

req = request.Request('https://passport.weibo.cn/sso/login')
req.add_header('Origin', 'https://passport.weibo.cn')
req.add_header('User-Agent', 'Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25')
req.add_header('Referer', 'https://passport.weibo.cn/signin/login?entry=mweibo&res=wel&wm=3349&r=http%3A%2F%2Fm.weibo.cn%2F')

with request.urlopen(req, data=login_data.encode('utf-8')) as f:
    print('Status:', f.status, f.reason)
    for k, v in f.getheaders():
        print('%s: %s' % (k, v))
    print('Data:', f.read().decode('utf-8'))
```

如果登录成功，我们获得的响应如下：

```
Status: 200 OK
Server: nginx/1.2.0
...
Set-Cookie: SSOLoginState=1432620126; path=/; domain=weibo.cn
...
Data: {"retcode":20000000,"msg":"","data":{...,"uid":"1658384301"}}
```

如果登录失败，我们获得的响应如下：

```
...
Data: {"retcode":50011015,"msg":"\u7528\u6237\u540d\u6216\u5bc6\u7801\u9519\u8bef","data":{"username":"example@python.org","errline":536}}
```

#### Handler

`request` 还包含多种处理器，以应对更加复杂的情况。
比如利用 `ProxyHandler` 通过 Proxy 访问网站。

```
proxy_handler = urllib.request.ProxyHandler({'http': 'http://www.example.com:3128/'})
proxy_auth_handler = urllib.request.ProxyBasicAuthHandler()
proxy_auth_handler.add_password('realm', 'host', 'username', 'password')
opener = urllib.request.build_opener(proxy_handler, proxy_auth_handler)
with opener.open('http://www.example.com/login.html') as f:
    pass
```

### 21.7. urllib.response — Response classes used by urllib

### 21.8. urllib.parse — Parse URLs into components

### 21.9. urllib.error — Exception classes raised by urllib.request

### 21.10. urllib.robotparser — Parser for robots.txt

### 21.17. `smtplib` — SMTP邮件发送协议

SMTP protocol client

```
>>> import smtplib
>>> server = smtplib.SMTP('localhost')
>>> server.sendmail('soothsayer@example.org', 'jcaesar@example.org',
... """To: jcaesar@example.org
... From: soothsayer@example.org
...
... Beware the Ides of March.
... """)
>>> server.quit()
```

### 21.22. http.server — HTTP servers 

`http.server` 模块可以在 Py 中建立一个简单的 Web 服务器。

```
from http.server import HTTPServer, CGIHTTPRequestHandler

port = 8080

httpd = HTTPServer(('', port), CGIHTTPRequestHandler)
print("Starting simple_httpd on port: " + str(httpd.server_port))
httpd.serve_forever()
```



## 23. Internationalization 国际化

### 23.2. `locale` — Internationalization services 

>   The [`locale`](../library/locale.html#module-locale) module accesses a database of culture specific data formats. The grouping attribute of locale’s format function provides a direct way of formatting numbers with group separators:

 [`locale`](../library/locale.html#module-locale) 模块访问一个特定语言环境的指定格式数据库。 locale’s format function 的分组属性，提供了使用组分隔符格式化数字的直接方法：

```
>>> import locale
>>> locale.setlocale(locale.LC_ALL, 'English_United States.1252')
'English_United States.1252'
>>> conv = locale.localeconv()          # get a mapping of conventions
>>> x = 1234567.8
>>> locale.format("%d", x, grouping=True)
'1,234,567'
>>> locale.format_string("%s%.*f", (conv['currency_symbol'],
...                      conv['frac_digits'], x), grouping=True)
'$1,234,567.80'
```



## 26. Development Tools

### 26.3. `doctest` — 文档字符串示例测试

Test interactive Python examples 

`doctest` 模块用于扫描某个模块，并验证嵌入在程序文档字符串中的测试。
在交互模式下的输入输出内容便可作为测试文档。

```
def average(values):
    """Computes the arithmetic mean of a list of numbers.

    >>> print(average([20, 30, 70]))
    40.0
    """
    return sum(values) / len(values)

import doctest
doctest.testmod()   # automatically validate the embedded tests 自动使内嵌测试生效
```

### 26.4. `unittest` — 单元测试框架

Unit testing framework 

 [`unittest`](../library/unittest.html#module-unittest) 模块比  [`doctest`](../library/doctest.html#module-doctest) 模块稍微难一点，它允许在一个单独的文件中维护一组更全面的测试：

```
import unittest

class TestStatisticalFunctions(unittest.TestCase):

    def test_average(self):
        self.assertEqual(average([20, 30, 70]), 40.0)
        self.assertEqual(round(average([1, 5, 7]), 1), 4.3)
        with self.assertRaises(ZeroDivisionError):
            average([])
        with self.assertRaises(TypeError):
            average(20, 30, 70)

unittest.main()  # Calling from the command line invokes all tests
```



## 27. Debugging and Profiling

### 27.5. `timeit` — 测量小代码片段的执行时间

Measure execution time of small code snippets 

一些 Python 的用户对相同问题的不同解决方法的相对性能优劣有着极大的兴趣。而 Python 也提供了一些测试 工具，可以立即回答这些问题。

例如，使用元组打包和解包的特性，进行参数交换，要比传统的方法更高效。 [`timeit`](../library/timeit.html#module-timeit) 模块很快地显示出了一个微弱性能优势：

```
>>> from timeit import Timer
>>> Timer('t=a; a=b; b=t', 'a=1; b=2').timeit()
0.57535828626024577
>>> Timer('a,b = b,a', 'a=1; b=2').timeit()
0.54962537085770791
```

相比  [`timeit`](../library/timeit.html#module-timeit)  精确细腻的层度， [`profile`](../library/profile.html#module-profile) 和 [`pstats`](../library/profile.html#module-pstats) 模块提供了在大块代码中确认关键部分时间的功能。



## 29. Python Runtime Services

[29. Python Runtime Services](https://docs.python.org/3/library/python.html)

### 29.1. `sys` — 系统特定的参数和功能

[29.1. `sys` — System-specific parameters and functions](https://docs.python.org/3/library/sys.html)

This module provides access to some variables used or maintained by the interpreter and to functions that interact strongly with the interpreter. It is always available.

`sys ` 模块包含了系统特定的功能

#### sys.argv 命令行参数

Common utility scripts 通常需要处理命令行参数。
这些参数都存放在 `sys` 模块的 *argv* 属性中。
如果在

例如从命令行运行  `python demo.py one two three` ，可得到下面的输出结果。

```
>>> import sys
>>> print(sys.argv)
['demo.py', 'one', 'two', 'three']
```

 [`getopt`](../library/getopt.html#module-getopt) 模块使用 Unix [`getopt`](../library/getopt.html#module-getopt) 函数处理 *sys.argv* 。
 [`argparse`](../library/argparse.html#module-argparse) 模块提供了更加强大灵活的命令行处理。

#### sys.stderr 错误输出重定向

sys.stderr 用于发出警告和错误消息，即使在 *stdout* 被重新定向时。

#### sys.exit 程序终止

使用 `sys.exit()` 是结束一个脚本最直接的方式。

#### sys.version_info

查看 Python 版本

```
>>> import sys
>>> sys.version_info
sys.version_info(major=3, minor=5, micro=1, releaselevel='final', serial=0)
>>> sys.version_info.major == 3
True
```



### 29.6. contextlib — with语句上下文工具

Utilities for with-statement contexts

该模块为涉及 `with` 语句的常见任务提供了一些实用的工具。
更过相关信息可阅读 [Context Manager Types](https://docs.python.org/3/library/stdtypes.html#typecontextmanager) and [With Statement Context Managers](https://docs.python.org/3/reference/datamodel.html#context-managers).

finally 和 with 的相关信息可查看：
0x11 错误、调试和测试 > 2. 处理异常 > 定义清理操作 finally / 预定义清理操作 with

利用 `__enter__` / `__exit__` 实现上下文管理的方式依旧比较麻烦。

#### @contextlib.contextmanager[¶](https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager)

>   This function is a [decorator](https://docs.python.org/3/glossary.html#term-decorator) that can be used to define a factory function for [`with`](https://docs.python.org/3/reference/compound_stmts.html#with) statement context managers, without needing to create a class or separate [`__enter__()`](https://docs.python.org/3/reference/datamodel.html#object.__enter__) and [`__exit__()`](https://docs.python.org/3/reference/datamodel.html#object.__exit__)methods.

该函数其实是一个装饰器，它用于为 `with` 语句的上下文管理器定义一个工厂函数，并且不需要创建 class 或  [`__enter__()`](https://docs.python.org/3/reference/datamodel.html#object.__enter__) and [`__exit__()`](https://docs.python.org/3/reference/datamodel.html#object.__exit__) 方法。

装饰器 `@contextmanager` 会接受一个生成器 generator。
该生成器利用 `yield` 语句将类实例传递给 `with ... as var` 。

注意，貌似要在生成器中手动关闭对象！参考 contextlib.closing(*thing*)

```
from contextlib import contextmanager

class Query(object):

    def __init__(self, name):
        self.name = name

    def query(self):
        print('Query info about %s...' % self.name)

@contextmanager
def create_query(name):
    print('Begin')
    a = Query(name)
    yield a
    print('End')

with create_query('Bob') as q:
    q.query()
```

输出：

```
Begin
Query info about Bob...
End
```

如果需要在代码前后自动执行特定代码，也可使用 `@contextmanager` 实现：

```
@contextmanager
def tag(name):
    print("<%s>" % name)
    yield
    print("</%s>" % name)

with tag("h1"):
    print("hello")
    print("world")
```

输出：

```
<h1>
hello
world
</h1>
```

#### contextlib.closing(*thing*)

Return a context manager that closes *thing* upon completion of the block. 
返回一个上下文管理器，该管理器用于在 *thing* 中的代码块完成后关闭 *thing* 。它的作用就是把任意对象变为上下文对象，并支持`with`语句。

This is basically equivalent to:

```
from contextlib import contextmanager

@contextmanager
def closing(thing):
    try:
        yield thing
    finally:
        thing.close()
```

And lets you write code like this:

```
from contextlib import closing
from urllib.request import urlopen

with closing(urlopen('http://www.python.org')) as page:
    for line in page:
        print(line)
```

without needing to explicitly close `page`. Even if an error occurs, `page.close()` will be called when the [`with`](https://docs.python.org/3/reference/compound_stmts.html#with) block is exited.





