# 0x08 函数式编程

[TOC]

函数就是**面向过程的程序设计**的基本单元。

Functional Programming：**函数式编程**，虽然也可以归结到面向过程的程序设计中，但其思想更接近数学计算。functional programming 似乎也被称作 Monad。(注意：这里是在讲述 “函数**式**编程”，而非 “函数编程”。)

procedurally(过程式编程), functional programming(函数式编程),object orientation(面向对象)。 

如何理解编程方式中所谓的**抽象程度**？
对编程语言而言，越低级的语言越接近底层硬件，其执行效率越高，但是抽象程度越低。越是高级的语言，越贴近计算 compute ，其抽象程度越高，但是执行效率越低。
这里所指的**计算 compute**，是指数学意义上的计算，越是抽象的计算，离底层硬件越远。对于计算机硬件而言，汇编语言的抽象程度最低，最贴近机器语言。

**函数式编程** ：就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数**没有变量**，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。

函数式编程的一个特点是，**允许把函数本身作为参数传入另一个函数，还允许返回一个函数**！

Python 对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。

## 1. 高阶函数

高阶函数 (Higher-order function) 是指能够接受另外一个函数作为参数的函数，并且会以某种方式应用该函数。
函数式编程就是指这种高度抽象的编程范式。

https://en.wikipedia.org/wiki/Higher-order_function

Python 中的函数都是第一类的数据对象，因此可以将函数赋值给变量、保存到数据结构中、作为参数传递给其它函数，以及作为其它函数的返回值。

### 指向函数的变量

以 `abs()` 函数为例，进行讲解：

-   `abs` 是函数名，函数名其实就是**指向函数对象的变量**，它和普通变量没有区别。

-   `abs(-10)` 是对函数的调用。

    ```
    >>> abs
    <built-in function abs>
    >>> abs.__name__
    'abs'

    >>> abs(-10)
    10
    ```


-   普通变量也可指向函数，即把函数本身赋值给普通变量。

    ```
    >>> abs
    <built-in function abs>
    >>> abs.__name__
    'abs'

    >>> f = abs
    >>> f
    <built-in function abs>
    >>> f.__name__
    'abs' 
    ```

-   直接调用 `abs()` 函数和调用变量 `f()` 完全相同。

    ```
    >>> f = abs
    >>> f(-10)
    10
    ```

-   函数名也可用于指向其它对象。但是改变函数名的指向后，就再也无法通过该名称调用此函数对象了。要恢复 `abs` 函数，需要重启交互环境。
    提醒： `abs` 函数实际上是定义在 `import builtins` 模块中的。

    ```
    >>> abs=10
    >>> abs # abs现在指向整数10
    10
    >>> abs(-10)
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    TypeError: 'int' object is not callable
    ```

### 将函数作为参数

函数能够接受变量，同时变量也可指向函数。
那么，便有可能将函数作为参数传递给另一个函数。
像这样，当 A 函数有能力接受 B 函数作为参数时，便称 A 是高阶函数。
编写高阶函数的目的，就是为了接受别的函数作为参数。

```
def add(x, y, f):
    return f(x) + f(y)

>>> add(-5, 6, abs)
11
```



## 2. 内建高阶函数

- 内置函数 map 属于高阶函数，因为它接受函数作为参数。
- 内置函数 filter 属于高阶函数，因为它接受函数作为参数。
- 内置函数 sorted 属于高阶函数，因为它接受函数作为参数。

### reduce 

>   reduce(...)
>
>   reduce(function, sequence[, initial]) -> value
>
>   Apply a function of two arguments cumulatively to the items of a sequence, from left to right, so as to reduce the sequence to a single value. 
>
>   For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates ((((1+2)+3)+4)+5).  
>
>   If **initial** is present, it is placed before the items of the sequence in the calculation, and serves as a default when the sequence is empty.

```
reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
```

注意：function 参数必须能够接受两个参数，且必须有恰当的返回值。

```
# 由于print_()函数默认返回None，
# 所以会将None作为参数打印
In [1]: def print_(x,y):
   ...:     print(x,y)
   ...:
   
In [4]: reduce(print_,[0,1,2,3])
0 1
None 2
None 3
```

```
import functools
# 计算一个数列的乘积
product = functools.reduce(lambda x, y: x*y, range(1, 11))
```

示例：实现 `int` 函数的功能：

```
from functools import reduce

def str2int(s):
    def fn(x, y):
        return x * 10 + y
    def char2num(s):
        return {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}[s]
    return reduce(fn, map(char2num, s))
```

lambda 函数可对函数进行简化：

```
from functools import reduce

def char2num(s):
    return {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}[s]

def str2int(s):
    return reduce(lambda x, y: x * 10 + y, map(char2num, s))
```

### 

## 3. 返回函数对象

### 函数对象作为返回值

高阶函数不仅能够接受函数作为参数，还可把它内部的函数作为作为返回值。
当某个函数作为返回值时，牢记该函数并未立即执行。
另外，在返回函数中也不要引用任何可能会变化的量。

示例，求和函数：

```
def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum

# 调用外函数时，将内函数作为返回值
# 此时并不会立即计算出结果
>>> f = lazy_sum(1, 3, 5, 7, 9)
>>> f # f是函数名
<function lazy_sum.<locals>.sum at 0x101c6ed90>

>>> f() #调用此函数时，才真的会计算结果
25
```

本示例，在外函数 `lazy_sum` 中定了内函数 `sum` 。
内函数可以引用外函数的参数和局部变量。
当内函数被外函数作为返回值时，相关参数和变量都会被保存在内函数中。
这就是所谓的 “ **闭包(Closure)** ”。

### 每次均返回新的函数对象

每次调用 `lazy_sum()` 都会返回一个新函数对象，同之前返回的函数对象有完全不同的内存地址。即使传入相同的参数，所返回的函数对象也不相同。调用不同的返回对象时，其调用结果也互不影响。

```
>>> f1 = lazy_sum(1, 3, 5, 7, 9)
>>> f2 = lazy_sum(1, 3, 5, 7, 9)
>>> f1==f2
False

>>> f1 = lazy_sum(1, 3, 5, 7, 9)
>>> f1
<function lazy_sum.<locals>.sum at 0x00000295322FEAE8>
>>> f2 = lazy_sum(1, 3, 5, 7, 9)
>>> f2
<function lazy_sum.<locals>.sum at 0x00000295322FEB70>

>>> f3 = f2
>>> f3
<function lazy_sum.<locals>.sum at 0x00000295322FEB70>

>>> f1 == f2
False
>>> f2 == f3
True
```



### 被返回的是函数对象

#### 将函数调用作为返回值

本节用于对比 “返回函数(或说返回函数对象)” 和 “返回函数调用” 间的区别
如果将函数的调用作为返回值，就会在返回时立即执行。

示例 1：

```
>>> def lazy_sum_call(*args):
...     def sum():
...         ax = 0
...         for n in args:
...             ax = ax + n
...         return ax
...     return sum() # 此处返回函数的调用
...
>>> f1 = lazy_sum(1,2)
>>> f1
3 # 这里会直接得到结果
```

 示例 2：

```
In [26]: def count():
    ...:     fs = []
    ...:     for i in range(1, 4):
    ...:         def f():
    ...:              return i*i
    ...:         fs.append(f())
    ...:     return fs
    ...:

In [27]: f1, f2, f3 = count()

In [28]: f1
Out[28]: 1

In [29]: f2
Out[29]: 4

In [30]: f3
Out[30]: 9
```

### 返回函数引用循环变量

当必须要在 “返回函数” 中引用循环变量时，可以再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：

```
def count():
    def f(j):
        def g():
            return j*j
        return g
    fs = []
    for i in range(1, 4):
        fs.append(f(i)) # 注意此处是在调用函数。
    return fs
```

再看看结果：

```
>>> f1, f2, f3 = count()
>>> f1()
1
>>> f2()
4
>>> f3()
9

```

缺点是代码较长，可利用lambda函数缩短代码。

## 4. 匿名函数 lambda

Lambda 表达式的语法如下：

`lambda <argument list>:<expression>` 

利用 `lambda` 关键字可以创建短小的匿名函数。
Lambda 函数可用于任何需要函数对象的地方。

匿名函数在语法结构上被限制为一个单独的表达式，不能使用 `return` 语句，返回值就是该表达式的结果。

`lambda x: x * x` 等效于：

```
def f(x):
    return x * x
```

匿名函数也是函数对象，同样可以为其指定函数名。

```
>>> f = lambda x: x * x
>>> f
<function <lambda> at 0x101c6ef28>
>>> f(5)
25
```

### 将 lanmbda 作为参数

```
>>> list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
[1, 4, 9, 16, 25, 36, 49, 64, 81]
```

### 将 lanmbda 作为返回值

```
def build(x, y):
    return lambda: x * x + y * y
```

lambda 函数可以从所包含的作用域中引用变量：

```
>>> def make_incrementor(n):
...     return lambda x: x + n
...
>>> f = make_incrementor(42)
>>> f(0)
42
>>> f(1)
43
```



## 5. 装饰器 Decorator

```
需要补充的笔记
class property_:
    def __init__(self, fget=None, fset=None, fdel=None, doc=None):
        self.fget = fget
        self.fset = fset
        self.fdel = fdel
    #装饰器只要返回对象即可
    def setter(self, fset):
        return property_(self.fget, fset, self.fde, doc=None)
```







装饰器的概念源自面向对象的程序设计模式 OOP。
OOP 中的装饰器需要通过继承和组合来实现。

装饰器是使用 wrapper functions 的捷径。有助于一遍又一遍地使用相同的代码 "wrap" functionality。可以参考下面的连接：

-   [http://www.ibm.com/developerworks/linux/library/l-cpdecor.html](http://www.ibm.com/developerworks/linux/library/l-cpdecor.html)
-   [http://toumorokoshi.github.io/dry-principles-through-python-decorators.html](http://toumorokoshi.github.io/dry-principles-through-python-decorators.html)

Python 中的装饰器可以用函数实现，也可用类实现。
“装饰器”是指在代码运行期间动态增加功能的方法。
利用“装饰器”可在不改变某函数定义的前提下，增强该函数的功能。
本质上而言，装饰器就是一个返回值是函数对象的高阶函数。

函数装饰器：通过介入函数的启动和关闭机制，调整一个已存在函数的行为。

可以使用多个装饰器，每个装饰器需位于不同的行中。

在Python中，函数也被视为对象，而函数名就是**指向函数对象的变量** 。
如本章前面所讲，函数对象也可被赋值给任意变量。

```
>>> def now():
...     print('2017-7-21')
...
>>> f = now
>>> f()
2017-7-21
#__name__属性用于表示函数名
>>> now.__name__
'now'
>>> f.__name__
'now'
```

### 装饰器本身不需要参数

利用装饰器为 `now()` 函数增加输出函数名的功能：

```
def log(func):
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw) #注意：这里func()是在调用一个函数
								# return wrapper 则是在返回一个函数
    return wrapper
```

`log` 函数作为装饰器，需要接受一个函数作为参数，并返回一个函数对象。
需要使用 `@` 语法，把装饰器置于函数定义处：

```
@log
def now():
    print('2015-3-25')
```

调用 `now()` 时，会连同装饰器一起执行。注意此时 `now` 变量所指的函数对象已发生了变化，所以 `__name__` 属性也会发生变化。

```
>>> now()
call now():
2017-7-21

>>> now.__name__
'wrapper'
```

因此，把 `@log` 放到 `now()` 函数的定义处，相当于执行了语句：
( 所以函数名的指向会发生变化 )

```
now = log(now)
```

装饰器 `log` 作为高阶函数，会返回一个函数对象 `wrapper` 。
`now` 函数对象的函数名被用于指向 `wrapper` 函数对象，即变量 `now` 现在被指向 `wrapper` 函数对象。于是调用 `now()` 便是在调用 `wrapper()` 。
`now` 函数对象依旧存在，由于“ **闭包(Closure)** ” 的特性，使得在 `wrapper` 函数对象内部依旧可以通过函数名 `now` 继续调用 `now` 函数对象。

`wrapper` 函数对象的参数列表是 `(*args, **kw)` ，表示 `wrapper` 函数对象可接受任意参数。

### 装饰器本身需要参数

如果同时需要向装饰器本身传入参数，就需要编写一个用于返回高阶函数的高阶函数。此时会产生一个具有三次嵌套结构的装饰器函数对象。

比如，利用装饰器为 `now` 函数对象增加输出自定义文本的功能：

```
def log(text):
    def decorator(func):
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
```

三层嵌套的装饰器的用法如下：

```
@log('execute')
def now():
    print('2017-7-21')
```

执行结果：

```
>>> now()
execute now():
2017-7-21
```

和两层嵌套的decorator相比，3层嵌套的效果是这样的：

```
>>> now = log('execute')(now)
```

分析：首相调用 `log('execute')` ，返回 `decorator` 函数对象。
然后再调用 `decorator(now)` ，返回 `wrapper` 函数对象。

### @functools.wraps(func)

使用装饰器时， `now` 变量所指向的函数对象已发生了变化，所以 `__name__` 属性也会发生变化。

```
def log(func):
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw) #注意：这里func()是在调用一个函数
								# return wrapper则是在返回一个函数
    return wrapper
    
@log
def now():
    print('2017-7-21')

>>> now()
call now():
2017-7-21

>>> now.__name__
'wrapper'
```

这会导致某些依赖函数签名的代码，在执行时会出错。
为了避免这样的错误，需要把 `now` 函数对象中的 `__name__` 等属性复制到 `wrapper` 函数对象中。 `functools.wraps` 装饰器可用于复制这些属性。
并不需要编写 `wrapper.__name__ = func.__name__` 这样的代码。

因此，一个完整的装饰器的写法如下：

```
import functools

def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
    
```

装饰器本身需要参数时，可写作：

```
import functools

def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
```

### Example 

示例1：编写一个装饰器，使其同时支持：

```
@log
def f():
    pass
```

和

```
@log('execute')
def f():
    pass
```

```
#!usr/bin/env python3
#-*- coding: utf-8 -*-

import functools

def log(text = None):
    if isinstance(text, str):
        def decorator(func):
            @functools.wraps(func)
            def wrapper(*args, **kw):
                print('Begin %s %s():' %(text, func.__name__))
                func(*args, **kw)
                print('End %s %s():' %(text, func.__name__))
            return wrapper
        return decorator
    else:
        @functools.wraps(text)
        def wrapper(*args, **kw):
            print('Begin Call %s():' %(text.__name__))
            text(*args,**kw)
            print('End Call %s():' %(text.__name__))
        return wrapper

@log
def time():
    print('10:35:48')

@log('Execute')
def date():
    print('2017-06-18')

time()
date()
```

示例 2：

>   Decorators are a shortcut to applying wrapper functions. This is helpful to "wrap" functionality with the same code over and over again. For example, I created a `retry` decorator for myself that I can just apply to any function and if any exception is thrown during a run, it is retried again, till a maximum of 5 times and with a delay between each retry. This is especially useful for situations where you are trying to make a network call to a remote computer:

修饰器是应用打包函数的捷径。这有助于用相同的代码一遍又一遍的打包功能。例如，我为自己创建一个 `retry` 装饰器，我可以将其应用到任何函数，假如在运行期间给出任何异常，它会再次尝试，最多尝试5次，每次重试之间有一个延迟。这在你试图对远程计算机进行网络调用的情况下尤其有用。

```
from time import sleep
from functools import wraps
import logging
logging.basicConfig()
log = logging.getLogger("retry")


def retry(f):
    @wraps(f)
    def wrapped_f(*args, **kwargs):
        MAX_ATTEMPTS = 5
        for attempt in range(1, MAX_ATTEMPTS + 1):
            try:
                return f(*args, **kwargs)
            except:
                log.exception("Attempt %s/%s failed : %s",
                              attempt,
                              MAX_ATTEMPTS,
                              (args, kwargs))
                sleep(10 * attempt)
        log.critical("All %s attempts failed : %s",
                     MAX_ATTEMPTS,
                     (args, kwargs))
    return wrapped_f


counter = 0


@retry
def save_to_database(arg):
    print("Write to a database or make a network call or etc.")
    print("This will be automatically retried if exception is thrown.")
    global counter
    counter += 1
    # This will throw an exception in the first call
    # And will work fine in the second call (i.e. a retry)
    if counter < 2:
        raise ValueError(arg)


if __name__ == '__main__':
    save_to_database("Some bad value")
```

Output:

```
$ python more_decorator.py
Write to a database or make a network call or etc.
This will be automatically retried if exception is thrown.
ERROR:retry:Attempt 1/5 failed : (('Some bad value',), {})
Traceback (most recent call last):
  File "more_decorator.py", line 14, in wrapped_f
    return f(*args, **kwargs)
  File "more_decorator.py", line 39, in save_to_database
    raise ValueError(arg)
ValueError: Some bad value
Write to a database or make a network call or etc.
This will be automatically retried if exception is thrown.
```






## 6. 偏函数 Partial function

The Python Standard Library » 10. Functional Programming Modules » 10.2. functools — Higher-order functions and operations on callable objects

>   class partial(builtins.object)
>    |  partial(func, *args, **keywords) - new function with partial application of the given arguments and keywords.新功能，部分应用给定的参数和关键字。
>
>    Data descriptors defined here:
>    |  `__dict__ `
>    |  args
>    |      tuple of arguments to future partial calls
>    |  func
>    |      function object to use in future partial calls
>    |  keywords
>    |      dictionary of keyword arguments to future partial calls

```
# 偏函数的整个转换过程大致相当于
def partial(func, *args, **keywords):
    def newfunc(*fargs, **fkeywords):
        newkeywords = keywords.copy()
        newkeywords.update(fkeywords)
        return func(*args, *fargs, **newkeywords)
    newfunc.func = func
    newfunc.args = args
    newfunc.keywords = keywords
    return newfunc
```

 `functools.partial` 会基于 **func** 创建出一个新函数。
新函数会固定住 **func** 中的部分参数，以使调用过程更为简洁。
可以理解为， `functools.partial` 设置/修改了 **func** 的参数的默认值，并返回一个新函数，以使调用过程更加简单。
注意：此处的偏函数和数学意义上的偏函数不一样。

```
# int默认按十进制转
>>> int('12345')
12345

# base参数可修改进制
>>> int('12345', base=8)
5349
>>> int('12345', 16)
74565

# 当需进行大量进制转换时，这样会比较方便
>>>def int2(x, base=2):
	    return int(x, base)
	    
>>> int2('1000000')
64
>>> int2('1010101')
85
```

`functools.partial` 可直接创建这样的新函数：

```
>>> import functools
>>> int2 = functools.partial(int, base=2)
>>> int2('1000000')
64
>>> int2('1010101')
85

# 默认参数同样可以被修改
>>> int2('1000000', base=10)
1000000
```

### func, \*args, \*\*keywords 的关系

基于偏函数的转换过程：

```
# 偏函数的整个转换过程大致相当于
def partial(func, *args, **keywords):
    def newfunc(*fargs, **fkeywords):
        newkeywords = keywords.copy()
        newkeywords.update(fkeywords)
        return func(*args, *fargs, **newkeywords)
    newfunc.func = func
    newfunc.args = args
    newfunc.keywords = keywords
    return newfunc
```

注意理解 func, \*args, \*\*keywords 这三个参数间的关系。

```
# 创建偏函数
>>> int2 = functools.partial(int, base=2)

# 那么
>>> int2('10010')
# 等效于：
>>> kw = { 'base': 2 }
>>> int('10010', **kw)
```

又或是：

```
>>> max2 = functools.partial(max, 10)

# 那么
>>> max2(5, 6, 7)
# 相当于
>>> args = (10, 5, 6, 7)
>>> max(*args)
>>> 10
```







































































