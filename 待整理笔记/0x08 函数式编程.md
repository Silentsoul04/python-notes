# 0x08 函数式编程

[TOC]



1. 高阶函数-

指向函数的变量-

将函数作为参数-

2. 内建高阶函数-

### reduce 

>   reduce(...)
>
>   reduce(function, sequence[, initial]) -> value
>
>   Apply a function of two arguments cumulatively to the items of a sequence, from left to right, so as to reduce the sequence to a single value. 
>
>   For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates ((((1+2)+3)+4)+5).  
>
>   If **initial** is present, it is placed before the items of the sequence in the calculation, and serves as a default when the sequence is empty.

```
reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
```

注意：function 参数必须能够接受两个参数，且必须有恰当的返回值。

```
# 由于print_()函数默认返回None，
# 所以会将None作为参数打印
In [1]: def print_(x,y):
   ...:     print(x,y)
   ...:
   
In [4]: reduce(print_,[0,1,2,3])
0 1
None 2
None 3
```

```
import functools
# 计算一个数列的乘积
product = functools.reduce(lambda x, y: x*y, range(1, 11))
```

示例：实现 `int` 函数的功能：

```
from functools import reduce

def str2int(s):
    def fn(x, y):
        return x * 10 + y
    def char2num(s):
        return {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}[s]
    return reduce(fn, map(char2num, s))
```

lambda 函数可对函数进行简化：

```
from functools import reduce

def char2num(s):
    return {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}[s]

def str2int(s):
    return reduce(lambda x, y: x * 10 + y, map(char2num, s))
```

### 

3. 返回函数对象-

函数对象作为返回值-

每次均返回新的函数对象-

被返回的是函数对象-

将函数调用作为返回值-

返回函数引用循环变量-

4. 匿名函数 lambda-









将 lanmbda 作为返回值-

5. 装饰器 Decorator-

装饰器本身不需要参数-

装饰器本身需要参数-

@functools.wraps(func)-




## 6. 偏函数 Partial function

The Python Standard Library » 10. Functional Programming Modules » 10.2. functools — Higher-order functions and operations on callable objects

>   class partial(builtins.object)
>    |  partial(func, *args, **keywords) - new function with partial application of the given arguments and keywords.新功能，部分应用给定的参数和关键字。
>
>    Data descriptors defined here:
>    |  `__dict__ `
>    |  args
>    |      tuple of arguments to future partial calls
>    |  func
>    |      function object to use in future partial calls
>    |  keywords
>    |      dictionary of keyword arguments to future partial calls

```
# 偏函数的整个转换过程大致相当于
def partial(func, *args, **keywords):
    def newfunc(*fargs, **fkeywords):
        newkeywords = keywords.copy()
        newkeywords.update(fkeywords)
        return func(*args, *fargs, **newkeywords)
    newfunc.func = func
    newfunc.args = args
    newfunc.keywords = keywords
    return newfunc
```

 `functools.partial` 会基于 **func** 创建出一个新函数。
新函数会固定住 **func** 中的部分参数，以使调用过程更为简洁。
可以理解为， `functools.partial` 设置/修改了 **func** 的参数的默认值，并返回一个新函数，以使调用过程更加简单。
注意：此处的偏函数和数学意义上的偏函数不一样。

```
# int默认按十进制转
>>> int('12345')
12345

# base参数可修改进制
>>> int('12345', base=8)
5349
>>> int('12345', 16)
74565

# 当需进行大量进制转换时，这样会比较方便
>>>def int2(x, base=2):
	    return int(x, base)
	    
>>> int2('1000000')
64
>>> int2('1010101')
85
```

`functools.partial` 可直接创建这样的新函数：

```
>>> import functools
>>> int2 = functools.partial(int, base=2)
>>> int2('1000000')
64
>>> int2('1010101')
85

# 默认参数同样可以被修改
>>> int2('1000000', base=10)
1000000
```

### func, \*args, \*\*keywords 的关系

基于偏函数的转换过程：

```
# 偏函数的整个转换过程大致相当于
def partial(func, *args, **keywords):
    def newfunc(*fargs, **fkeywords):
        newkeywords = keywords.copy()
        newkeywords.update(fkeywords)
        return func(*args, *fargs, **newkeywords)
    newfunc.func = func
    newfunc.args = args
    newfunc.keywords = keywords
    return newfunc
```

注意理解 func, \*args, \*\*keywords 这三个参数间的关系。

```
# 创建偏函数
>>> int2 = functools.partial(int, base=2)

# 那么
>>> int2('10010')
# 等效于：
>>> kw = { 'base': 2 }
>>> int('10010', **kw)
```

又或是：

```
>>> max2 = functools.partial(max, 10)

# 那么
>>> max2(5, 6, 7)
# 相当于
>>> args = (10, 5, 6, 7)
>>> max(*args)
>>> 10
```







































































