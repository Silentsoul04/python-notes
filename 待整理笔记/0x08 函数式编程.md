# 0x08 函数式编程

[TOC]

函数就是**面向过程的程序设计**的基本单元。

Functional Programming：**函数式编程**，虽然也可以归结到面向过程的程序设计中，但其思想更接近数学计算。functional programming 似乎也被称作 Monad。(注意：这里是在讲述 “函数**式**编程”，而非 “函数编程”。)

procedurally(过程式编程), functional programming(函数式编程),object orientation(面向对象)。 

如何理解编程方式中所谓的**抽象程度**？
对编程语言而言，越低级的语言越接近底层硬件，其执行效率越高，但是抽象程度越低。越是高级的语言，越贴近计算 compute ，其抽象程度越高，但是执行效率越低。
这里所指的**计算 compute**，是指数学意义上的计算，越是抽象的计算，离底层硬件越远。对于计算机硬件而言，汇编语言的抽象程度最低，最贴近机器语言。

**函数式编程** ：就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数**没有变量**，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。

函数式编程的一个特点是，**允许把函数本身作为参数传入另一个函数，还允许返回一个函数**！

Python 对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。

## 1. 高阶函数

高阶函数 (Higher-order function) 是指能够接受另外一个函数作为参数的函数，并且会以某种方式应用该函数。
函数式编程就是指这种高度抽象的编程范式。

https://en.wikipedia.org/wiki/Higher-order_function

Python 中的函数都是第一类的数据对象，因此可以将函数赋值给变量、保存到数据结构中、作为参数传递给其它函数，以及作为其它函数的返回值。

### 指向函数的变量

以 `abs()` 函数为例，进行讲解：

-   `abs` 是函数名，函数名其实就是**指向函数对象的变量**，它和普通变量没有区别。

-   `abs(-10)` 是对函数的调用。

    ```
    >>> abs
    <built-in function abs>
    >>> abs.__name__
    'abs'

    >>> abs(-10)
    10
    ```


-   普通变量也可指向函数，即把函数本身赋值给普通变量。

    ```
    >>> abs
    <built-in function abs>
    >>> abs.__name__
    'abs'

    >>> f = abs
    >>> f
    <built-in function abs>
    >>> f.__name__
    'abs' 
    ```

-   直接调用 `abs()` 函数和调用变量 `f()` 完全相同。

    ```
    >>> f = abs
    >>> f(-10)
    10
    ```

-   函数名也可用于指向其它对象。但是改变函数名的指向后，就再也无法通过该名称调用此函数对象了。要恢复 `abs` 函数，需要重启交互环境。
    提醒： `abs` 函数实际上是定义在 `import builtins` 模块中的。

    ```
    >>> abs=10
    >>> abs # abs现在指向整数10
    10
    >>> abs(-10)
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    TypeError: 'int' object is not callable
    ```

### 将函数作为参数

函数能够接受变量，同时变量也可指向函数。
那么，便有可能将函数作为参数传递给另一个函数。
像这样，当 A 函数有能力接受 B 函数作为参数时，便称 A 是高阶函数。
编写高阶函数的目的，就是为了接受别的函数作为参数。

```
def add(x, y, f):
    return f(x) + f(y)

>>> add(-5, 6, abs)
11
```



## 2. 内建高阶函数

- 内置函数 map 属于高阶函数，因为它接受函数作为参数。
- 内置函数 filter 属于高阶函数，因为它接受函数作为参数。
- 内置函数 sorted 属于高阶函数，因为它接受函数作为参数。

### reduce 

>   reduce(...)
>
>   reduce(function, sequence[, initial]) -> value
>
>   Apply a function of two arguments cumulatively to the items of a sequence, from left to right, so as to reduce the sequence to a single value. 
>
>   For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates ((((1+2)+3)+4)+5).  
>
>   If **initial** is present, it is placed before the items of the sequence in the calculation, and serves as a default when the sequence is empty.

```
reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
```

注意：function 参数必须能够接受两个参数，且必须有恰当的返回值。

```
# 由于print_()函数默认返回None，
# 所以会将None作为参数打印
In [1]: def print_(x,y):
   ...:     print(x,y)
   ...:
   
In [4]: reduce(print_,[0,1,2,3])
0 1
None 2
None 3
```

```
import functools
# 计算一个数列的乘积
product = functools.reduce(lambda x, y: x*y, range(1, 11))
```

示例：实现 `int` 函数的功能：

```
from functools import reduce

def str2int(s):
    def fn(x, y):
        return x * 10 + y
    def char2num(s):
        return {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}[s]
    return reduce(fn, map(char2num, s))
```

lambda 函数可对函数进行简化：

```
from functools import reduce

def char2num(s):
    return {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}[s]

def str2int(s):
    return reduce(lambda x, y: x * 10 + y, map(char2num, s))
```

### 

## 3. 返回函数对象

### 函数对象作为返回值

高阶函数不仅能够接受函数作为参数，还可把它内部的函数作为作为返回值。
当某个函数作为返回值时，牢记该函数并未立即执行。
另外，在返回函数中也不要引用任何可能会变化的量。

示例，求和函数：

```
def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum

# 调用外函数时，将内函数作为返回值
# 此时并不会立即计算出结果
>>> f = lazy_sum(1, 3, 5, 7, 9)
>>> f # f是函数名
<function lazy_sum.<locals>.sum at 0x101c6ed90>

>>> f() #调用此函数时，才真的会计算结果
25
```

本示例，在外函数 `lazy_sum` 中定了内函数 `sum` 。
内函数可以引用外函数的参数和局部变量。
当内函数被外函数作为返回值时，相关参数和变量都会被保存在内函数中。
这就是所谓的 “ **闭包(Closure)** ”。

### 每次均返回新的函数对象

每次调用 `lazy_sum()` 都会返回一个新函数对象，同之前返回的函数对象有完全不同的内存地址。即使传入相同的参数，所返回的函数对象也不相同。调用不同的返回对象时，其调用结果也互不影响。

```
>>> f1 = lazy_sum(1, 3, 5, 7, 9)
>>> f2 = lazy_sum(1, 3, 5, 7, 9)
>>> f1==f2
False

>>> f1 = lazy_sum(1, 3, 5, 7, 9)
>>> f1
<function lazy_sum.<locals>.sum at 0x00000295322FEAE8>
>>> f2 = lazy_sum(1, 3, 5, 7, 9)
>>> f2
<function lazy_sum.<locals>.sum at 0x00000295322FEB70>

>>> f3 = f2
>>> f3
<function lazy_sum.<locals>.sum at 0x00000295322FEB70>

>>> f1 == f2
False
>>> f2 == f3
True
```



### 被返回的是函数对象

#### 将函数调用作为返回值

本节用于对比 “返回函数(或说返回函数对象)” 和 “返回函数调用” 间的区别
如果将函数的调用作为返回值，就会在返回时立即执行。

示例 1：

```
>>> def lazy_sum_call(*args):
...     def sum():
...         ax = 0
...         for n in args:
...             ax = ax + n
...         return ax
...     return sum() # 此处返回函数的调用
...
>>> f1 = lazy_sum(1,2)
>>> f1
3 # 这里会直接得到结果
```

 示例 2：

```
In [26]: def count():
    ...:     fs = []
    ...:     for i in range(1, 4):
    ...:         def f():
    ...:              return i*i
    ...:         fs.append(f())
    ...:     return fs
    ...:

In [27]: f1, f2, f3 = count()

In [28]: f1
Out[28]: 1

In [29]: f2
Out[29]: 4

In [30]: f3
Out[30]: 9
```

### 返回函数引用循环变量

当必须要在 “返回函数” 中引用循环变量时，可以再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：

```
def count():
    def f(j):
        def g():
            return j*j
        return g
    fs = []
    for i in range(1, 4):
        fs.append(f(i)) # 注意此处是在调用函数。
    return fs
```

再看看结果：

```
>>> f1, f2, f3 = count()
>>> f1()
1
>>> f2()
4
>>> f3()
9

```

缺点是代码较长，可利用lambda函数缩短代码。

## 4. 匿名函数 lambda

Lambda 表达式的语法如下：

`lambda <argument list>:<expression>` 

利用 `lambda` 关键字可以创建短小的匿名函数。
Lambda 函数可用于任何需要函数对象的地方。

匿名函数在语法结构上被限制为一个单独的表达式，不能使用 `return` 语句，返回值就是该表达式的结果。

`lambda x: x * x` 等效于：

```
def f(x):
    return x * x
```

匿名函数也是函数对象，同样可以为其指定函数名。

```
>>> f = lambda x: x * x
>>> f
<function <lambda> at 0x101c6ef28>
>>> f(5)
25
```

### 将 lanmbda 作为参数

```
>>> list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
[1, 4, 9, 16, 25, 36, 49, 64, 81]
```

### 将 lanmbda 作为返回值

```
def build(x, y):
    return lambda: x * x + y * y
```

lambda 函数可以从所包含的作用域中引用变量：

```
>>> def make_incrementor(n):
...     return lambda x: x + n
...
>>> f = make_incrementor(42)
>>> f(0)
42
>>> f(1)
43
```



## 5. 装饰器 Decorator

### 装饰器本身不需要参数

### 装饰器本身需要参数

### @functools.wraps(func)




## 6. 偏函数 Partial function

The Python Standard Library » 10. Functional Programming Modules » 10.2. functools — Higher-order functions and operations on callable objects

>   class partial(builtins.object)
>    |  partial(func, *args, **keywords) - new function with partial application of the given arguments and keywords.新功能，部分应用给定的参数和关键字。
>
>    Data descriptors defined here:
>    |  `__dict__ `
>    |  args
>    |      tuple of arguments to future partial calls
>    |  func
>    |      function object to use in future partial calls
>    |  keywords
>    |      dictionary of keyword arguments to future partial calls

```
# 偏函数的整个转换过程大致相当于
def partial(func, *args, **keywords):
    def newfunc(*fargs, **fkeywords):
        newkeywords = keywords.copy()
        newkeywords.update(fkeywords)
        return func(*args, *fargs, **newkeywords)
    newfunc.func = func
    newfunc.args = args
    newfunc.keywords = keywords
    return newfunc
```

 `functools.partial` 会基于 **func** 创建出一个新函数。
新函数会固定住 **func** 中的部分参数，以使调用过程更为简洁。
可以理解为， `functools.partial` 设置/修改了 **func** 的参数的默认值，并返回一个新函数，以使调用过程更加简单。
注意：此处的偏函数和数学意义上的偏函数不一样。

```
# int默认按十进制转
>>> int('12345')
12345

# base参数可修改进制
>>> int('12345', base=8)
5349
>>> int('12345', 16)
74565

# 当需进行大量进制转换时，这样会比较方便
>>>def int2(x, base=2):
	    return int(x, base)
	    
>>> int2('1000000')
64
>>> int2('1010101')
85
```

`functools.partial` 可直接创建这样的新函数：

```
>>> import functools
>>> int2 = functools.partial(int, base=2)
>>> int2('1000000')
64
>>> int2('1010101')
85

# 默认参数同样可以被修改
>>> int2('1000000', base=10)
1000000
```

### func, \*args, \*\*keywords 的关系

基于偏函数的转换过程：

```
# 偏函数的整个转换过程大致相当于
def partial(func, *args, **keywords):
    def newfunc(*fargs, **fkeywords):
        newkeywords = keywords.copy()
        newkeywords.update(fkeywords)
        return func(*args, *fargs, **newkeywords)
    newfunc.func = func
    newfunc.args = args
    newfunc.keywords = keywords
    return newfunc
```

注意理解 func, \*args, \*\*keywords 这三个参数间的关系。

```
# 创建偏函数
>>> int2 = functools.partial(int, base=2)

# 那么
>>> int2('10010')
# 等效于：
>>> kw = { 'base': 2 }
>>> int('10010', **kw)
```

又或是：

```
>>> max2 = functools.partial(max, 10)

# 那么
>>> max2(5, 6, 7)
# 相当于
>>> args = (10, 5, 6, 7)
>>> max(*args)
>>> 10
```







































































