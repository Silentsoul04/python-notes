# 正则表达式

Regular Expression

[TOC]

对应的内嵌标志表达式是 (?i)，它有四种形式：
1，(?i) 开
2，(?-i) 关
3，(?i:X) 开
4，(?-i:X) 关

https://my.oschina.net/cshuangxi/blog/295622

## 1. 简介



## 2. 正则表达式语法

### 特殊序列

special sequences

- `\A`

    

- `\b`

    

    ```
    pattern = r"\b(cat)\b"
    # "\b(cat)\b" basically matches the word "cat" surrounded by word boundaries.
    match = re.search(pattern, "The cat sat!")
    if match:
       print ("Match 1")
    
    match = re.search(pattern, "We s>cat<tered?")
    if match:
       print ("Match 2")
    
    match = re.search(pattern, "We scattered.")
    if match:
       print ("Match 3")
       
    >>>
    Match 1
    Match 2
    >>>
    ```

- `\B`

    

- `\d` 

    

- `\D`

    

- `\s`

    

- `\S`

    

- `\w`

    -   

- `\W`

- `\Z`

  



## 3. Module Contents[¶](https://docs.python.org/3/library/re.html#module-contents)

6.2.2. Module Contents[¶](https://docs.python.org/3/library/re.html#module-contents)

### re.match( )

re.match(*pattern*, *string*, *flags=0*)



```
>>> import re
>>> re.match(r'^\d{3}\-\d{3,8}$', '010-12345')
<_sre.SRE_Match object; span=(0, 9), match='010-12345'>
>>> re.match(r'^\d{3}\-\d{3,8}$', '010 12345')
>>>
```

常见用法：

```
test = '用户输入的字符串'
if re.match(r'正则表达式', test):
    print('ok')
else:
    print('failed')
```

### re.search( )

re.search(*pattern*, *string*, *flags=0*)



### re.findall( )

re.findall(*pattern*, *string*, *flags=0*)



### re.finditer( )

re.finditer(*pattern*, *string*, *flags=0*)



### re.sub( )



```
import re

str = "My name is David. Hi David."
pattern = r"David"
newstr = re.sub(pattern, "Amy", str)
print(newstr)

>>>
My name is Amy. Hi Amy.
>>>
```

re.sub(*pattern*, *repl*, *string*, *count=0*, *flags=0*)



### re.split()

- re.split(pattern, string, maxsplit=0, flags=0)


    注意：实例中列表末尾的空字符串。

    ```
    >>> re.split('\W+', 'Words, words, words.')
    ['Words', 'words', 'words', '']
    >>> re.split('(\W+)', 'Words, words, words.')
    ['Words', ', ', 'words', ', ', 'words', '.', '']
    >>> re.split('\W+', 'Words, words, words.', 1)
    ['Words', 'words, words.']
    >>> re.split('[a-f]+', '0a3B9', flags=re.IGNORECASE)
    ['0', '3', '9']
    ```


    If there are capturing groups in the separator分离器 and it matches at the start of the string, the result will start with an empty string. The same holds for the end of the string:
    
    ​```
    >>> re.split('(\W+)', '...words, words...')
    ['', '...', 'words', ', ', 'words', '...', '']
    ​```

使用 regex 的分拆字符串比使用字符串方法更灵活：

```
# 字符串方法：无法识别连续空格
>>> 'a b   c'.split(' ')
['a', 'b', '', '', 'c']
# regex：
>>> re.split(r'\s+', 'a b   c')
['a', 'b', 'c']

>>> re.split(r'[\s\,]+', 'a,b, c  d')
['a', 'b', 'c', 'd']

>>> re.split(r'[\s\,\;]+', 'a,b;; c  d')
['a', 'b', 'c', 'd']
```



## 4. Match Objects

6.2.4. Match Objects[¶](https://docs.python.org/3/library/re.html#match-objects)

### match.group

match.group([*group1*, *...*])[¶](https://docs.python.org/3/library/re.html#re.match.group)

用括号包裹 regex 便可创建分组，提取子串。
group 可以同元字符一起使用。

```
>>> m = re.match(r"(\w+) (\w+)", "Isaac Newton, physicist")
>>> m.group(0)       # The entire match
'Isaac Newton'
>>> m.group(1)       # The first parenthesized subgroup.
'Isaac'
>>> m.group(2)       # The second parenthesized subgroup.
'Newton'
>>> m.group(1, 2)    # Multiple arguments give us a tuple.
('Isaac', 'Newton')
```

-   **named groups** : 格式为 ` (?P<name>...)` ，`name` 表示 group 的名称，`...` 表示 group 的内容。被命名后的 group 可通过名称或序号进行访问。

-   **Non-capturing groups** : 格式为 `(?:...)` ，这样的 group 不能通过组方法进行访问。如果将其插入到现有的 regex 中，并不会破坏现有的 group 的顺序。

    ```
    In [48]: pattern = r"(?P<first>abc)(?:...)(ghi)"

    In [49]: match = re.match(pattern, "abcdefghi")

    In [50]: match.group(1)
    Out[50]: 'abc'

    In [51]: match.group(2)
    Out[51]: 'ghi'

    In [52]: match.group()
    Out[52]: 'abcdefghi'

    In [54]: match.groups(0)
    Out[54]: ('abc', 'ghi')
    ```

### match.groups



## 5. 预编译正则表达式

当我们在Python中使用正则表达式时，re模块内部会干两件事情：

1.  编译正则表达式，如果正则表达式的字符串本身不合法，会报错；
2.  用编译后的正则表达式去匹配字符串。

如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：

```
>>> import re
# 编译:
>>> re_telephone = re.compile(r'^(\d{3})-(\d{3,8})$')
# 使用：
>>> re_telephone.match('010-12345').groups()
('010', '12345')
>>> re_telephone.match('010-8086').groups()
('010', '8086')
```

编译后生成 Regular Expression Objects[¶](https://docs.python.org/3/library/re.html#regular-expression-objects) 。
regex 对象也拥有相应的方法和属性，这方法和属性与 Module Contents 中介绍的方法类似。但是在调用时，无需再次给出 regex。

## 6. 贪婪匹配

正则匹配默认是贪婪匹配，会匹配尽可能多的字符。
举例如下，匹配出数字后面的`0`：

```
>>> re.match(r'^(\d+)(0*)$', '102300').groups()
('102300', '')
```

 `\d+` 采用贪婪匹配，会直接把后面的`0`全部匹配，导致 `0*` 只能匹配空字符串。
此时需要采用非贪婪匹配，加个 `?` 就可以让`\d+`采用非贪婪匹配：

```
>>> re.match(r'^(\d+?)(0*)$', '102300').groups()
('1023', '00')
```







