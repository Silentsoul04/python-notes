# 正则表达式

Regular Expression

[TOC]

对应的内嵌标志表达式是 (?i)，它有四种形式：
1，(?i) 开
2，(?-i) 关
3，(?i:X) 开
4，(?-i:X) 关

https://my.oschina.net/cshuangxi/blog/295622

## 1. 简介



## 2. 正则表达式语法

### 特殊序列

special sequences

-   `\A`

    Matches only at the start of the string.
    The sequences **\A** and **\Z** match the beginning and end of a string, respectively. 

-   `\b`

    Matches the empty string, but only at the beginning or end of **a word**. A word is defined as a sequence of Unicode alphanumeric or underscore characters, so the end of a word is indicated by whitespace or a non-alphanumeric, non-underscore Unicode character. Note that formally, `\b` is defined as the boundary between a `\w` and a `\W` character (or vice versa), or between `\w` and the beginning/end of the string. This means that `r'\bfoo\b'` matches `'foo'`, `'foo.'`, `'(foo)'`, `'bar foo baz'` but not `'foobar'` or `'foo3'`.

    By default Unicode alphanumerics are the ones used, but this can be changed by using the [`ASCII`](https://docs.python.org/3/library/re.html#re.ASCII) flag. Inside a character range, `\b` represents the backspace character, for compatibility with Python’s string literals.

    ```
    pattern = r"\b(cat)\b"
    # "\b(cat)\b" basically matches the word "cat" surrounded by word boundaries.
    match = re.search(pattern, "The cat sat!")
    if match:
       print ("Match 1")

    match = re.search(pattern, "We s>cat<tered?")
    if match:
       print ("Match 2")

    match = re.search(pattern, "We scattered.")
    if match:
       print ("Match 3")
       
    >>>
    Match 1
    Match 2
    >>>
    ```

-   `\B`

    Matches the empty string, but only when it is *not* at the beginning or end of a word. This means that `r'py\B'` matches `'python'`, `'py3'`, `'py2'`, but not `'py'`, `'py.'`, or `'py!'`. `\B` is just the opposite of `\b`, so word characters are Unicode alphanumerics or the underscore, although this can be changed by using the [`ASCII`](https://docs.python.org/3/library/re.html#re.ASCII) flag.

-   `\d` 

    -   For Unicode (str) patterns:

        Matches any **Unicode decimal digit** (that is, any character in Unicode character category [Nd]). This includes `[0-9]`, and also many other digit characters. If the [`ASCII`](https://docs.python.org/3/library/re.html#re.ASCII) flag is used only `[0-9]` is matched (but the flag affects the entire regular expression, so in such cases using an explicit `[0-9]` may be a better choice).

    -   For 8-bit (bytes) patterns:

        Matches any decimal digit; this is equivalent to `[0-9]`.

-   `\D`

    Matches any character which is not a Unicode decimal digit. This is the **opposite**相反的 of `\d`. If the [`ASCII`](https://docs.python.org/3/library/re.html#re.ASCII) flag is used this becomes the equivalent of `[^0-9]` (but the flag affects the entire regular expression, so in such cases using an explicit `[^0-9]` may be a better choice).

-   `\s`

    -   For Unicode (str) patterns:

        Matches Unicode whitespace characters (which includes `[ \t\n\r\f\v]`, and also many other characters, for example the non-breaking spaces mandated by typography rules in many languages). If the [`ASCII`](https://docs.python.org/3/library/re.html#re.ASCII) flag is used, only `[ \t\n\r\f\v]` is matched (but the flag affects the entire regular expression, so in such cases using an explicit `[ \t\n\r\f\v]`may be a better choice).

    -   For 8-bit (bytes) patterns:

        Matches characters considered whitespace in the ASCII character set; this is equivalent to `[ \t\n\r\f\v]`.

-   `\S`

    Matches any character which is not a Unicode whitespace character. This is the **opposite** of `\s`. If the [`ASCII`](https://docs.python.org/3/library/re.html#re.ASCII) flag is used this becomes the equivalent of `[^ \t\n\r\f\v]` (but the flag affects the entire regular expression, so in such cases using an explicit `[^ \t\n\r\f\v]` may be a better choice).

-   `\w`

    -   For Unicode (str) patterns:

        Matches **Unicode word characters**; this includes most characters that can be part of a word in any language, as well as numbers and the underscore. If the [`ASCII`](https://docs.python.org/3/library/re.html#re.ASCII) flag is used, only `[a-zA-Z0-9_]` is matched (but the flag affects the entire regular expression, so in such cases using an explicit `[a-zA-Z0-9_]` may be a better choice).

    -   For 8-bit (bytes) patterns:

        Matches characters considered alphanumeric in the ASCII character set; this is equivalent to `[a-zA-Z0-9_]`.

-   `\W`
  Matches any character which is **not a Unicode word character**. This is the **opposite** of `\w`. If the [`ASCII`](https://docs.python.org/3/library/re.html#re.ASCII) flag is used this becomes the equivalent of `[^a-zA-Z0-9_]` (but the flag affects the entire regular expression, so in such cases using an explicit `[^a-zA-Z0-9_]` may be a better choice).

-   `\Z`

  Matches only at the end of the string.



## 3. Module Contents[¶](https://docs.python.org/3/library/re.html#module-contents)

6.2.2. Module Contents[¶](https://docs.python.org/3/library/re.html#module-contents)

### re.match( )

re.match(*pattern*, *string*, *flags=0*)

If zero or more characters **at the beginning of** *string* match the regular expression *pattern*, return a corresponding [match object](https://docs.python.org/3/library/re.html#match-objects). Return `None` if the string does not match the pattern; note that this is different from a zero-length match.

Note that even in [`MULTILINE`](https://docs.python.org/3/library/re.html#re.MULTILINE) mode, [`re.match()`](https://docs.python.org/3/library/re.html#re.match) will only match at the beginning of the string and not at the beginning of each line.

If you want to locate定位 a match anywhere in *string*, use [`search()`](https://docs.python.org/3/library/re.html#re.search) instead (see also [search() vs. match()](https://docs.python.org/3/library/re.html#search-vs-match)).

```
>>> import re
>>> re.match(r'^\d{3}\-\d{3,8}$', '010-12345')
<_sre.SRE_Match object; span=(0, 9), match='010-12345'>
>>> re.match(r'^\d{3}\-\d{3,8}$', '010 12345')
>>>
```

常见用法：

```
test = '用户输入的字符串'
if re.match(r'正则表达式', test):
    print('ok')
else:
    print('failed')
```

### re.search( )

re.search(*pattern*, *string*, *flags=0*)

Scan through *string* looking for the **first location** where the regular expression *pattern* produces a match, and return a corresponding [match object](https://docs.python.org/3/library/re.html#match-objects). Return `None` if no position in the string matches the pattern; note that this is different from finding a zero-length match at some point in the string.

### re.findall( )

re.findall(*pattern*, *string*, *flags=0*)

Return all non-overlapping非重叠 matches of *pattern* in *string*, as a list of strings. The *string* is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result unless they touch the beginning of another match.

### re.finditer( )

re.finditer(*pattern*, *string*, *flags=0*)

Return an [iterator](https://docs.python.org/3/glossary.html#term-iterator) yielding [match objects](https://docs.python.org/3/library/re.html#match-objects) over all non-overlapping matches for the RE *pattern*in *string*. The *string* is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result unless they touch the beginning of another match.
The function **re.finditer** does the same thing as **re.findall** , except it returns an iterator, rather than a list.

### re.sub( )

This method replaces all occurrences出现 of the **pattern **in string with **repl**, substituting all occurrences, unless **max** provided. This method returns the modified string. 

```
import re

str = "My name is David. Hi David."
pattern = r"David"
newstr = re.sub(pattern, "Amy", str)
print(newstr)

>>>
My name is Amy. Hi Amy.
>>>
```

re.sub(*pattern*, *repl*, *string*, *count=0*, *flags=0*)

Return the string obtained by replacing the leftmost non-overlapping occurrences of *pattern* in *string* by the replacement *repl*. If the pattern isn’t found, *string* is returned unchanged. *repl* can be a string or a function; if it is a string, any backslash escapes in it are processed. That is, `\n`is converted to a single newline character, `\r` is converted to a carriage return, and so forth. Unknown escapes such as `\&` are left alone. Backreferences, such as `\6`, are replaced with the substring matched by group 6 in the pattern. For example:

```
re.sub(r'def\s+([a-zA-Z_][a-zA-Z_0-9]*)\s*\(\s*\):',
       r'static PyObject*\npy_\1(void)\n{',
       'def myfunc():')
>>> 'static PyObject*\npy_myfunc(void)\n{'
```

### re.split()

-   re.split(pattern, string, maxsplit=0, flags=0)

    Split *string* by the occurrences of *pattern*. 

    If capturing捕获 parentheses are used in *pattern* ( `'(\W+)'` ), then the text of all groups in the pattern are also returned as part of the resulting list. 

    If *maxsplit* is nonzero, at most *maxsplit* splits occur发生, and the remainder剩余的 of the string is returned as the final element of the list.
    注意：实例中列表末尾的空字符串。

    ```
    >>> re.split('\W+', 'Words, words, words.')
    ['Words', 'words', 'words', '']
    >>> re.split('(\W+)', 'Words, words, words.')
    ['Words', ', ', 'words', ', ', 'words', '.', '']
    >>> re.split('\W+', 'Words, words, words.', 1)
    ['Words', 'words, words.']
    >>> re.split('[a-f]+', '0a3B9', flags=re.IGNORECASE)
    ['0', '3', '9']
    ```


    If there are capturing groups in the separator分离器 and it matches at the start of the string, the result will start with an empty string. The same holds for the end of the string:
    
    ​```
    >>> re.split('(\W+)', '...words, words...')
    ['', '...', 'words', ', ', 'words', '...', '']
    ​```

使用 regex 的分拆字符串比使用字符串方法更灵活：

```
# 字符串方法：无法识别连续空格
>>> 'a b   c'.split(' ')
['a', 'b', '', '', 'c']
# regex：
>>> re.split(r'\s+', 'a b   c')
['a', 'b', 'c']

>>> re.split(r'[\s\,]+', 'a,b, c  d')
['a', 'b', 'c', 'd']

>>> re.split(r'[\s\,\;]+', 'a,b;; c  d')
['a', 'b', 'c', 'd']
```



## 4. Match Objects

6.2.4. Match Objects[¶](https://docs.python.org/3/library/re.html#match-objects)

### match.group

match.group([*group1*, *...*])[¶](https://docs.python.org/3/library/re.html#re.match.group)

用括号包裹 regex 便可创建分组，提取子串。
group 可以同元字符一起使用。

```
>>> m = re.match(r"(\w+) (\w+)", "Isaac Newton, physicist")
>>> m.group(0)       # The entire match
'Isaac Newton'
>>> m.group(1)       # The first parenthesized subgroup.
'Isaac'
>>> m.group(2)       # The second parenthesized subgroup.
'Newton'
>>> m.group(1, 2)    # Multiple arguments give us a tuple.
('Isaac', 'Newton')
```

-   **named groups** : 格式为 ` (?P<name>...)` ，`name` 表示 group 的名称，`...` 表示 group 的内容。被命名后的 group 可通过名称或序号进行访问。

-   **Non-capturing groups** : 格式为 `(?:...)` ，这样的 group 不能通过组方法进行访问。如果将其插入到现有的 regex 中，并不会破坏现有的 group 的顺序。

    ```
    In [48]: pattern = r"(?P<first>abc)(?:...)(ghi)"

    In [49]: match = re.match(pattern, "abcdefghi")

    In [50]: match.group(1)
    Out[50]: 'abc'

    In [51]: match.group(2)
    Out[51]: 'ghi'

    In [52]: match.group()
    Out[52]: 'abcdefghi'

    In [54]: match.groups(0)
    Out[54]: ('abc', 'ghi')
    ```

### match.groups



## 5. 预编译正则表达式

当我们在Python中使用正则表达式时，re模块内部会干两件事情：

1.  编译正则表达式，如果正则表达式的字符串本身不合法，会报错；
2.  用编译后的正则表达式去匹配字符串。

如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：

```
>>> import re
# 编译:
>>> re_telephone = re.compile(r'^(\d{3})-(\d{3,8})$')
# 使用：
>>> re_telephone.match('010-12345').groups()
('010', '12345')
>>> re_telephone.match('010-8086').groups()
('010', '8086')
```

编译后生成 Regular Expression Objects[¶](https://docs.python.org/3/library/re.html#regular-expression-objects) 。
regex 对象也拥有相应的方法和属性，这方法和属性与 Module Contents 中介绍的方法类似。但是在调用时，无需再次给出 regex。

## 6. 贪婪匹配

正则匹配默认是贪婪匹配，会匹配尽可能多的字符。
举例如下，匹配出数字后面的`0`：

```
>>> re.match(r'^(\d+)(0*)$', '102300').groups()
('102300', '')
```

 `\d+` 采用贪婪匹配，会直接把后面的`0`全部匹配，导致 `0*` 只能匹配空字符串。
此时需要采用非贪婪匹配，加个 `?` 就可以让`\d+`采用非贪婪匹配：

```
>>> re.match(r'^(\d+?)(0*)$', '102300').groups()
('1023', '00')
```







