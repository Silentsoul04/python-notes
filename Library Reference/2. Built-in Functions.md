# Built-in Functions

[TOC]

## a

### abs

`abs(x)` 

返回一个数的绝对值。
如果实参(argument)是整数或浮点数，则会返回其绝对值。
如果实参是复数(complex number)，则会返回复数的模(magnitude)

```python
>>> abs(-3)
3
>>> abs(-3.4)
3.4
>>> abs(3+4j)
5.0
```

### all

`all(iterable)` 

如下代码与该内置函数等效：

```python
def all(iterable):
    for element in iterable:
        if not element:
            return False
    return True
```

可见，如果可迭代(iterable)对象中所有元素的布尔值均为真，则返回 `True`。
注意，如果可迭代对象为空，也是返回 `True`。

### any

`any(iterable)`

如下代码与该内置函数等效：

```python
def any(iterable):
    for element in iterable:
        if element:
            return True
    return False
```

如果可迭代(iterable)对象中存在布尔值为真的元素，则返回 `True`。
注意，如果可迭代对象为空，也是返回 `True`。

### ascii

`ascii(object)`

类似于 [`repr()`](https://docs.python.org/3.7/library/functions.html#repr)，该函数也会返回一个用于描述 object 的字符串。与 [`repr()`](https://docs.python.org/3.7/library/functions.html#repr)  的不同之处在于，`ascii()` 在获取 `__repr__()` 的返回值之后，会使用转义序列 (`\x`, `\u` , `\U`) 来表示其中的非 ASCII 码字符。`ascii()` 返回的字符串类似于 Python 2 中的 `repr()` 函数返回的字符串。 

```python
class Cls:
    def __repr__(self):
        # ascii与repr都会使用__repr__，
        # 但ascii会转义其中的非ASCII字符
        return "调用__repr__"

    def __str__(self):
        # ascii不使用__str__
        return "调用__str__"


a_cls = Cls()
print("repr 的返回值:{0}".format(repr(a_cls)))
print("ascii的返回值:{0}".format(ascii(a_cls)))
```

输出

```
repr 的返回值:调用__repr__
ascii的返回值:\u8c03\u7528__repr__
```

#### `ascii()` 如何表示非 ASCII 码字符？

补充一点有关 Unicode 的知识：每个 Unicode 字符都有一个指定的代码点(code point)，在 Unicode 字符集中一般表示为 `U+XXXX` ，其中 XXXX 是由 4 个或更多个16进制数字表示的序列。在 Python 3 中：`\u` 转义序列用于插入码点范围在 `U+0000` ~ `U+FFFF` 之间的 Unicode 字符。`\U` 转义序列用于插入码点范围在 `U+10000` 及以上的字符。

`ascii()` 会将非 ASCII 码字符划分为三段，分别使用不同的转义序列表示：

- `\xhh` 转义序列用于表示码点范围在`U+007F` ~ `U+00FF` 之间的 Unicode 字符。
- `\uxxxx` 转义序列用于表示码点范围在`U+0100` ~ `U+FFFF` 之间的 Unicode 字符。
- `\Uxxxxxxxx` 转义序列用于表示码点范围在 `U+10000` 及以上的字符。

 `U+0000` ~ `U+007E` 之间的 Unicode 字符对应于 ASCII 码，这部分内容不会被 `ascii()` 转义。

示例代码：

```python
print(ascii('µ')) # U+007F ~ U+00FF
print(ascii('鲸')) # U+0100 ~ U+FFFF 
print(ascii("😊")) # U+10000
```

输出:

```
'\xb5'
'\u9cb8'
'\U0001f60a'
```

最后在对比一下 `repr()`：

```python
print(repr('µ'))
print(repr('鲸'))
print(repr("😊"))
```

输出：

```
'µ'
'鲸'
'😊'
```

## I

### iter

`iter(object[, sentinel])`

该函数会返回一个 [iterator](https://docs.python.org/3.7/glossary.html#term-iterator) 对象。第一个实参(argument)会因为第二个实参的传入，而获得截然不同的解释。

在没有传入第二个实参的情况下，object 必须是一个支持迭代协议( [`__iter__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__iter__) 方法)的集合(collection)对象；或者 object 必须支持序列协议 (the [`__getitem__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__getitem__) method with integer arguments starting at `0`)。如果这两种协议均不被 object 支持，`iter()` 便会抛出 [`TypeError`](https://docs.python.org/3.7/library/exceptions.html#TypeError)。Tips：这里提到的集合对象只是一种抽象概念，并非特指 [`Callable`](https://docs.python.org/3.7/library/collections.abc.html#collections.abc.Callable) 类型，仅实现 [`__iter__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__iter__) 方法即可支持 `iter` 函数；同样的，仅实现 [`__getitem__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__getitem__) 方法也能支持 `iter` 函数。

```python
class ObjcIter:
    def __iter__(self):
        cont = 0
        while cont < 3:
            cont += 1
            yield cont


a_iter1 = iter(ObjcIter())
print(list(a_iter1))


class ObjcGetitem:
    def __getitem__(self, item):
        cont = 0

        while cont <= item:
            cont += 1
            if cont >= 5:
                raise StopIteration()
        return cont


a_iter2 = iter(ObjcGetitem())
print(list(a_iter2))
```

输出：

```
[1, 2, 3]
[1, 2, 3, 4]
```



如果传入了第二参数 sentinel，此时 object 必须是一个可调用(callable)对象。对于在这种情况下创建的迭代器，每当调用其 [`__next__()`](https://docs.python.org/3.7/library/stdtypes.html#iterator.__next__) 方法时，便会以无参数形式调用 object。如果 object 的返回值等于 sentinel，便会抛出 [`StopIteration`](https://docs.python.org/3.7/library/exceptions.html#StopIteration) ；如果返回值不等于 sentinel，则直接返回该值。比如下面这个示例：

```python
class AutoIncrement(object):
    """每次调用该类的实例，计数器便会自动加1"""

    def __init__(self):
        self._count = 0

    def __call__(self):
        self._count += 1
        return self._count


a_iter = AutoIncrement()
for i in iter(a_iter, 3):
    # 当a_iter()返回5时，便会抛出StopIteration
    # 停止迭代
    print(i, end=',')
```

输出：

```
1,2,
```

还可参考：[Iterator Types](https://docs.python.org/3.7/library/stdtypes.html#typeiter).

[`iter()`](https://docs.python.org/3.7/library/functions.html#iter) 的第二种使用形式的一个使用场景是：可以一次性读取文件中的多个行，并在某个特定行停止读取。下面这个示例会持续读取一个文件，直到 [`readline()`](https://docs.python.org/3.7/library/io.html#io.TextIOBase.readline) 方法返回空字符串为止。

```python
with open('mydata.txt') as fp:
    for line in iter(fp.readline, ''):
        process_line(line)
```

## n

### next

`next(iterator[, default])`

通过调用 iterator 的 [`__next__()`](https://docs.python.org/3.7/library/stdtypes.html#iterator.__next__) 方法来检索迭代器中的下一项。在给定 default 的情况下，当迭代器耗尽时便会返回 default；如果没有给定 default，则会抛出 [`StopIteration`](https://docs.python.org/3.7/library/exceptions.html#StopIteration)。









