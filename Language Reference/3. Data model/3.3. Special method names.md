# 3.3. Special method names

## [3.3.1. Basic customization](https://docs.python.org/3.7/reference/datamodel.html#basic-customization)

### \_\_new\_\_

object.\_\_new\_\_(*cls*[, ...])

在新式类中， `__new__` 用于控制新实例的创建过程，`__init__` 用于控制新实例的初始化过程。由于 object 类中已包含 `__new__`，所以在每个新式类均拥有该方法。如无特殊说明，本节内容均针对新式类中的 `__new__` 方法进行讨论。

新式类中的 `__new__` 是一个特殊的**静态方法**，无需在声明过程中显式使用 `@staticmethod` 装饰器。`__new__` 方法的**实参**由"类引用"和"构造器实参列表"共同组成。

当我们调用某个类的构造器(*constructor*)时，便会先调用该类的 `__new__` 方法。根据 `__new__` 返回值的不同，可分为以下两种情况：

- 如果返回值是 *cls* 的实例，之后便会调用该实例的 `__init__` 方法。`__init__` 方法的实参由"实例引用"和"构造器实参列表"共同组成，也就是说 `__new__` 和 `__init__` 除了第一个参数不同之外，**其余参数均相同**。

  为 *cls* 类创建新实例的典型方法有以下两种：

  - 通过 `super()` 调用其父类的  `__new__` 方法，如 `super().__new__(cls[, ...])`。
  - 直接调用 object 类的 `__new__` 方法，如 `object.__new__(cls)`

  另外，在 `__new__` 返回实例前，还可根据需要对已创建的实例进行修改。

  ```python
  class A(object):
      def __new__(cls, a_str): 
          # 特殊静态方法，无需显式使用@staticmethod装饰器
          print("into __new__")
          # object类的__new__方法只需要一个参数，所以只需传递一个参数即可
          instance = super().__new__(cls) # 创建实例
          instance.num = 61  # 如果需要的话，可对实例进行修改
          return instance # 返回该实例
  
      def __init__(self, a_str):
          print("into __init__")
          print(self.num)
  A("hello") # 执行构造器表达式
  ```

  输出：

  ```
  into __new__
  into __init__
  61
  ```

- 如果返回值并非 *cls* 的实例，那么将不会调用该实例的 `__init__` 方法

  ```python
  class Sample(object):
      def __init__(self): # 不会被调用
          print("Sample's __init__")
  
      def __str__(self):
          return "SAMPLE"
  
  class A(object):
      def __new__(cls):
          """并不会调用Sample或A中的__init__方法"""
          return super().__new__(Sample)  # 返回一个Sample实例
      	# 也可返回字符串、整数、None、函数对象等，但都不会调用__init__方法
  
      def __init__(self): # 不会被调用
          print("A's __init__")
  
  print(A())
  ```

  输出：

  ```
  SAMPLE
  ```

#### a. Tips

- 在旧式类中并没有 `__new__` 方法，只有 `__init__` 方法，如果我们定义如下旧类：

  ```python
  # -*- coding: utf-8 -*-
  # python2
  class oldStyleClass:
      def __new__(cls):
          # 旧式类在构造实例的过程中，不会调用__new__方法
          print("into __new__")
  
      def __init__(self):
          print("into __init__")
  
  
  oldStyleClass()
  ```

  输出结果将会是：

  ```
  into __init__
  ```

  可见，旧式类在实例化的过程并不会调用 `__new__` 方法。

- 只要返回值是 *cls* 的实例，便会调用该实例的 `__init__` 方法，无论是否已经调用过：

  ```python
  class AbstractClass(object):
      def __new__(cls, a, b):
          instance = super(AbstractClass, cls).__new__(cls)
          instance.__init__(a, b)
          return instance  # 只要返回实例便会调用init，所以这里会调用两次
  
      def __init__(self, a, b):
          print("into __init__")
  
  
  AbstractClass(1, 2)
  ```

  输出：

  ```
  into __init__
  into __init__
  ```

#### b. 应用场景

- 当我们继承某个**不可变类型**(如 int、str、tuple)时，可通过 `__new__` 方法自定义子类的实例化过程。例如，当我们需要为 int 类创建一个始终存储正数的子类时，便需要覆写 `__new__` 方法：

  ```python
  class PositiveInteger(int):
      def __new__(cls, value):
          return super(PositiveInteger, cls).__new__(cls, abs(value))
  
  i = PositiveInteger(-6)
  print(i) # 输出 6
  ```

  如果我们试图通过重载 `__init__` 来实现上述功能，会发现在 Python 3 中会抛出异常。

  ```python
  class PositiveInteger(int):
      def __init__(self, value):
          super(PositiveInteger, self).__init__(abs(value)) 
          # Python3会抛出TypeError
          # Python2可正常运行，但最终的输出结果仍是 -6
  
  i = PositiveInteger(-6)
  print(i) # Python2输出-6
  ```

- 可以用 `__new__` 来实现设计模式中的**单例模式**(singleton)

  ```python
  class Singleton(object):
      def __new__(cls):
          # 每次实例化的时，均会返回同一个实例对象
          if not hasattr(cls, 'instance'):
              cls.instance = super().__new__(cls)
          return cls.instance
  
      def __init__(self):
          print("into __init__")
  
  # 虽然每次实例化时，均会返回同一个实例对象，
  # 但是，任然会调用两次__init__方法
  inst_1 = Singleton()
  inst_2 = Singleton()
  
  inst_1.attr = 'value'
  print(inst_1.attr, inst_2.attr)
  print(inst_1 is inst_2)
  ```

  输出

  ```
  into __init__
  into __init__
  value value
  True
  ```

- 可利用 `__new__` 来**限制实例的总数**

  ```python
  class LimitedInstances(object):
      _instances = []  # 存放已有实例引用的列表
      limit = 5 
  
      def __new__(cls, *args, **kwargs):
          if not len(cls._instances) <= cls.limit:
              raise RuntimeError, "Count not create instance. Limit %s reached" % cls.limit    
          instance = object.__name__(cls, *args, **kwargs)
          cls._instances.append(instance)
          return instance
      
      def __del__(self):
          # Remove instance from _instances 
          self._instance.remove(self)
  ```

- 覆写自定义元类的 `__new__`，从而影响类对象的创建过程。

  ```python
  # -*- coding: utf-8 -*-
  class Meta(type):  # 自定义元类需继承自type
      def __new__(cls, name, bases, dct):  # __new__方法的参数需和type一致
          # 需通过super调用父类的__new__方法来构造新的类对象
          x = super().__new__(cls, name, bases, dct) 
          x.attr_of_new = 100 # 在元类中为类对象添加自定义属性
          return x # 最后需返回类对象
      def __init__(self, name, bases, dct):
          self.attr_of_init = 200
          super().__init__(name, bases, dict)
  ```

  输出：

  ```python
  >>> class Foo(metaclass=Meta): # 需使用metaclass关键字指定目标元类
  ...     pass
  ...
  >>> Foo.attr_of_new # Meta元类为Foo添加了属性
  100
  >>> Foo.attr_of_init 
  200
  ```


#### c. 参考

- [Python: \_\_new\_\_ magic method explained](https://howto.lintel.in/python-__new__-magic-method-explained/)

### \_\_init\_\_

object.\_\_init\_\_(*self*[, ...])

在新式类中， `__new__` 用于控制新实例的创建过程，`__init__` 用于控制新实例的初始化过程。如果 `__new__` 的返回值是当前类的实例，之后便会调用该实例的 `__init__` 方法，来对实例进行初始化。在完成初始化后才会将实例返回给调用者。

`__init__` 的实参由"实例引用"和"构造器实参列表"共同组成，也就是说 `__new__` 和 `__init__` 除了第一个参数不同之外，**其余参数均相同**。`__init__` 只能返回 `None`，否则会抛出 [`TypeError`](https://docs.python.org/3.7/library/exceptions.html#TypeError)。

假设基类中定义了 `__init__` 方法，如果派生类中覆写了 `__init__` 方法，则在派生类的 `__init__` 方法中必须显式调用父类中的 `__init__` 方法，以确保能够正确初始化实例的基类部分，如：`super().__init__([args...])`。

#### a. Tips

- 在旧式类中并没有 `__new__` 方法，只有 `__init__` 方法，如果我们定义如下旧类：

  ```python
  # -*- coding: utf-8 -*-
  # python2
  class oldStyleClass:
      def __new__(cls):
          # 旧式类在构造实例的过程中，不会调用__new__方法
          print("into __new__")
  
      def __init__(self):
          print("into __init__")
  
  
  oldStyleClass()
  ```

  输出结果将会是：

  ```
  into __init__
  ```

  可见，旧式类在实例化的过程并不会调用 `__new__` 方法。

- 只要返回值是 *cls* 的实例，便会调用该实例的 `__init__` 方法，无论该方法是否已经调用过：

  ```python
  class AbstractClass(object):
      def __new__(cls, a, b):
          instance = super(AbstractClass, cls).__new__(cls)
          instance.__init__(a, b)
          return instance  # 只要返回实例便会调用init，所以这里会调用两次
  
      def __init__(self, a, b):
          print("into __init__")
  
  
  AbstractClass(1, 2)
  ```

  输出：

  ```
  into __init__
  into __init__
  ```




## [3.3.6. Emulating callable objects](https://docs.python.org/3.7/reference/datamodel.html#emulating-callable-objects)

模拟可调用对象[版本：3.7]

### \_\_call\_\_

object.\_\_call\_\_(*self*[, *args*...])

当我们像调用函数一样调用类实例时，便会调用该方法。如果类中定义了该方法，那么在调用类实例 x 时：`x(arg1,arg2, ...)` 与  `x.__call__(arg1, arg2, ...)` 等效果。

由于类本身也是可调用对象(当我们调用某个类时，便会返回该类的实例)，所以作为类对象模板的元类(如 type)也需要实现 `__call__` 方法。

## [3.3.7. Emulating container types](https://docs.python.org/3.7/reference/datamodel.html#emulating-container-types)

版本：3.7

通过定义本节中讲述的方法，便可实现容器(container)对象。
容器通常是指序列(如，列表或元组)或映射(如，字典)，但也可以表示其它容器类型。
第一组方法用于模拟序列或映射；对于序列来说，方法签名中参数 key 的范围是 `0 <= key < N` (N 表示序列的长度)，key 还可以是切片对象。

建议在映射中提供如下方法，并让其行为类似于"标准字典对象"中的同名方法：`keys()`, `values()`, `items()`, `get()`, `clear()`, `setdefault()`, `pop()`, `popitem()`, `copy()`, 和 `update()` 。 [`collections.abc`](https://docs.python.org/3.7/library/collections.abc.html#module-collections.abc) 模块提供了  [`MutableMapping`](https://docs.python.org/3.7/library/collections.abc.html#collections.abc.MutableMapping) 抽象基类，以便在创建新类时可从基类继承如下方法： [`__getitem__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__getitem__), [`__setitem__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__setitem__), [`__delitem__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__delitem__), and `keys()`。

可变序列应提供如下方法，并让其行为类似于"标准列表对象"中的同名方法：`append()`, `count()`, `index()`, `extend()`, `insert()`, `pop()`, `remove()`,`reverse()` 和 `sort()`。
序列类型可通过定义如下方法，来实现加法(用于连接两个序列)和乘法(将序列本身进行重复)： [`__add__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__add__), [`__radd__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__radd__), [`__iadd__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__iadd__), [`__mul__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__mul__), [`__rmul__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__rmul__) and[`__imul__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__imul__) —— 除此之外不要定义其它数值运算符。

建议映射和序列都实现 [`__contains__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__contains__) 方法，以便使用 `in` 进行成员测试；对于映射，`in` 将 key 作为测试对象；对于序列，`in` 将值作为测试对象。还建议在映射和序列中均实现 [`__iter__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__iter__) 方法，以便对容器进行迭代；对于映射， [`__iter__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__iter__) 应类似于 `keys()`；对于序列，迭代操作的对象是值。

### \_\_len\_\_

`object.__len__(self)`

该函数应返回对象的长度(长度值是 `>=0` 的整数)，内置函数 [`len()`](https://docs.python.org/3.7/library/functions.html#len) 会调用此函数来获取长度值。另外，对于未定义 [`__bool__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__bool__) 方法的对象，在 Boolean 上下文中会将 [`__len__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__len__) 返回 0 的情形视为 `False`。

```python
class Cls(object):
    def __init__(self, lst):
        self._lst = lst

    def __len__(self):
        return len(self._lst)
```

**CPython 实现细节：**在 CPython 中，长度(length)的最大值不能超过 [`sys.maxsize`](https://docs.python.org/3.7/library/sys.html#sys.maxsize)。如果长度大于 `sys.maxsize`，某些功能(如 `len()`)便可能会引发 [`OverflowError`](https://docs.python.org/3.7/library/exceptions.html#OverflowError)。为了避免进行真值测试时抛出 `OverflowError`，对象必须定义 [`__bool__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__bool__) 方法。

### \_\_iter\_\_

`object.__iter__(self)`

当需要容器提供迭代器(iterator)时，便会调用此方法。该方法会返回一个新的迭代器对象，通过该迭代器对象可遍历容器中的所有对象。如果容器本身就是迭代器，在调用该方法后，便会返回容器自身。对于映射对象，应使用键进行迭代。

迭代器对象同样需要实现该方法，并通过该方法返回其自身。有关迭代器的更多信息，请看 [Iterator Types](https://docs.python.org/3.7/library/stdtypes.html#typeiter) 。

```python
class Fib(object):
    def __reset(self):
        self.a = 1
        self.b = 1

    def __init__(self):
        self.__reset()


    def __iter__(self):
        """测试该方法前，请删除__contains__"""
        print("调用 __iter__()")
        self.__reset()
        return self

    def __next__(self):
        self.a, self.b = self.b, self.a + self.b  # 计算下一个值
        if self.a > 100000:  # 退出循环的条件
            print("停止迭代")
            raise StopIteration()
        return self.a  # 返回下一个值
```



### \_\_contains\_\_

成员测试操作符 ([`in`](https://docs.python.org/3.7/reference/expressions.html#in) 和 [`not in`](https://docs.python.org/3.7/reference/expressions.html#not-in)) 常见的实现方式是：通过对序列进行迭代，以确定是否存在指定项。但是，容器对象可以使用下面这个方法来提供更高效的实现，该方法也可用于非序列对象。

`object.__contains__(self, item)`

该方法用于实现成员测试。如果 self 中包含 item，便会返回 `True` ；否则返回 `False`。对于映射对象，应将键作为测试对象，而非值或键值对。如果对象中未定义 `__contains__`，成员测试便会尝试通过 [`__iter__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__iter__) 来迭代对象，以确定目标值是否存在。如果这两个方法都未定义，则会通过旧式序列迭代协议 [`__getitem__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__getitem__), 来确定目标是否存在，[详见此处](https://docs.python.org/3.7/reference/expressions.html#membership-test-details)。





