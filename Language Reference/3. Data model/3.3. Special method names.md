# 3.3. Special method names

## [3.3.1. Basic customization](https://docs.python.org/3.7/reference/datamodel.html#basic-customization)

### \_\_new\_\_

object.\_\_new\_\_(*cls*[, ...])

假设存在一个名为 A 的类，当我们执行类 A 的构造器表达式(*constructor expression*)时，首先会调用类 A 的 `__new__` 方法。`__new__` 是一个特殊的静态方法，无需在声明过程中显式使用 `@staticmethod` 装饰器。`__new__` 的实参由"类 A "和"构造器的实参列表"共同组成。根据 `__new__` 返回值的不同，可分为以下两种情况：

- 如果返回值是 *cls* 的实例，之后便会调用该实例的 `__init__` 方法。`__init__` 方法的实参由"实例"和"构造器的实参列表"共同组成，也就是说 `__new__` 和 `__init__` 除了第一个参数不同之外，其余参数均相同。为 *cls* 类创建实例的典型方法是：调用其超类的  `__new__` 方法，如 `super().__new__(cls[, ...])`。在最终返回实例前，还可根据需要对实例做出修改。

  ```python
  class A:
      def __new__(cls, a_str): 
          # 特殊静态方法，无需显式使用@staticmethod装饰器
          print("into __new__")
          # object类的__new__方法只需要一个参数，所以只需传递一个参数即可
          instance = super().__new__(cls) 
          instance.num = 61  # 如果需要的话，可对实例进行修改
          return instance # 返回该实例
  
      def __init__(self, a_str):
          print("into __init__")
          print(self.num)
  
  
  A("hello") # 执行构造器表达式
  ```

  输出：

  ```
  into __new__
  into __init__
  61
  ```

- 如果返回值并非 *cls* 的实例，那么将不会调用该实例的 `__init__` 方法

  ```python
  class Sample(object):
      def __init__(self):
          print("Sample's __init__")
  
      def __str__(self):
          return "SAMPLE"
  
  class A(object):
      def __new__(cls):
          """并不会调用Sample或A中的__init__方法"""
          return super().__new__(Sample)  # 返回一个Sample实例
      	# 也可返回字符串、整数、函数对象等，但都不会调用__init__方法
  
      def __init__(self):
          print("A's __init__")
  
  print(A())
  ```

  输出：

  ```
  SAMPLE
  ```

#### 应用场景

- 当我们继承某个不可变类型(如 int、str、tuple)时，可通过 `__new__` 方法自定义子类的实例化过程。例如，当我们需要为 int 类创建一个始终存储正数的子类时，便需要覆写 `__new__` 方法：

  ```python
  class PositiveInteger(int):
      def __new__(cls, value):
          return super(PositiveInteger, cls).__new__(cls, abs(value))
  
  i = PositiveInteger(-6)
  print(i) # 输出 6
  ```

  如果我们试图通过重载 `__init__` 方法来实现上述功能，便会发现在 Python 3 中会抛出异常

  ```python
  class PositiveInteger(int):
      def __init__(self, value):
          super().__init__() # 此处会抛出TypeError: object.__init__() takes no parameters
  
  i = PositiveInteger(-6)
  print(i)
  ```

- 可以用 `__new__` 来实现设计模式中的单例模式(singleton)

  ```python
  class Singleton(object):
      def __new__(cls):
          # 每次实例化的时，均会返回同一个实例对象
          if not hasattr(cls, 'instance'):
              cls.instance = super().__new__(cls)
          return cls.instance
  
      def __init__(self):
          print("into __init__")
  
  # 虽然每次实例化时，均会返回同一个实例对象，
  # 但是，任然会调用两次__init__方法
  inst_1 = Singleton()
  inst_2 = Singleton()
  
  inst_1.attr = 'value'
  print(inst_1.attr, inst_2.attr)
  print(inst_1 is inst_2)
  ```

  输出

  ```
  into __init__
  into __init__
  value value
  True
  ```

- 利用 `__new__` 维护共享属性：

  ```python
  class Cls(object):
      _data = list()
  
      def __new__(cls, *args, **kwargs):
          instance = super().__new__(cls)
          instance._list = cls._data
          return instance
  
  
  # 创建两个不同id的实例
  one = Cls()
  two = Cls()
  
  # _list是这两个实例的公有属性
  one._list.append("whale")
  print(one._list)
  print(two._list)
  ```

  输出：

  ```python
  ['whale']
  ['whale']
  ```

- `__new__` 也通常在自定义元类中被重写，以创建自定义类。

  ```
  
  
  
  
  
  
  ```


#### tips

- 只要返回值是 *cls* 的实例，便会调用该实例的 `__init__` 方法，无论是否已经调用过：

  ```python
  class AbstractClass(object):
      def __new__(cls, a, b):
          instance = super(AbstractClass, cls).__new__(cls)
          instance.__init__(a, b)
          return instance  # 只要返回实例便会调用init，所以这里会调用两次
  
      def __init__(self, a, b):
          print("into __init__")
  
  
  AbstractClass(1, 2)
  ```

  输出：

  ```
  into __init__
  into __init__
  ```

- `__new__` 属于object类，故在新式类中，此方法存在于每一个类

### \_\_init\_\_

object.\_\_init\_\_(*self*[, ...])

该方法会在 `__new__` 创建并返回实例后被调用，经 `__init__` 处理后的实例才会被返回给调用者。传递给类构造表达式的参数会被传递给 `__init__` 方法。假设父类拥有 `__init__` 方法，如果派生类中定义了 `__init__` 方法，则必须显式调用父类类中的该方法，以确保正确初始化实例中的基本部分，例如：`super().__init__([args...])`

因为 `__new__` 和 `__init__` 在构造对象时一起工作 —— `__new__` 创建实例，`__init__` 自定义实例。`__init__` 不能返回 `None` 值，否则会在运行时(runtime)中抛出 [`TypeError`](https://docs.python.org/3.7/library/exceptions.html#TypeError) 

## [3.3.6. Emulating callable objects](https://docs.python.org/3.7/reference/datamodel.html#emulating-callable-objects)

模拟可调用对象[版本：3.7]

### \_\_call\_\_

object.\_\_call\_\_(*self*[, *args*...])

当我们像调用函数一样调用类实例时，便会调用该方法。如果类中定义了该方法，那么在调用类实例 x 时：`x(arg1,arg2, ...)` 与  `x.__call__(arg1, arg2, ...)` 等效果。

由于类本身也是可调用对象(当我们调用某个类时，便会返回该类的实例)，所以作为类对象模板的元类(如 type)也需要实现 `__call__` 方法。

## [3.3.7. Emulating container types](https://docs.python.org/3.7/reference/datamodel.html#emulating-container-types)

版本：3.7

通过定义本节中讲述的方法，便可实现容器(container)对象。
容器通常是指序列(如，列表或元组)或映射(如，字典)，但也可以表示其它容器类型。
第一组方法用于模拟序列或映射；对于序列来说，方法签名中参数 key 的范围是 `0 <= key < N` (N 表示序列的长度)，key 还可以是切片对象。

建议在映射中提供如下方法，并让其行为类似于"标准字典对象"中的同名方法：`keys()`, `values()`, `items()`, `get()`, `clear()`, `setdefault()`, `pop()`, `popitem()`, `copy()`, 和 `update()` 。 [`collections.abc`](https://docs.python.org/3.7/library/collections.abc.html#module-collections.abc) 模块提供了  [`MutableMapping`](https://docs.python.org/3.7/library/collections.abc.html#collections.abc.MutableMapping) 抽象基类，以便在创建新类时可从基类继承如下方法： [`__getitem__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__getitem__), [`__setitem__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__setitem__), [`__delitem__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__delitem__), and `keys()`。

可变序列应提供如下方法，并让其行为类似于"标准列表对象"中的同名方法：`append()`, `count()`, `index()`, `extend()`, `insert()`, `pop()`, `remove()`,`reverse()` 和 `sort()`。
序列类型可通过定义如下方法，来实现加法(用于连接两个序列)和乘法(将序列本身进行重复)： [`__add__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__add__), [`__radd__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__radd__), [`__iadd__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__iadd__), [`__mul__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__mul__), [`__rmul__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__rmul__) and[`__imul__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__imul__) —— 除此之外不要定义其它数值运算符。

建议映射和序列都实现 [`__contains__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__contains__) 方法，以便使用 `in` 进行成员测试；对于映射，`in` 将 key 作为测试对象；对于序列，`in` 将值作为测试对象。还建议在映射和序列中均实现 [`__iter__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__iter__) 方法，以便对容器进行迭代；对于映射， [`__iter__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__iter__) 应类似于 `keys()`；对于序列，迭代操作的对象是值。

### \_\_len\_\_

`object.__len__(self)`

该函数应返回对象的长度(长度值是 `>=0` 的整数)，内置函数 [`len()`](https://docs.python.org/3.7/library/functions.html#len) 会调用此函数来获取长度值。另外，对于未定义 [`__bool__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__bool__) 方法的对象，在 Boolean 上下文中会将 [`__len__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__len__) 返回 0 的情形视为 `False`。

```python
class Cls(object):
    def __init__(self, lst):
        self._lst = lst

    def __len__(self):
        return len(self._lst)
```

**CPython 实现细节：**在 CPython 中，长度(length)的最大值不能超过 [`sys.maxsize`](https://docs.python.org/3.7/library/sys.html#sys.maxsize)。如果长度大于 `sys.maxsize`，某些功能(如 `len()`)便可能会引发 [`OverflowError`](https://docs.python.org/3.7/library/exceptions.html#OverflowError)。为了避免进行真值测试时抛出 `OverflowError`，对象必须定义 [`__bool__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__bool__) 方法。

### \_\_iter\_\_

`object.__iter__(self)`

当需要容器提供迭代器(iterator)时，便会调用此方法。该方法会返回一个新的迭代器对象，通过该迭代器对象可遍历容器中的所有对象。如果容器本身就是迭代器，在调用该方法后，便会返回容器自身。对于映射对象，应使用键进行迭代。

迭代器对象同样需要实现该方法，并通过该方法返回其自身。有关迭代器的更多信息，请看 [Iterator Types](https://docs.python.org/3.7/library/stdtypes.html#typeiter) 。

```python
class Fib(object):
    def __reset(self):
        self.a = 1
        self.b = 1

    def __init__(self):
        self.__reset()


    def __iter__(self):
        """测试该方法前，请删除__contains__"""
        print("调用 __iter__()")
        self.__reset()
        return self

    def __next__(self):
        self.a, self.b = self.b, self.a + self.b  # 计算下一个值
        if self.a > 100000:  # 退出循环的条件
            print("停止迭代")
            raise StopIteration()
        return self.a  # 返回下一个值
```



### \_\_contains\_\_

成员测试操作符 ([`in`](https://docs.python.org/3.7/reference/expressions.html#in) 和 [`not in`](https://docs.python.org/3.7/reference/expressions.html#not-in)) 常见的实现方式是：通过对序列进行迭代，以确定是否存在指定项。但是，容器对象可以使用下面这个方法来提供更高效的实现，该方法也可用于非序列对象。

`object.__contains__(self, item)`

该方法用于实现成员测试。如果 self 中包含 item，便会返回 `True` ；否则返回 `False`。对于映射对象，应将键作为测试对象，而非值或键值对。如果对象中未定义 `__contains__`，成员测试便会尝试通过 [`__iter__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__iter__) 来迭代对象，以确定目标值是否存在。如果这两个方法都未定义，则会通过旧式序列迭代协议 [`__getitem__()`](https://docs.python.org/3.7/reference/datamodel.html#object.__getitem__), 来确定目标是否存在，[详见此处](https://docs.python.org/3.7/reference/expressions.html#membership-test-details)。





