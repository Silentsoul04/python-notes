# 0x02 基础

[TOC]

## 1. 对象 Object 

一般意义上而言，Python 会把程序中使用到的任何东西都作为对象。
因此，我们会说"the *object*" 而不是 "the *something*"。

Python 是强对象导向的，就意义上而言数字、字符串和函数都是对象。



## 2. 字面常量 Literal

Literal Constants

>   An example of a literal constant is a number like `5`, `1.23`, or a string like `'This is a string'` or `"It's a string!"`.
>
>   It is called a literal because it is *literal* - you use its value literally. The number `2` always represents itself and nothing else - it is a *constant* because its value cannot be changed. Hence, all these are referred to as literal constants.

字面常量的例子：
一个数，如 `5` / `1.23`
字符串，如 `'This is a string'` / `"It's a string!"`。

它们被称作字面意义上的，因为它们具备 字面 的意义 - 你按照它们的字面意义使用它们的值。数字 2 总是代表它自己，而不会是别的什么东西 - 它是一个常量，因为不能改变它的值。因此，所有这些都被称为字面意义上的常量。

### 常量的表示

在 Python 中，通常用**全部大写的变量名**表示常量：

```
PI = 3.14159265359
```

但事实上 `PI` 仍然是一个变量，Python根本没有任何机制保证 `PI` 不会被改变，所以，用全部大写的变量名表示常量只是一个习惯上的用法，如果非要改变变量 `PI` 的值，也是完全可行的。



## 3. 变量

Python 支持多种数据类型。
在 Python 中可以把任何数据视为一个“对象”。
变量则被用于在程序中指向这些数据对象，对数据赋值便是把数据和变量关联起来。

Python 中变量是通过赋值语句引入的，变量只包含对数据对象的一个引用，数据对象本身才真正包含数据。等号 `=` 是赋值语句，使得变量指向相应数据对象，仅是引用了该对象。

变量名必须是大小写英文字母/ 数字/ `_` 的组合，不能以数字开头。

```
a = 1 #整数
t_007 = 'T007' #字符串
Answer = True #布尔值
```

### 类型可变

变量名可以引用任意类型的数据：

```
a = 123 # a是整数
print(a)
a = 'ABC' # 变量引用的值的类型发生了变化
print(a)
```

数据类型名称不会出现在 Python 程序中，但是所有值和对象都是有类型的。表达式中运算数的类型会在运算时检测，因此，类型错误一定会被检查；然而，在编写代码时，程序员不必关心数据类型。

### 动态语言

此类变量本身的类型不固定的语言称之为动态语言，与之对应的是静态语言。
静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如 Java 是静态语言，赋值语句如下（// 表示注释）：

```
int a = 123; // a是整数类型变量
a = "ABC"; // 错误：不能把字符串赋给整型变量
```

和静态语言相比，动态语言更灵活，就是这个原因。

### 变量与内存

References

将某个对象分配给一个变量时，该变量仅是引用了该对象。
变量并不能代表对象本身。
换句话说，变量名相当于指针，该指针用于指向内存中存放的被引用的对象的位置。
这也被称作，绑定 binding 名称到对象。

例如 `a = 'ABC'` 表示：

-   首先在内存创建字符串 `ABC` ，假设该字符串在内存中的地址是 0x06
-   然后在内存中创建变量 `a` ，并把该变量指向地址 0x06

如果把变量 `a` 赋值给变量 `b` ，实际上是把 `b` 也指向地址 0x06

```
a = 'ABC'
b = a
a = 'XYZ'
# 虽然a绑定的对象发生了变化
# 但是，b依旧指向'ABC'
```

再看一个列表的示例： `ds_reference.py`

```python
print('Simple Assignment')
shoplist = ['apple', 'mango', 'carrot', 'banana']
# mylist is just another name pointing to the same object!
mylist = shoplist

# I purchased the first item, so I remove it from the list
del shoplist[0]

print('shoplist is', shoplist)
print('mylist is', mylist)
# Notice that both shoplist and mylist both print
# the same list without the 'apple' confirming that
# they point to the same object

print('Copy by making a full slice')
# Make a copy by doing a full slice 切片
mylist = shoplist[:] #产生一个全新的list，指向不同的内存
# Remove first item
del mylist[0]

print('shoplist is', shoplist)
print('mylist is', mylist)
# Notice that now the two lists are different
```

Output:

```python
$ python ds_reference.py
Simple Assignment
shoplist is ['mango', 'carrot', 'banana']
mylist is ['mango', 'carrot', 'banana']
Copy by making a full slice
shoplist is ['mango', 'carrot', 'banana']
mylist is ['carrot', 'banana']
```

**How It Works**

注意，如果想要拷贝 list 或类似序列，亦或是更复杂的对象 ( 不是整数那样的简单对象 )。此时必须使用切片操作进行拷贝。
如果只是简单的将某个变量名赋值给另一个变量名，那么这两个变量会”引用“相同的内存地址。假设对其中一个做出了修改，那么另一个变量也会出现相应的变化。



## 4. 不可变对象

`str` 是典型的不可变对象，`list` 则是典型的可变对象。

操作可变对象时，对象本身会发生变化。比如：

```
>>> a = ['c', 'b', 'a'] # 假设此列表的内存地址是0x0061
>>> a.sort()
>>> a
['a', 'b', 'c'] # 调用.sort方法后的地址依然是0x0061
```

操作不可变对象时，对象本身不会发生变化，但是会创建一个新对象。

```
>>> a = 'abc' # 假设此str的内存地址是0x0061
>>> a.replace('a', 'A')
'Abc' # 此str的地址则不是0x0061
>>> a
'abc'
```



## 5. 运算符和表达式

Operators and Expressions

表达式可以被分解为**运算符**和**操作数**。

### 数学运算和赋值的快速方法

Shortcut for math operation and assignment

以下这种快捷方式具有通用性。
主要用于在某个变量上执行某种数学运算，并将计算结果返回该变量。

```
a = 2
a = a * 3
```

等效于：

```
a = 2
a *= 3
```

 `var = var operation expression` 变为 `var operation= expression`

### 运算符 Operators

赋值运算符的作用仅仅是在名称和值之间创建一种关联。

下面是可用运算符的简要概述：

-   `+` (plus) 加法

    -   Adds two objects
    -   `3 + 5` gives `8`. `'a' + 'b'` gives `'ab'`.

-   `-` (minus) 减法

    -   Gives the subtraction of one number from the other; if the first operand is absent it is assumed to be zero.
        从另一个数中减去一个数字；假如第一个操作数不存在，则假设其为 0 。
    -   `-5.2` gives a negative number and `50 - 24` gives `26`. `-5.2`得到负值，`50-24` 得 `26`。

-   `*` (multiply) 乘法

    -   Gives the multiplication of the two numbers or returns the string repeated that many times.

        给出两个数字的乘积，或返回重复给定次数的字符串。

    -   `2 * 3` gives `6`. `'la' * 3` gives `'lalala'`.

-   `**` (power) 幂

    -   Returns x to the power of y 返回 x 的 y 次幂。
    -   `3 ** 4` gives `81` (i.e. `3 * 3 * 3 * 3`)

-   `/` (divide) 除，永远返回浮点数

    -   Divide x by y
    -   `13 / 3` gives `4.333333333333333`

-   `//` (divide and floor) 取整运算

    -   Divide x by y and round the answer *down* to the nearest whole number

        x 除以 y 并将答案向下舍入到最接近的整数。

    -   `13 // 3` gives `4`

    -   `-13 // 3` gives `-5`

-   `%` (modulo) 模

    -   Returns the remainder of the division 返回除法的余数
    -   `13 % 3` gives `1`. `-25.5 % 2.25` gives `1.5`.

-   `<<` (left shift) 左移

    -   Shifts the bits of the number to the left by the number of bits specified. (Each number is represented in memory by bits or binary digits i.e. 0 and 1)

        把一个数的比特向左移一定数目（每个数在内存中都表示为比特或二进制数字，即0和1）

    -   `2 << 2` gives `8`. `2` is represented by `10` in bits.

    -   Left shifting by 2 bits gives `1000` which represents the decimal `8`.

        左移 2 bits 得 `1000`，在十进制中表示 `8`。

-   `>>` (right shift) 右移

    -   Shifts the bits of the number to the right by the number of bits specified.
    -   `11 >> 1` gives `5`.
    -   `11` is represented in bits by `1011` which when right shifted by 1 bit gives `101`which is the decimal `5`.

-   `&` (bit-wise AND) 按位与

    -   Bit-wise AND of the numbers
    -   `5 & 3` gives `1`.

-   `|` (bit-wise OR) 按位或

    -   Bitwise OR of the numbers
    -   `5 | 3` gives `7`

-   `^` (bit-wise XOR) 按位异或

    -   Bitwise XOR of the numbers
    -   `5 ^ 3` gives `6`

-   `~` (bit-wise invert) 按位取反

    -   The bit-wise inversion of x is -(x+1)
    -   `~5` gives `-6`. More details at [http://stackoverflow.com/a/11810203](http://stackoverflow.com/a/11810203)

-   `<` (less than) 小于，比较运算可进行连续比较

    -   Returns whether x is less than y. All comparison operators return `True` or `False`. Note the capitalization of these names.

        返回值代表 x 是否小于 y。所有计较操作符均返回`True` 或`False`。注意此处的名字的大小写。

    -   `5 < 3` gives `False` and `3 < 5` gives `True`.

    -   Comparisons can be chained arbitrarily: `3 < 5 < 7` gives `True`.

        比较操作可以被任意连接：`3<5<7`  返回 `True`。

-   `>` (greater than) 大于

    -   Returns whether x is greater than y

    -   `5 > 3` returns `True`. If both operands are numbers, they are first converted to a common type. Otherwise, it always returns `False`.

        `5 > 3` 返回 `True`。如果两个操作数都是数字，它们首先被转换为一个共同的类型。否则，它总是返回False。

-   `<=` (less than or equal to) 小于等于

    -   Returns whether x is less than or equal to y
    -   `x = 3; y = 6; x <= y` returns `True`

-   `>=` (greater than or equal to)

    -   Returns whether x is greater than or equal to y
    -   `x = 4; y = 3; x >= 3` returns `True`

-   `==` (equal to) 相等

    -   Compares if the objects are equal 比较两个对象是否相等
    -   `x = 2; y = 2; x == y` returns `True`
    -   `x = 'str'; y = 'stR'; x == y` returns `False`
    -   `x = 'str'; y = 'str'; x == y` returns `True`

-   `!=` (not equal to) 不相等

    -   Compares if the objects are not equal
    -   `x = 2; y = 3; x != y` returns `True`

-   `not` (boolean NOT) 布尔'非'

    -   If x is `True`, it returns `False`. If x is `False`, it returns `True`.
    -   `x = True; not x` returns `False`.

-   `and` (boolean AND) 布尔'与'

    -   `x and y` returns `False` if x is `False`, else it returns evaluation of y

        如果 x 是 `Flase` 则 `x and y` 返回 `Flase`，其余情况返回 y 的值。

    -   `x = False; y = True; x and y` returns `False` since x is False. In this case, Python will not evaluate y since it knows that the left hand side of the 'and' expression is `False` which implies暗示 that the whole expression will be `False` irrespective不考虑 of the other values. This is called short-circuit evaluation短路计算.

-   `or` (boolean OR)

    -   If x is `True`, it returns True, else it returns evaluation of y
    -   `x = True; y = False; x or y` returns `True`. Short-circuit evaluation applies here as well.

#### 运算符的优先等级

Evaluation Order

下表给出了 Python 中运算符的优先级，包含从最低的优先级(least binding)到最高的优先级 (most binding)。在给定表达式中，Python 会优先计算表格下部运算符和表达式的值，然后在计算表格上部的运算符。
在同一个框中的运算符具有相同的优先级。

Note that comparisons, membership tests, and identity tests, all have the same precedence and have a left-to-right chaining连接 feature as described in the [Comparisons](https://docs.python.org/3/reference/expressions.html#comparisons) section.

下面的表格，取自  [Python reference manual](http://docs.python.org/3/reference/expressions.html#operator-precedence) 。最好使用括号将运算符和操作数适当分组，以便明确指定优先级，以提高程序的可读性。

| Operator                                 | Description                              |
| ---------------------------------------- | ---------------------------------------- |
| [`lambda`](https://docs.python.org/3/reference/expressions.html#lambda) | Lambda expression                        |
| [`if`](https://docs.python.org/3/reference/compound_stmts.html#if) – [`else`](https://docs.python.org/3/reference/compound_stmts.html#else) | Conditional expression                   |
| [`or`](https://docs.python.org/3/reference/expressions.html#or) | Boolean OR                               |
| [`and`](https://docs.python.org/3/reference/expressions.html#and) | Boolean AND                              |
| [`not`](https://docs.python.org/3/reference/expressions.html#not) `x` | Boolean NOT                              |
| [`in`](https://docs.python.org/3/reference/expressions.html#in), [`not in`](https://docs.python.org/3/reference/expressions.html#not-in), [`is`](https://docs.python.org/3/reference/expressions.html#is), [`is not`](https://docs.python.org/3/reference/expressions.html#is-not), `<`, `<=`, `>`, `>=`, `!=`, `==` | Comparisons, including membership tests and identity tests |
| `|`                                      | Bitwise OR                               |
| `^`                                      | Bitwise XOR                              |
| `&`                                      | Bitwise AND                              |
| `<<`, `>>`                               | Shifts                                   |
| `+`, `-`                                 | Addition and subtraction                 |
| `*`, `@`, `/`, `//`, `%`                 | Multiplication, matrix multiplication division, remainder [[5\]](https://docs.python.org/3/reference/expressions.html#id21) |
| `+x`, `-x`, `~x`                         | Positive, negative, bitwise NOT          |
| `**`                                     | Exponentiation [[6\]](https://docs.python.org/3/reference/expressions.html#id22) |
| `await` `x`                              | Await expression                         |
| `x[index]`, `x[index:index]`, `x(arguments...)`, `x.attribute` | Subscription, slicing, call, attribute reference |
| `(expressions...)`, `[expressions...]`, `{key:value...}`, `{expressions...}` | Binding or tuple display, list display, dictionary display, set display |

### 改变运算规则

Changing the Order Of Evaluation

`()` 用于改变运算规则，同时也可使表达式更易读。

### 结合律 Associativity

Associativity

运算符通常从左向右进行结合，即具有相同优先级的运算符按照从左向右的顺序计算。例如，2 +3 + 4被计算成(2 + 3) + 4。

一些如赋值运算符那样的运算符是由右向左结合的，即a = b = c被处理为a = (b = c)。 `**` 和 `=` 是右结合运算符，其它运算符是做结合运算符。

### 变量 `_`

交互模式中，最近一个打印输出的表达式的值被赋给变量 `_`。

```
>>> tax = 12.5 / 100
>>> price = 100.50
>>> price * tax
12.5625
>>> price + _
113.0625
>>> round(_, 2)
113.06
```

用户应该将该变量视为只读。 不要显式地为其分配一个值 - 因为这样将创建一个具有相同名称的独立局部变量 `_`，该局部变量会屏蔽系统内置变量的魔术效果。

## 6. 流程控制

Control Flow

注意：python 中没有 `swicth...case` 语句，可以使用 `if..elif..else` 完成相同的工作。在一些情况下，使用字典会更方便。

### if...elif...else

The `if` statement

```
if <条件判断1>:
    <执行1>
elif <条件判断2>:
    <执行2>
elif <条件判断3>:
    <执行3>
else:
    <执行4>
```

`if` 语句从上往下执行<条件判断>。
如果在某个<条件判断>是 `True`，则执行该条件下的语句。
剩余的 `elif` / `else` 都会被忽略。

### while...else

`else` 语句对 `while` 可选。

示例：

```
number = 23
running = True

while running:
    guess = int(input('Enter an integer : '))

    if guess == number:
        print('Congratulations, you guessed it.')
        # this causes the while loop to stop
        running = False
    elif guess < number:
        print('No, it is a little higher than that.')
    else:
        print('No, it is a little lower than that.')
else:
    print('The while loop is over.')
    # Do anything else you want to do here

print('Done')
```

Output:

```
$ python while.py
Enter an integer : 50
No, it is a little lower than that.
Enter an integer : 22
No, it is a little higher than that.
Enter an integer : 23
Congratulations, you guessed it.
The while loop is over.
Done
```

```
while <条件判断1>:
    <执行1>
else:
    <执行2>
```

`else` 语句配合 `loop` 语句使用时，会在没有发生 `break` 的情况下执行。
如果在第一次执行 `while <条件判断1>` 时，<条件判断1>便为假。此时，`else` 语句同样会被执行。

**Note for C/C++ Programmers**
Remember that you can have an `else` clause for the `while` loop.



### for...else

The `for..in` statement is another looping statement which *iterates*遍历 over a sequence of objects i.e. go through each item in a sequence. 

```
names = ['Michael', 'Bob', 'Tracy']
for name in names:
    print(name)
```

Output:

```
Michael
Bob
Tracy
```

Example (save as `for.py`):

```
for i in range(1, 5):
    print(i)
else:
    print('The for loop is over')
```

Output:

```
$ python for.py
1
2
3
4
The for loop is over
```

By default, `range()` takes a step count of 1. If we supply a third number to range, then that becomes the step count. 
For example, range(1,5,2) gives [1,3]. Remember that the range extends up to the second number i.e. it does not include the second number.

Remember that **the `else` part is optional**. When included, it is always executed once after the `for` loop is over unless a break statement is encountered.

Remember that **the `for..in` loop works for any sequence**. Here, we have a list of numbers generated by the built-in `range` function, but in general we can use any kind of sequence of any kind of objects! 我们可以使用任何对象的任何序列。

**Note for C/C++/Java/C# Programmers**

The Python `for` loop is radically彻底 different from the C/C++ `for` loop. C# programmers will note that the `for` loop in Python is similar to the `foreach` loop in C#. Java programmers will note that the same is similar to `for (int i : IntArray)` in Java 1.5.

In C/C++, if you want to write `for (int i = 0; i < 5; i++)`, then in Python you write just `for i in range(0,5)`. As you can see, the `for` loop is simpler, more expressive表现力 and less error prone in Python.

#### 修改正在被迭代的序列

若想在循环体内修改正在被迭代的序列（例如复制序列中选定的项）。
建议先为该序列创建一个副本。
当迭代某个序列时并不会隐式地创建一个副本。
利用切片功能可以很方便的创建副本。

```
>>> for w in words[:]:  # Loop over a slice copy of the entire list.
...     if len(w) > 6:
...         words.insert(0, w)
...
>>> words
['defenestrate', 'cat', 'window', 'defenestrate']
```

#### 引用多个变量

上面的 `for` 循环里，同时引用了两个变量：

```
>>> for x, y in [(1, 1), (2, 4), (3, 9)]:
...     print(x, y)
...
1 1
2 4
3 9
```

### else

-   配合 `loop` 语句使用时，会在没有发生 `break` 的情况下执行。
-   配合 `try` 语句使用时，会在没有发生异常的情况下执行。
-   配合 `if` 语句使用时，会在前面所有条件判断都为假的情况下执行。

### break

The `break` statement is **used to *break* out of a loop statement** i.e. stop the execution of a looping statement, even if the loop condition has not become `False` or the sequence of items has not been completely iterated over.

An important note is that if you *break* out of a `for` or `while` loop, any corresponding相应 loop `else` block is **not** executed.

Example (save as `break.py`):

```
while True:
    s = input('Enter something : ')
    if s == 'quit':
        break
    print('Length of the string is', len(s))
print('Done')
```

Output:

```
$ python break.py
Enter something : Programming is fun
Length of the string is 18
Enter something : When the work is done
Length of the string is 21
Enter something : if you wanna make your work also fun:
Length of the string is 37
Enter something : use Python!
Length of the string is 11
Enter something : quit
Done
```

**How It Works**

>   In this program, we repeatedly反复 take the user's input and print the length of each input each time. We are providing提供 a special condition to stop the program by checking if the user input is `'quit'`. We stop the program by *breaking* out of the loop and reach到达repeatedly the end of the program.
>
>   The length of the input string can be found out using the built-in `len` function.
>
>   Remember that the `break` statement can be used with the `for` loop as well.

### continue

`continue`的作用是提前结束本轮循环，并直接开始下一轮循环。`break` 语句用于在循环过程中直接退出循环。
这两个语句通常都必须配合`if`语句使用。

如果我们想只打印奇数，可以用`continue`语句跳过某些循环：

```
n = 0
while n < 10:
    n = n + 1
    if n % 2 == 0: # 如果n是偶数，执行continue语句
        continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行
    print(n)
```

不要滥用 `break` 和 `continue` 语句。`break` 和`continue`会造成代码执行逻辑分叉过多，容易出错。

### 深入条件控制

More on Conditions

```
if <条件判断1>:
    <执行1>
elif <条件判断2>:
    <执行2>
else:
    <执行3>
```

```
while <条件判断1>:
    <执行1>
else:
    <执行2>
```

`<条件判断>` 在 `while` 和 `if` 中可以是任何运算符，不仅仅是指比较运算符。

 `in` 和`not in` ：用于成员测试。对于字典，应使用 key 进行成员测试。

 `is` 和 `is not` ：test for object identity: `x is y` is true if and only if *x* and *y* are the same object. Object identity is determined using the [`id()`](https://docs.python.org/3/library/functions.html#id) function. `x is not y` yields the inverse truth value. `==` 运算符比较数据结构内部的内容(如两个列表)在结构上的相等性

```
In [7]: c=[1,2]

In [8]: d=[1,2]

In [9]: c is d
Out[9]: False

In [12]: e=c

In [13]: e is c
Out[13]: True
```

比较操作可以被串联在一起使用。
例如： `a < b == c` 测试是否 `a` 小于 `b` 并且 `b` 等于 `c`。

比较操作可以同布尔运算符 `and` / `or` 一起使用，并且比较操作( 或任何其它的布尔表达式 )的结果可以使用 `not` 取反。布尔运算的优先级低于比较运算符；在布尔运算之中，`not` 拥有最高优先级，`or` 的优先级最低，因此 `A and not B or C` 等价于  `(A and (not B)) or C` 。通常括号被用于表达期望的运算顺序。

布尔运算 `and` / `or` 也称作短路运算符 *short-circuit* ：其参数从左向右进行求值，一旦可以确定结果就立刻停止求值。例，如果 `A` 和 `C` 为真而 `B` 为假， `A and B and C` 不会计算表达式 `C` 。

当普通值（非布尔值）被用于布尔运算时，短路计算的结果是最后一个参与计算的参数的值。

可以把比较运算或其它布尔表达式的返回值赋给一个变量，例如:

```
>>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'
>>> non_null = string1 or string2 or string3
>>> non_null
'Trondheim'
```

注意，Python 与 C 不同，在表达式内部不能出现出现赋值运算。C 程序员可能会抱怨这一点，但这避免了在 C 程序中遇到的一类共通的问题：当有意使用 `==` 时，却在表达式中错误输入了 `=` 。

### 循环技巧

Looping Techniques

#### items()

>   When looping through dictionaries, the key and corresponding value can be retrieved at the same time using the `items()` method.

当通过循环遍历字典时，使用 `items()` 方法可以同时获取 key 和对应的 value。

```
>>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}
>>> for k, v in knights.items():
...     print(k, v)
...
gallahad the pure
robin the brave
```

#### enumerate()

>   When looping through a sequence, the position index and corresponding value can be retrieved at the same time using the [`enumerate()`](../library/functions.html#enumerate) function.

当通过循环遍历序列时，索引位置和对应值可以使用  [`enumerate()`](../library/functions.html#enumerate) 函数同时获取。

```
>>> for i, v in enumerate(['tic', 'tac', 'toe']):
...     print(i, v)
...
0 tic
1 tac
2 toe
```

#### zip()

>   To loop over two or more sequences at the same time, the entries can be paired with the [`zip()`](../library/functions.html#zip) function.

同时循环两个或更多的序列，可以使用  [`zip()`](../library/functions.html#zip) 对条目进行配对。

```
>>> questions = ['name', 'quest', 'favorite color']
>>> answers = ['lancelot', 'the holy grail', 'blue']
>>> for q, a in zip(questions, answers):
...     print('What is your {0}?  It is {1}.'.format(q, a))
...
What is your name?  It is lancelot.
What is your quest?  It is the holy grail.
What is your favorite color?  It is blue.
```

#### reversed( )

>   To loop over a sequence in reverse, first specify the sequence in a forward direction and then call the [`reversed()`](../library/functions.html#reversed) function.

需要逆向循环序列的话，先正向定位序列，然后调用 [`reversed()`](../library/functions.html#reversed) 函数:

```
>>> for i in reversed(range(1, 10, 2)):
...     print(i)
...
9
7
5
3
1
```

#### sorted( )

>   To loop over a sequence in sorted order, use the [`sorted()`](../library/functions.html#sorted) function which returns a new sorted list while leaving the source unaltered.

以排序后的顺序循环序列，使用 [`sorted()`](../library/functions.html#sorted) 函数，该函数会返回一个新的经过排序的列表，同时保持源序列不变。

```
>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
>>> for f in sorted(set(basket)):
...     print(f)
...
apple
banana
orange
pear
```

#### 使用新列表替换原列表

>   It is sometimes tempting to change a list while you are looping over it; however, it is often simpler and safer to create a new list instead.

当列表时，有时你会尝试修改一个正在循环的列表；然而，创建一个新列表以替换原列表，是更简单和安全的方法。

```
>>> import math
>>> raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]
>>> filtered_data = []
>>> for value in raw_data:
...     if not math.isnan(value):
...         filtered_data.append(value)
...
>>> filtered_data
[56.2, 51.7, 55.3, 52.5, 47.8]
```

## 7. 文档字符串

DocStrings

如果模块、类或函数定义中的起始语句是字符串，那么该字符串会被视作文档字符串(DocStrings)。通过 `__doc__` 属性，可直接获取文档字符的内容。`help()` 函数和`pydoc` 命令均通过获取对象的 `__doc__` 属性，来提供帮助信息。

文档字符串格式要求如下：

- 文档字符串的缩进必须与定义中的所有其它语句保持一致。

- 虽然可以是 `"..."` 或 `"""..."""` 字符串，但通常是`"""..."""` 多行字符串。

- 如果将 `"""..."""` 用作文档字符串，那么第一行将被视作文档字符的标题，并以大写字母开头，同时以点号结尾；第二行是空白行；从第三行开始是详细记录程序的文档。

示例：

```python
def print_max(x, y):
    '''Prints the maximum of two numbers.

    The two values must be integers.
    '''
    # convert to integers, if possible
    x = int(x)
    y = int(y)

    if x > y:
        print(x, 'is maximum')
    else:
        print(y, 'is maximum')

print_max(3, 5)
print(print_max.__doc__)
```

输出：

```
5 is maximum
Prints the maximum of two numbers.

    The two values must be integers.    
```

可以参考《数据结构(Python语言描述)》的 5.1.4 先验条件、后验条件、异常和文档

## 补充

### range( )

range(stop) 
range(start, stop[, step]) 

`range` 实际上是一种不可变的序列类型，而非一个函数。
`stop` 不会被包含在生成的序列中。

```
range(5, 10)
   5 through 9

range(0, 10, 3)
   0, 3, 6, 9

range(-10, -100, -30)
  -10, -40, -70
```

如果要对某个序列的索引进行迭代的话，可使用  `range()` 和 `len()` ：

```
>>> a = ['Mary', 'had', 'a', 'little', 'lamb']
>>> for i in range(len(a)):
...     print(i, a[i])
...
0 Mary
1 had
2 a
3 little
4 lamb
```

但在大多数情况下，使用 `enumerate()` 函数更方便。

如果直接打印 `range()` ，会看起来很怪：

```
>>> print(range(10))
range(0, 10)
```

通过 `range()` 所返回的对象的行为像是列表，但实际上并不是列表。
对 `range()` 进行迭代时，它能返回所需序列中的连续项。但是 `range()` 没有生成一个真正的列表，并因此节约了空间。此类对象被称为*iterable* 。

而 `for` 语句和 `list()` 函数则可看作 *iterator* 。 *iterator* 可以从 *iterable* 对象中创建列表：

```
>>> list(range(5))
[0, 1, 2, 3, 4]
```

### enumerate( ) 

enumerate(iterable, start=0) 
Return an enumerate object. iterable must be a sequence, an iterator, or some other object which supports iteration. The __next__() method of the iterator returned by enumerate() returns a tuple containing a count (from start which defaults to 0) and the values obtained from iterating over iterable.

```
>>> seasons = ['Spring', 'Summer', 'Fall', 'Winter']
>>> list(enumerate(seasons))
[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
>>> list(enumerate(seasons, start=1))
[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]
```

Equivalent to:

    def enumerate(sequence, start=0):
        n = start
        for elem in sequence:
            yield n, elem
            n += 1






