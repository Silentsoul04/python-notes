# 0x06 高级特性

[TOC]

## 1. 列表推导式

List Comprehensions 即列表推导式(列表生成式)。
用于从现有列表中推导出一个新列表。

列表推导是 Py 支持函数式编程概念的( functional programming concepts) 的一个例子。

参考笔记 《容器_可迭代_迭代器_生成器.md》可获取其它生成器的相关信息

### 列表推导 vs for循环

`[<初始表达式> for...in... if...]`

-   列表推导式中创建的变量不会被存储到当前作用域的符号表中。
-   `for x in ...` 循环中的 `x` 会被存储到当前作用域的符号表中，循环完成后依旧存在。

Examlpe ：

```
>>> squares = []
>>> for x in range(10):
...     squares.append(x**2)
...
>>> squares
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

此处的 for 语句会创建(或覆盖)名为 `x` 的变量，该变量在循环完成后依然存在。
使用列表推导式或 `map()` 函数则没有这样的副作用。

```
squares = [x**2 for x in range(10)]
# 或
squares = list(map(lambda x: x**2, range(10)))
```

### 方括号[ ] vs 圆括号( )

列表推导由包含相应语句的 `[]` 方括号组成，会生成一个新的列表。
若是使用`()` 代替 `[]` ，则得到一个生成器 generator。

```
In [1]: squares = [x**2 for x in range(10)]

In [2]: squares

Out[2]: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

In [4]: squares_ = (x**2 for x in range(10))

In [5]: squares_

Out[5]: <generator object <genexpr> at 0x000001E2F2AB4E60>

In [6]: next(squares_)

Out[6]: 0

In [7]: next(squares_)

Out[7]: 1
```

### for 和 if

运用列表生成式，可以写出非常简洁的代码。
例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：

```
>>> import os # 导入os模块，模块的概念后面讲到
>>> [d for d in os.listdir('.')] # os.listdir可以列出文件和目录
['.emacs.d', '.ssh', '.Trash', 'Adlm', 'Applications', 'Desktop', 'Documents', 'Downloads', 'Library', 'Movies', 'Music', 'Pictures', 'Public', 'VirtualBox VMs', 'Workspace', 'XCode']
```

for 循环后面还可以加上 if 判断，例如：

```
# 筛选出偶数的平方
>>> [x * x for x in range(1, 11) if x % 2 == 0]
[4, 16, 36, 64, 100]
```

在第一个 `for` 子句后还可以跟有多个  `for` / `if` 子句（也可仅有第一个 `for` 子句）。

### 多个变量

`for` 循环可以同时使用两个以上的变量，比如：

```
>>> d = {'x': 'A', 'y': 'B', 'z': 'C' }
>>> [k + '=' + v for k, v in d.items()]
['y=B', 'x=A', 'z=C']
```

注意：这里虽然是两个变量，但依旧是列表。

### 多层循环

还可以使用两层以上的循环。

```
>>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
```

如果表达式 `(x,y)` 用于构成元组，则该表达式必须处于括号中。
该代码等效于：

```
>>> combs = []
>>> for x in [1,2,3]:
...     for y in [3,1,4]:
...         if x != y:
...             combs.append((x, y))
...
>>> combs
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
```

**注意**，在以上两段代码中， `for` 和 `if` 语句的顺序是相同的。

### 多种推导方式

列表推导可以包含复杂表达式，或是包含嵌套函数：

```
>>> from math import pi
>>> [str(round(pi, i)) for i in range(1, 6)]
['3.1', '3.14', '3.142', '3.1416', '3.14159']
```

在 list 中的每个元素上进行方法调用：

```
>>> L = ['Hello', 'World', 'IBM', 'Apple']
>>> [s.lower() for s in L]
['hello', 'world', 'ibm', 'apple']
```

示例

```
>>> vec = [-4, -2, 0, 2, 4]

>>> # create a new list with the values doubled
>>> [x*2 for x in vec]
[-8, -4, 0, 4, 8]

>>> # filter the list to exclude negative numbers
>>> [x for x in vec if x >= 0]
[0, 2, 4]

>>> # apply a function to all the elements
>>> [abs(x) for x in vec]
[4, 2, 0, 2, 4]

>>> # call a method on each element
>>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']
>>> [weapon.strip() for weapon in freshfruit]
['banana', 'loganberry', 'passion fruit']

>>> # create a list of 2-tuples like (number, square)
>>> [(x, x**2) for x in range(6)]
[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]

>>> # the tuple must be parenthesized, otherwise an error is raised
>>> [x, x**2 for x in range(6)]
  File "<stdin>", line 1, in ?
    [x, x**2 for x in range(6)]
               ^
SyntaxError: invalid syntax
>>> # flatten a list using a listcomp with two 'for' 
>>> vec = [[1,2,3], [4,5,6], [7,8,9]]
>>> [num for elem in vec for num in elem]
[1, 2, 3, 4, 5, 6, 7, 8, 9]
```

### 嵌套列表推导

Nested List Comprehensions

`[<初始表达式> for...in... if...]`

列表推导式中的初始表达式可以是任意表达式。
在初始表达式中，甚至可以包含另一个列表推导式。

以 `3*4` 的矩阵为例，将其变为 `4*3` 的矩阵。

```
>>> matrix = [
...     [1, 2, 3, 4],
...     [5, 6, 7, 8],
...     [9, 10, 11, 12],
... ]
```

下面的列表推导将调换行和列：

```
>>> [[row[i] for row in matrix] for i in range(4)]
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
```

嵌套的列表推导式 listcomp 是同样是对 `for` 后面的内容进行求值，所以上例等价于:

```
>>> transposed = []
>>> for i in range(4):
...     transposed.append([row[i] for row in matrix])
...
>>> transposed
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
```

反过来说，如下也是一样的:

```
>>> transposed = []
>>> for i in range(4):
...     # the following 3 lines implement the nested listcomp
...     transposed_row = []
...     for row in matrix:
...         transposed_row.append(row[i])
...     transposed.append(transposed_row)
...
>>> transposed
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
```

在实际中，使用内置函数组成复杂流程语句的方法更好。
对此种情况 `zip()` 函数将会做的更好:

```
>>> list(zip(*matrix))
[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]
```

## 5. 协程

协程 (Coroutine)，又称微线程，或纤程。
Python 通过 generater 实现对协程的支持。 `yield` 不仅可用于返回一个值，还可用于接受调用者发出的参数。

子程序，或称函数，在所有语言中都是层级调用。比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。
所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。
协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。
因此，可将子程序视作协程的一种特例。

示例：

```
def print_matches(match_text):
    print('looking for', match_text)
    while True:
        line = yield
        if match_text in line:
            print(line)


matcher = print_matches("python")
next(matcher)  # 向前执行到第一条 yield 语句
matcher.send("Hello World")  
matcher.send("Python is cool")  
matcher.close()  # 匹配器函数调用结束

#输出：
#looking for Python
#Python is cool
```

在调用 `send()` 向协程发送某个值前，协程会暂时中止。

基于 生产者-使用者模型(即一部分程序生成的数据会被程序的另一部分使用)编写并发程序时，协程十分有用。在这种模型中，协程代表了数据的一个使用者，生产者产生数据后，可直接通过 `yield` 跳转到使用者，待使用者执行完毕后，会再次切换回生产者继续产生数据。整个流程无锁，效率极高，并且仅在一个线程执行，由 produce 和 consumer 协作完成任务，而非线程的抢占式多任务。

```
def consumer():#消费者生成器
    r = ''
    while True:
        n = yield r
        if not n:
            return
        print('[CONSUMER] Consuming %s...' % n)
        r = '200 OK'

def produce(c):生存者
    c.send(None) #用next(c)也行，生成器需要调用next后才开始第一次执行	
    n = 0
    while n < 5:
        n = n + 1
        print('[PRODUCER] Producing %s...' % n)
        r = c.send(n)
        print('[PRODUCER] Consumer return: %s' % r)
    c.close()#关闭生成器

c = consumer()
produce(c)
```

执行结果：

```
[PRODUCER] Producing 1...
[CONSUMER] Consuming 1...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 2...
[CONSUMER] Consuming 2...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 3...
[CONSUMER] Consuming 3...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 4...
[CONSUMER] Consuming 4...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 5...
[CONSUMER] Consuming 5...
[PRODUCER] Consumer return: 200 OK
```





## 补充

### next( )

>   next(...)
>
>   next(iterator[, default])
>
>   Return the next item from the iterator. If default is given and the iterator is exhausted, it is returned instead of raising StopIteration.

通过 `next()` 函数获得 generator 的下一个返回值。
generator 保存的是算法，每次调用`next(g)`，就计算出`g`的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出`StopIteration`的错误。

```
>>> g = (x * x for x in range(5))
>>> g
<generator object <genexpr> at 0x1022ef630>
>>> next(g)
0
>>> next(g)
1
>>> next(g)
4
>>> next(g)
9
>>> next(g)
16
>>> next(g)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
```

### 



