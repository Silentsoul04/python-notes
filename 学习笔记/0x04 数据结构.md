# 0x04 数据结构

[TOC]



## 2. 映射类型 - dict



### 创建字典

在字典中每个 键值 对被称作一个条目(entry)

Dictionaries can be created by placing a comma-separated list of `key: value` pairs within braces, for example: `{'jack': 4098, 'sjoerd': 4127}` or `{4098: 'jack', 4127: 'sjoerd'}`, or by the [`dict`](https://docs.python.org/3/library/stdtypes.html#dict)constructor.

`dict()` BIF 是用于构建字典的工厂函数。

`class dict(**kwarg)`
`class dict(mapping, **kwarg)`
`class dict(iterable, **kwarg)`

Return a new dictionary initialized from an optional positional argument and a possibly empty set of keyword arguments.

If no positional argument is given, an empty dictionary is created. If a positional argument is given and it is a mapping object, a dictionary is created with the same key-value pairs as the mapping object. Otherwise, the positional argument must be an [iterable](https://docs.python.org/3/glossary.html#term-iterable) object. Each item in the iterable must itself be an iterable with exactly two objects. The first object of each item becomes a key in the new dictionary, and the second object the corresponding value. If a key occurs more than once, the last value for that key becomes the corresponding value in the new dictionary.

If keyword arguments are given, the keyword arguments and their values are added to the dictionary created from the positional argument. If a key being added is already present, the value from the keyword argument replaces the value from the positional argument.

To illustrate, the following examples all return a dictionary equal to `{"one": 1, "two": 2,"three": 3}`:

```
>>> a = dict(one=1, two=2, three=3)
>>> b = {'one': 1, 'two': 2, 'three': 3}
>>> c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))
>>> d = dict([('two', 2), ('one', 1), ('three', 3)])
>>> e = dict({'three': 3, 'one': 1, 'two': 2})
>>> a == b == c == d == e
True
```

roviding keyword arguments as in the first example only works for keys that are valid Python identifiers. Otherwise, any valid keys can be used.

字典推导式被用于从任意 key 和 value 表达式中创建字典：

```
>>> {x: x**2 for x in (2, 4, 6)}
{2: 4, 4: 16, 6: 36}
```

创建空字典：

```
a = {} 
b = dict()
```



### 操作字典的方法

以下是字典支持的操作，自定义映射类型也应该会支持这些操作。

-   `len(d)`

    Return the number of items in the dictionary *d*.


-   `d[key]`

    Return the item of *d* with key *key*. Raises a [`KeyError`](https://docs.python.org/3/library/exceptions.html#KeyError) if *key* is not in the map.If a subclass of dict defines a method [`__missing__()`](https://docs.python.org/3/reference/datamodel.html#object.__missing__) and *key* is not present, the `d[key]`operation calls that method with the key *key* as argument. The `d[key]` operation then returns or raises whatever is returned or raised by the `__missing__(key)` call. No other operations or methods invoke [`__missing__()`](https://docs.python.org/3/reference/datamodel.html#object.__missing__). If [`__missing__()`](https://docs.python.org/3/reference/datamodel.html#object.__missing__) is not defined, [`KeyError`](https://docs.python.org/3/library/exceptions.html#KeyError) is raised. [`__missing__()`](https://docs.python.org/3/reference/datamodel.html#object.__missing__) must be a method; it cannot be an instance variable:

    ```
    >>> class Counter(dict):
    ...     def __missing__(self, key):
    ...         return 0
    >>> c = Counter()
    >>> c['red']
    0
    >>> c['red'] += 1
    >>> c['red']
    1
    ```


    The example above shows part of the implementation of [`collections.Counter`](https://docs.python.org/3/library/collections.html#collections.Counter). A different `__missing__` method is used by [`collections.defaultdict`](https://docs.python.org/3/library/collections.html#collections.defaultdict).

-   `d[key] = value`

    Set `d[key]` to *value*.


-   `del d[key]`

    Remove `d[key]` from *d*. Raises a [`KeyError`](https://docs.python.org/3/library/exceptions.html#KeyError) if *key* is not in the map.


-   `key in d`

    Return `True` if *d* has a key *key*, else `False`.


-   `key not in d`

    Equivalent to `not key in d`.


-   `iter(d)`

    Return an iterator over the keys of the dictionary. This is a shortcut for `iter(d.keys())`.


-   `clear`()

    Remove all items from the dictionary.


-   `copy`()

    Return a shallow copy of the dictionary.


-   *classmethod *`fromkeys`(*seq*[, *value*])

    Create a new dictionary with keys from *seq* and values set to *value*.[`fromkeys()`](https://docs.python.org/3/library/stdtypes.html#dict.fromkeys) is a class method that returns a new dictionary. *value* defaults to `None`.


-   `get`(*key*[, *default*])

    Return the value for *key* if *key* is in the dictionary, else *default*. If *default* is not given, it defaults to `None`, so that this method never raises a [`KeyError`](https://docs.python.org/3/library/exceptions.html#KeyError).


-   `items`() 访问键值对

    Return a new view of the dictionary’s items (`(key, value)` pairs). See the [documentation of view objects](https://docs.python.org/3/library/stdtypes.html#dict-views).


-   `keys`()

    Return a new view of the dictionary’s keys. See the [documentation of view objects](https://docs.python.org/3/library/stdtypes.html#dict-views). 
    该视图支持成员测试、迭代等操作。但其内容并不是独立于原始字典的。

    `list(d.keys())`  返回 keys 组成的无序列表

    `sorted(d.keys())` 返回排序后的列表


-   `pop`(*key*[, *default*])

    If *key* is in the dictionary, remove it and return its value, else return *default*. If *default* is not given and *key* is not in the dictionary, a [`KeyError`](https://docs.python.org/3/library/exceptions.html#KeyError) is raised.


-   `popitem`()

    Remove and return an arbitrary `(key, value)` pair from the dictionary.[`popitem()`](https://docs.python.org/3/library/stdtypes.html#dict.popitem) is useful to destructively iterate over a dictionary, as often used in set algorithms. If the dictionary is empty, calling [`popitem()`](https://docs.python.org/3/library/stdtypes.html#dict.popitem) raises a [`KeyError`](https://docs.python.org/3/library/exceptions.html#KeyError).


-   `setdefault`(*key*[, *default*])

    If *key* is in the dictionary, return its value. If not, insert *key* with a value of *default* and return *default*. *default* defaults to `None`.


-   `update`([*other*])

    Update the dictionary with the key/value pairs from *other*, overwriting existing keys. Return `None`.[`update()`](https://docs.python.org/3/library/stdtypes.html#dict.update) accepts either another dictionary object or an iterable of key/value pairs (as tuples or other iterables of length two). If keyword arguments are specified, the dictionary is then updated with those key/value pairs: `d.update(red=1, blue=2)`.


-   `values`()

    Return a new view of the dictionary’s values. See the [documentation of view objects](https://docs.python.org/3/library/stdtypes.html#dict-views).






```
>>> tel = {'jack': 4098, 'sape': 4139}
>>> tel['guido'] = 4127
>>> tel
{'sape': 4139, 'guido': 4127, 'jack': 4098}
>>> tel['jack']
4098
>>> del tel['sape']
>>> tel['irv'] = 4127
>>> tel
{'guido': 4127, 'irv': 4127, 'jack': 4098}
>>> list(tel.keys())
['irv', 'guido', 'jack']
>>> sorted(tel.keys())
['guido', 'irv', 'jack']
>>> 'guido' in tel
True
>>> 'jack' not in tel
False
```



### dict vs list

和list比较，dict有以下几个特点：

1.  查找和插入的速度极快，不会随着key的增加而变慢；
2.  需要占用大量的内存，内存浪费多。

而list相反：

1.  查找和插入的时间随着元素的增加而增加；
2.  占用空间小，浪费内存很少。

所以，dict 是用空间来换取时间的一种方法。

dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict 非常重要，需要牢记的第一条就是dict 的 key 必须是**不可变对象**。

这是因为dict 根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过 key 计算位置的算法称为哈希算法（Hash）。

要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key：

```
>>> key = [1, 2, 3]
>>> d[key] = 'a list'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'
```



## 3. 集合类型 - set

Set Types — [`set`](https://docs.python.org/3/library/stdtypes.html#set), [`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset)[¶](https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset)

set 对象是不同的 hashable 对象的无序集合。
常见用途：1. 成员测试；2. 从序列中删除重复元素；3. 处理数学运算，如交集/并集/差集/对称差集。 
(For other containers see the built-in [`dict`](https://docs.python.org/3/library/stdtypes.html#dict), [`list`](https://docs.python.org/3/library/stdtypes.html#list), and [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple) classes, and the [`collections`](https://docs.python.org/3/library/collections.html#module-collections) module.)

类似于其它集合 collections ，set 支持 `x in set`, `len(set)`, 和 `for x in set` 。作为无序集合，set 不会记录元素的位置或插入顺序。因此集合不支持索引、切片或其它类似序列的行为。

目前有两种内置 set 类型：set 和 frozenset。set 类型是可变的——可以使用像 `add()` 和 `remove()` 这样的方法更改内容。由于 set 是可变，因此没有 hash 值，所以不能被用作字典的键值 或是作为另一个 set 中的元素。frozenset type 不可变且可被 hashable —— 其内容在创建后便不可以改变；因此它可以用作字典的键值或是另一 set 中的元素。

set 和 dict 的唯一区别仅在于没有存储对应的 value。但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证 se t内部“不会有重复元素”。若把 list 放入set，则会报错。

set 会自动过滤掉重复元素：

```
>>> s = set([1, 1, 2, 2, 3, 3])
>>> s
{1, 2, 3}
```

### 创建集合

Non-empty sets (not frozensets) can be created by placing a comma-separated list of elements within braces, for example: `{'jack', 'sjoerd'}`, in addition to the [`set`](https://docs.python.org/3/library/stdtypes.html#set) constructor.

The constructors for both classes work the same:

-   class set([iterable])

-   class frozenset([iterable])

Return a new set or frozenset object whose elements are taken from *iterable*. The elements of a set must be [hashable](https://docs.python.org/3/glossary.html#term-hashable). To represent sets of sets, the inner sets must be [`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset) objects. If *iterable* is not specified, a new empty set is returned.

创建空集，必须使用  `set()` 。如果试图使用 `{}` 创建空集，则会创建一个空字典。

```
>>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
>>> print(basket)                      # show that duplicates have been removed
{'orange', 'banana', 'pear', 'apple'}
>>> 'orange' in basket                 # fast membership testing 
True
>>> 'crabgrass' in basket
False

>>> # Demonstrate set operations on unique letters from two words
...
>>> a = set('abracadabra')
>>> b = set('alacazam')
>>> a                                  # unique letters in a 
{'a', 'r', 'b', 'c', 'd'}
>>> a - b                              # letters in a but not in b
{'r', 'd', 'b'}
>>> a | b                              # letters in either a or b
{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}
>>> a & b                              # letters in both a and b
{'a', 'c'}
>>> a ^ b                              # letters in a or b but not both
{'r', 'd', 'b', 'm', 'z', 'l'}
```

类似于列表推导 [list comprehensions](#tut-listcomps)，也支持集合推导：

```
>>> a = {x for x in 'abracadabra' if x not in 'abc'}
>>> a
{'r', 'd'}
```

若使用 `set()` 构造函数，需要提供一个 list 作为输入集合。
`set()` BIF 是一个工厂函数 factory function 

```
>>> s = set([1, 2, 3])
>>> s
{1, 2, 3}
```

### 操作集合的方法

-   `len(s)`

    Return the number of elements in set *s* (cardinality of *s*).


-   `x in s`

    Test *x* for membership in *s*.


-   `x not in s`

    Test *x* for non-membership in *s*.


-   `isdisjoint`(*other*)

    Return `True` if the set has no elements in common with *other*. Sets are disjoint if and only if their intersection is the empty set.


-   `issubset`(*other*)

-   `set <= other`

    Test whether every element in the set is in *other*.


-   `set < other`

    Test whether the set is a proper subset of *other*, that is, `set <= other and set != other`.


-   `issuperset`(*other*)

-   `set >= other`

    Test whether every element in *other* is in the set.


-   `set > other`

    Test whether the set is a proper superset of *other*, that is, `set >= other and set != other`.


-   `union`(**others*)

-   `set | other | ...`

    Return a new set with elements from the set and all others.


-   `intersection`(**others*)

-   `set & other & ...`

    Return a new set with elements common to the set and all others.


-   `difference`(**others*)

-   `set - other - ...`

    Return a new set with elements in the set that are not in the others.


-   `symmetric_difference`(*other*)

-   `set ^ other`

    Return a new set with elements in either the set or *other* but not both.


-   `copy`()

    Return a new set with a shallow copy of *s*.

Note, the non-operator versions of [`union()`](https://docs.python.org/3/library/stdtypes.html#set.union), [`intersection()`](https://docs.python.org/3/library/stdtypes.html#set.intersection), [`difference()`](https://docs.python.org/3/library/stdtypes.html#set.difference), and [`symmetric_difference()`](https://docs.python.org/3/library/stdtypes.html#set.symmetric_difference), [`issubset()`](https://docs.python.org/3/library/stdtypes.html#set.issubset), and [`issuperset()`](https://docs.python.org/3/library/stdtypes.html#set.issuperset) methods will accept any iterable as an argument. In contrast, their operator based counterparts require their arguments to be sets. This precludes error-prone constructions like `set('abc') & 'cbs'` in favor of the more readable `set('abc').intersection('cbs')`.

Both [`set`](https://docs.python.org/3/library/stdtypes.html#set) and [`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset) support set to set comparisons. Two sets are equal if and only if every element of each set is contained in the other (each is a subset of the other). A set is less than another set if and only if the first set is a proper subset of the second set (is a subset, but is not equal). A set is greater than another set if and only if the first set is a proper superset of the second set (is a superset, but is not equal).

Instances of [`set`](https://docs.python.org/3/library/stdtypes.html#set) are compared to instances of [`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset) based on their members. For example, `set('abc') == frozenset('abc')` returns `True` and so does `set('abc') inset([frozenset('abc')])`.

The subset and equality comparisons do not generalize to a total ordering function. For example, any two nonempty disjoint sets are not equal and are not subsets of each other, so *all* of the following return `False`: `a<b`, `a==b`, or `a>b`.

Since sets only define partial ordering (subset relationships), the output of the [`list.sort()`](https://docs.python.org/3/library/stdtypes.html#list.sort)method is undefined for lists of sets.

Set elements, like dictionary keys, must be [hashable](https://docs.python.org/3/glossary.html#term-hashable).

Binary operations that mix [`set`](https://docs.python.org/3/library/stdtypes.html#set) instances with [`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset) return the type of the first operand. For example: `frozenset('ab') | set('bc')` returns an instance of [`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset).

The following table lists operations available for [`set`](https://docs.python.org/3/library/stdtypes.html#set) that do not apply to immutable instances of [`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset):

-   `update`(**others*)

-   `set |= other | ...`

    Update the set, adding elements from all others. 
    `a = t | s` 并集


-   `intersection_update`(**others*)

-   `set &= other & ...`

    Update the set, keeping only elements found in it and all others.
    `a = t & s` 交集


-   `difference_update`(**others*)

-   `set -= other | ...`

    Update the set, removing elements found in others.
    `a = t - s` 求差集，求在 t 中，但不在 s 中的项


-   `symmetric_difference_update`(*other*)

-   `set ^= other`

    Update the set, keeping only elements found in either set, but not in both.
    `a = t ^ s` 对称差集，求在 t 或 s 中，但不同时出现在两者中的项


-   `add`(*elem*)

    将 *elem* 元素添加到集合中。


-   `remove`(*elem*)

    Remove element *elem* from the set. Raises [`KeyError`](https://docs.python.org/3/library/exceptions.html#KeyError) if *elem* is not contained in the set.删除某项


-   `discard`(*elem*)

    Remove element *elem* from the set if it is present.


-   `pop`()

    Remove and return an arbitrary element from the set. Raises [`KeyError`](https://docs.python.org/3/library/exceptions.html#KeyError) if the set is empty.


-   `clear`()

    Remove all elements from the set.

Note, the non-operator versions of the [`update()`](https://docs.python.org/3/library/stdtypes.html#set.update), [`intersection_update()`](https://docs.python.org/3/library/stdtypes.html#set.intersection_update), [`difference_update()`](https://docs.python.org/3/library/stdtypes.html#set.difference_update), and [`symmetric_difference_update()`](https://docs.python.org/3/library/stdtypes.html#set.symmetric_difference_update) methods will accept any iterable as an argument.

Note, the *elem* argument to the [`__contains__()`](https://docs.python.org/3/reference/datamodel.html#object.__contains__), [`remove()`](https://docs.python.org/3/library/stdtypes.html#set.remove), and [`discard()`](https://docs.python.org/3/library/stdtypes.html#set.discard) methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from *elem*.

```
>>> bri = set(['brazil', 'russia', 'india'])
>>> 'india' in bri
True
>>> 'usa' in bri
False
>>> bric = bri.copy()
>>> bric.add('china')
 #.issuperset方法测试bric是否为bri的超集
>>> bric.issuperset(bri)
True
>>> bri.remove('russia')
#.intersection 交集
>>> bri & bric # OR bri.intersection(bric)
{'brazil', 'india'}
```



## 4. 比较序列和其它类型

Comparing Sequences and Other Types

序列对象可以与具有相同序列类型的其他对象进行比较。 
比较使用词典 *lexicographical* 顺序：

-   首先比较前两个项目，如果它们不同，即可得出比较结果；如果它们相等，则比较接下来的两个项目，以此类推，直到任一序列被耗尽。

-   如果要比较的两个项本身是相同类型的序列，则递归地执行词典性比较。 如果两个序列的所有项目比较相等，则认为序列相等。 

-   如果一个序列是另一个序列的初始子序列，则较短的序列小于较长的序列。

字符串的词典 Lexicographical 排序使用 Unicode 代码标记单个字符排序的序号。相同类型的序列之间的比较的一些实例：

```
(1, 2, 3)              < (1, 2, 4)
[1, 2, 3]              < [1, 2, 4]
'ABC' < 'C' < 'Pascal' < 'Python' # 并不是字符越多越大
(1, 2, 3, 4)           < (1, 2, 4)
(1, 2)                 < (1, 2, -1)
(1, 2, 3)             == (1.0, 2.0, 3.0)
(1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)
```

注意：使用 `<` 或 `>` 比较两个不同类型的对象时，只要这些对象具有适当的比较方法，这种比较就是合法的。例如，混合数字类型根据其数值进行比较，因此 0 等于 0.0 。否则，解释器将抛出 `TypeError` 异常。

## 5. 补充

### del 语句

The [`del`](https://docs.python.org/3/reference/simple_stmts.html#del) statement

`del` 语句可以从列表中按给定的索引而不是值来删除一个子项。
`pop()` 方法有返回值。
`del` 还可用于从列表中删除切片或清空整个列表。
（通过为切片分配空列表，同样可以删除或清空整个列表）

```
>>> a = [-1, 1, 66.25, 333, 333, 1234.5]
>>> del a[0]
>>> a
[1, 66.25, 333, 333, 1234.5]
>>> del a[2:4]
>>> a
[1, 66.25, 1234.5]
>>> del a[:]
>>> a
[]
```

`del` 也可用于删除整个变量。删除后，若再引用此变量，就会引发错误。

```
>>> del a
```



### dir()

列出当前作用域中的全部名称