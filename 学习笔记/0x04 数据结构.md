# 0x04 数据结构

[TOC]



## 3. 集合类型 - set

Set Types — [`set`](https://docs.python.org/3/library/stdtypes.html#set), [`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset)[¶](https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset)

set 对象是不同的 hashable 对象的无序集合。
常见用途：1. 成员测试；2. 从序列中删除重复元素；3. 处理数学运算，如交集/并集/差集/对称差集。 
(For other containers see the built-in [`dict`](https://docs.python.org/3/library/stdtypes.html#dict), [`list`](https://docs.python.org/3/library/stdtypes.html#list), and [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple) classes, and the [`collections`](https://docs.python.org/3/library/collections.html#module-collections) module.)

类似于其它集合 collections ，set 支持 `x in set`, `len(set)`, 和 `for x in set` 。作为无序集合，set 不会记录元素的位置或插入顺序。因此集合不支持索引、切片或其它类似序列的行为。

目前有两种内置 set 类型：set 和 frozenset。set 类型是可变的——可以使用像 `add()` 和 `remove()` 这样的方法更改内容。由于 set 是可变，因此没有 hash 值，所以不能被用作字典的键值 或是作为另一个 set 中的元素。frozenset type 不可变且可被 hashable —— 其内容在创建后便不可以改变；因此它可以用作字典的键值或是另一 set 中的元素。

set 和 dict 的唯一区别仅在于没有存储对应的 value。但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证 se t内部“不会有重复元素”。若把 list 放入set，则会报错。

set 会自动过滤掉重复元素：

```
>>> s = set([1, 1, 2, 2, 3, 3])
>>> s
{1, 2, 3}
```

### 创建集合

Non-empty sets (not frozensets) can be created by placing a comma-separated list of elements within braces, for example: `{'jack', 'sjoerd'}`, in addition to the [`set`](https://docs.python.org/3/library/stdtypes.html#set) constructor.

The constructors for both classes work the same:

-   class set([iterable])

-   class frozenset([iterable])

Return a new set or frozenset object whose elements are taken from *iterable*. The elements of a set must be [hashable](https://docs.python.org/3/glossary.html#term-hashable). To represent sets of sets, the inner sets must be [`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset) objects. If *iterable* is not specified, a new empty set is returned.

创建空集，必须使用  `set()` 。如果试图使用 `{}` 创建空集，则会创建一个空字典。

```
>>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
>>> print(basket)                      # show that duplicates have been removed
{'orange', 'banana', 'pear', 'apple'}
>>> 'orange' in basket                 # fast membership testing 
True
>>> 'crabgrass' in basket
False

>>> # Demonstrate set operations on unique letters from two words
...
>>> a = set('abracadabra')
>>> b = set('alacazam')
>>> a                                  # unique letters in a 
{'a', 'r', 'b', 'c', 'd'}
>>> a - b                              # letters in a but not in b
{'r', 'd', 'b'}
>>> a | b                              # letters in either a or b
{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}
>>> a & b                              # letters in both a and b
{'a', 'c'}
>>> a ^ b                              # letters in a or b but not both
{'r', 'd', 'b', 'm', 'z', 'l'}
```

类似于列表推导 [list comprehensions](#tut-listcomps)，也支持集合推导：

```
>>> a = {x for x in 'abracadabra' if x not in 'abc'}
>>> a
{'r', 'd'}
```

若使用 `set()` 构造函数，需要提供一个 list 作为输入集合。
`set()` BIF 是一个工厂函数 factory function 

```
>>> s = set([1, 2, 3])
>>> s
{1, 2, 3}
```

### 操作集合的方法

-   `len(s)`

    Return the number of elements in set *s* (cardinality of *s*).


-   `x in s`

    Test *x* for membership in *s*.


-   `x not in s`

    Test *x* for non-membership in *s*.


-   `isdisjoint`(*other*)

    Return `True` if the set has no elements in common with *other*. Sets are disjoint if and only if their intersection is the empty set.


-   `issubset`(*other*)

-   `set <= other`

    Test whether every element in the set is in *other*.


-   `set < other`

    Test whether the set is a proper subset of *other*, that is, `set <= other and set != other`.


-   `issuperset`(*other*)

-   `set >= other`

    Test whether every element in *other* is in the set.


-   `set > other`

    Test whether the set is a proper superset of *other*, that is, `set >= other and set != other`.


-   `union`(**others*)

-   `set | other | ...`

    Return a new set with elements from the set and all others.


-   `intersection`(**others*)

-   `set & other & ...`

    Return a new set with elements common to the set and all others.


-   `difference`(**others*)

-   `set - other - ...`

    Return a new set with elements in the set that are not in the others.


-   `symmetric_difference`(*other*)

-   `set ^ other`

    Return a new set with elements in either the set or *other* but not both.


-   `copy`()

    Return a new set with a shallow copy of *s*.

Note, the non-operator versions of [`union()`](https://docs.python.org/3/library/stdtypes.html#set.union), [`intersection()`](https://docs.python.org/3/library/stdtypes.html#set.intersection), [`difference()`](https://docs.python.org/3/library/stdtypes.html#set.difference), and [`symmetric_difference()`](https://docs.python.org/3/library/stdtypes.html#set.symmetric_difference), [`issubset()`](https://docs.python.org/3/library/stdtypes.html#set.issubset), and [`issuperset()`](https://docs.python.org/3/library/stdtypes.html#set.issuperset) methods will accept any iterable as an argument. In contrast, their operator based counterparts require their arguments to be sets. This precludes error-prone constructions like `set('abc') & 'cbs'` in favor of the more readable `set('abc').intersection('cbs')`.

Both [`set`](https://docs.python.org/3/library/stdtypes.html#set) and [`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset) support set to set comparisons. Two sets are equal if and only if every element of each set is contained in the other (each is a subset of the other). A set is less than another set if and only if the first set is a proper subset of the second set (is a subset, but is not equal). A set is greater than another set if and only if the first set is a proper superset of the second set (is a superset, but is not equal).

Instances of [`set`](https://docs.python.org/3/library/stdtypes.html#set) are compared to instances of [`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset) based on their members. For example, `set('abc') == frozenset('abc')` returns `True` and so does `set('abc') inset([frozenset('abc')])`.

The subset and equality comparisons do not generalize to a total ordering function. For example, any two nonempty disjoint sets are not equal and are not subsets of each other, so *all* of the following return `False`: `a<b`, `a==b`, or `a>b`.

Since sets only define partial ordering (subset relationships), the output of the [`list.sort()`](https://docs.python.org/3/library/stdtypes.html#list.sort)method is undefined for lists of sets.

Set elements, like dictionary keys, must be [hashable](https://docs.python.org/3/glossary.html#term-hashable).

Binary operations that mix [`set`](https://docs.python.org/3/library/stdtypes.html#set) instances with [`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset) return the type of the first operand. For example: `frozenset('ab') | set('bc')` returns an instance of [`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset).

The following table lists operations available for [`set`](https://docs.python.org/3/library/stdtypes.html#set) that do not apply to immutable instances of [`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset):

-   `update`(**others*)

-   `set |= other | ...`

    Update the set, adding elements from all others. 
    `a = t | s` 并集


-   `intersection_update`(**others*)

-   `set &= other & ...`

    Update the set, keeping only elements found in it and all others.
    `a = t & s` 交集


-   `difference_update`(**others*)

-   `set -= other | ...`

    Update the set, removing elements found in others.
    `a = t - s` 求差集，求在 t 中，但不在 s 中的项


-   `symmetric_difference_update`(*other*)

-   `set ^= other`

    Update the set, keeping only elements found in either set, but not in both.
    `a = t ^ s` 对称差集，求在 t 或 s 中，但不同时出现在两者中的项


-   `add`(*elem*)

    将 *elem* 元素添加到集合中。


-   `remove`(*elem*)

    Remove element *elem* from the set. Raises [`KeyError`](https://docs.python.org/3/library/exceptions.html#KeyError) if *elem* is not contained in the set.删除某项


-   `discard`(*elem*)

    Remove element *elem* from the set if it is present.


-   `pop`()

    Remove and return an arbitrary element from the set. Raises [`KeyError`](https://docs.python.org/3/library/exceptions.html#KeyError) if the set is empty.


-   `clear`()

    Remove all elements from the set.

Note, the non-operator versions of the [`update()`](https://docs.python.org/3/library/stdtypes.html#set.update), [`intersection_update()`](https://docs.python.org/3/library/stdtypes.html#set.intersection_update), [`difference_update()`](https://docs.python.org/3/library/stdtypes.html#set.difference_update), and [`symmetric_difference_update()`](https://docs.python.org/3/library/stdtypes.html#set.symmetric_difference_update) methods will accept any iterable as an argument.

Note, the *elem* argument to the [`__contains__()`](https://docs.python.org/3/reference/datamodel.html#object.__contains__), [`remove()`](https://docs.python.org/3/library/stdtypes.html#set.remove), and [`discard()`](https://docs.python.org/3/library/stdtypes.html#set.discard) methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from *elem*.

```
>>> bri = set(['brazil', 'russia', 'india'])
>>> 'india' in bri
True
>>> 'usa' in bri
False
>>> bric = bri.copy()
>>> bric.add('china')
 #.issuperset方法测试bric是否为bri的超集
>>> bric.issuperset(bri)
True
>>> bri.remove('russia')
#.intersection 交集
>>> bri & bric # OR bri.intersection(bric)
{'brazil', 'india'}
```



## 4. 比较序列和其它类型

Comparing Sequences and Other Types

序列对象可以与具有相同序列类型的其他对象进行比较。 
比较使用词典 *lexicographical* 顺序：

-   首先比较前两个项目，如果它们不同，即可得出比较结果；如果它们相等，则比较接下来的两个项目，以此类推，直到任一序列被耗尽。

-   如果要比较的两个项本身是相同类型的序列，则递归地执行词典性比较。 如果两个序列的所有项目比较相等，则认为序列相等。 

-   如果一个序列是另一个序列的初始子序列，则较短的序列小于较长的序列。

字符串的词典 Lexicographical 排序使用 Unicode 代码标记单个字符排序的序号。相同类型的序列之间的比较的一些实例：

```
(1, 2, 3)              < (1, 2, 4)
[1, 2, 3]              < [1, 2, 4]
'ABC' < 'C' < 'Pascal' < 'Python' # 并不是字符越多越大
(1, 2, 3, 4)           < (1, 2, 4)
(1, 2)                 < (1, 2, -1)
(1, 2, 3)             == (1.0, 2.0, 3.0)
(1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)
```

注意：使用 `<` 或 `>` 比较两个不同类型的对象时，只要这些对象具有适当的比较方法，这种比较就是合法的。例如，混合数字类型根据其数值进行比较，因此 0 等于 0.0 。否则，解释器将抛出 `TypeError` 异常。

## 5. 补充

### del 语句

The [`del`](https://docs.python.org/3/reference/simple_stmts.html#del) statement

`del` 语句可以从列表中按给定的索引而不是值来删除一个子项。
`pop()` 方法有返回值。
`del` 还可用于从列表中删除切片或清空整个列表。
（通过为切片分配空列表，同样可以删除或清空整个列表）

```
>>> a = [-1, 1, 66.25, 333, 333, 1234.5]
>>> del a[0]
>>> a
[1, 66.25, 333, 333, 1234.5]
>>> del a[2:4]
>>> a
[1, 66.25, 1234.5]
>>> del a[:]
>>> a
[]
```

`del` 也可用于删除整个变量。删除后，若再引用此变量，就会引发错误。

```
>>> del a
```


