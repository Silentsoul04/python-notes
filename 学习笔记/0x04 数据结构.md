# 0x04 数据结构

[TOC]

## 1. 序列类型[¶](https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex)

Sequence Types — [`list`](https://docs.python.org/3/library/stdtypes.html#list), [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple), [`range`](https://docs.python.org/3/library/stdtypes.html#range)[¶](https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range)

有三种基本的序列类型: lists, tuples, and range objects. 
附加序列类型有两种：Text Sequence Type - `str`  和 Binary Sequence Types - `bytes` 。专门用于处理 [text strings](https://docs.python.org/3/library/stdtypes.html#textseq) 和  [binary data](https://docs.python.org/3/library/stdtypes.html#binaryseq) 

### 通用序列操作[¶](https://docs.python.org/3/library/stdtypes.html#common-sequence-operations)

Common Sequence Operations[¶](https://docs.python.org/3/library/stdtypes.html#common-sequence-operations)

大多数的序列类型都支持下表中的操作，包括可变序列和不可变序列。
所提供的 `collections.abc.Sequence` 抽象基类(ABC-abstract base class) ，会使得在自定义序列类型上正确实现这些操作会更加容易。

该表格中越是底部的 operation 优先级最高。
s 和 t 是相同类型的序列；n/i/j/k 是整数；x 是 s 中的任意对象。

`in` / `not in` 和比较操作符具有相同的优先级。
`+` (连接) 和 `*` (重复)操作符和数学运算中的 `+` /`*` 具有相同的优先级。

| Operation              | Result                                   | Notes  |
| ---------------------- | ---------------------------------------- | ------ |
| `x in s`               | `True` if an item of *s* is equal to *x*, else `False` | (1)    |
| `x not in s`           | `False` if an item of *s* is equal to *x*, else `True` | (1)    |
| `s + t`                | the concatenation of *s* and *t*         | (6)(7) |
| `s * n` or `n * s`     | equivalent to adding *s* to itself *n* times | (2)(7) |
| `s[i]`                 | *i*th item of *s*, origin 0              | (3)    |
| `s[i:j]`               | slice of *s* from *i* to *j*             | (3)(4) |
| `s[i:j:k]`             | slice of *s* from *i* to *j* with step *k* | (3)(5) |
| `len(s)`               | length of *s*                            |        |
| `min(s)`               | smallest item of *s*                     |        |
| `max(s)`               | largest item of *s*                      |        |
| `s.index(x[, i[, j]])` | index of the first occurrence of *x* in *s* (at or after index *i* and before index *j*) | (8)    |
| `s.count(x)`           | total number of occurrences of *x* in *s* |        |

相同类型的序列也支持比较。In particular, tuples and lists are compared lexicographically by comparing corresponding elements. This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. (For full details see [Comparisons](https://docs.python.org/3/reference/expressions.html#comparisons) in the language reference.)

### 不可变列表类型[¶](https://docs.python.org/3/library/stdtypes.html#immutable-sequence-types)

Immutable Sequence Types

The only operation that immutable sequence types generally implement that is not also implemented by mutable sequence types is support for the [`hash()`](https://docs.python.org/3/library/functions.html#hash) built-in.

This support allows immutable sequences, such as [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple) instances, to be used as [`dict`](https://docs.python.org/3/library/stdtypes.html#dict) keys and stored in [`set`](https://docs.python.org/3/library/stdtypes.html#set) and [`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset) instances.

Attempting to hash an immutable sequence that contains unhashable values will result in [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError).

### 可变序列类型的操作方法[¶](https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types)

Mutable Sequence Types

The operations in the following table are defined on mutable sequence types. The [`collections.abc.MutableSequence`](https://docs.python.org/3/library/collections.abc.html#collections.abc.MutableSequence) ABC is provided to make it easier to correctly implement these operations on custom sequence types.

In the table *s* is an instance of a mutable sequence type, *t* is any iterable object and *x* is an arbitrary object that meets any type and value restrictions imposed by *s* (for example, [`bytearray`](https://docs.python.org/3/library/stdtypes.html#bytearray)only accepts integers that meet the value restriction `0 <= x <= 255`).

| Operation                 | Result                                   | Notes |
| ------------------------- | ---------------------------------------- | ----- |
| `s[i] = x`                | item *i* of *s* is replaced by *x*       |       |
| `s[i:j] = t`              | slice of *s* from *i* to *j* is replaced by the contents of the iterable *t* |       |
| `del s[i:j]`              | same as `s[i:j] = []`                    |       |
| `s[i:j:k] = t`            | the elements of `s[i:j:k]` are replaced by those of *t* | (1)   |
| `del s[i:j:k]`            | removes the elements of `s[i:j:k]`from the list |       |
| `s.append(x)`             | appends *x* to the end of the sequence (same as`s[len(s):len(s)] = [x]` ) |       |
| `s.clear()`               | removes all items from `s` (same as `del s[:]`) | (5)   |
| `s.copy()`                | creates a shallow copy of `s` (same as `s[:]`) | (5)   |
| `s.extend(t)` or `s += t` | extends *s* with the contents of *t* (for the most part the same as `s[len(s):len(s)] = t` / `s[len(s):] = t`) |       |
| `s *= n`                  | updates *s* with its contents repeated *n* times | (6)   |
| `s.insert(i, x)`          | inserts *x* into *s* at the index given by *i* (same as `s[i:i] = [x]`) |       |
| `s.pop([i])`              | retrieves the item at *i* and also removes it from *s* | (2)   |
| `s.remove(x)`             | remove the first item from *s* where `s[i] == x` | (3)   |
| `s.reverse()`             | reverses the items of *s* in place       | (4)   |

Notes:

1.  *t* must have the same length as the slice it is replacing.

2.  The optional argument *i* defaults to `-1`, so that by default the last item is removed and returned.

3.  `remove` raises [`ValueError`](https://docs.python.org/3/library/exceptions.html#ValueError) when *x* is not found in *s*.

4.  The `reverse()` method modifies the sequence in place for economy of space when reversing a large sequence. To remind users that it operates by side effect, it does not return the reversed sequence.

5.  `clear()` and `copy()` are included for consistency with the interfaces of mutable containers that don’t support slicing operations (such as [`dict`](https://docs.python.org/3/library/stdtypes.html#dict) and [`set`](https://docs.python.org/3/library/stdtypes.html#set))

    New in version 3.3: `clear()` and `copy()` methods.

6.  The value *n* is an integer, or an object implementing [`__index__()`](https://docs.python.org/3/reference/datamodel.html#object.__index__). Zero and negative values of *n* clear the sequence. Items in the sequence are not copied; they are referenced multiple times, as explained for `s * n` under [Common Sequence Operations](https://docs.python.org/3/library/stdtypes.html#typesseq-common).

### list [¶](https://docs.python.org/3/library/stdtypes.html#lists)

`list` 是有序且可变的序列类型，同时也是一种复合数据类型。列表中各个元素的数据类型可以不相同。

```
>>> classmates = ['Michael', 'Bob', 'Tracy']
>>> classmates
['Michael', 'Bob', 'Tracy']

>>> len(classmates)
3

>>> cubes = [1, 8, 27, 65, 125]  # something's wrong here
>>> 4 ** 3  # the cube of 4 is 64, not 65!
64
>>> cubes[3] = 64  # replace the wrong value
>>> cubes
[1, 8, 27, 64, 125]
```

-   空列表

```
>>> L = [] # 或 L=list()
>>> len(L)
0
```

-   切片

切片操作会返回一个包含请求元素的新列表对象。

```
>>> squares[:] # 返回一个新的浅拷贝(shallow)
[1, 4, 9, 16, 25]
>>> list(squares) # 也会返回一个浅拷贝
```

[深拷贝](https://blog.csdn.net/u011630575/article/details/78604226) 

为切片赋值，可用于改变列表尺寸或清除整个列表：

```
>>> letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
>>> letters
['a', 'b', 'c', 'd', 'e', 'f', 'g']
>>> # replace some values
>>> letters[2:5] = ['C', 'D', 'E']
>>> letters
['a', 'b', 'C', 'D', 'E', 'f', 'g']
>>> # now remove them
>>> letters[2:5] = []
>>> letters
['a', 'b', 'f', 'g']
>>> # clear the list by replacing all the elements with an empty list
>>> letters[:] = []
>>> letters
[]
```

#### 操作列表的方法

列表操作支持这两节的内容：

-   **通用序列操作** 
-   **可变序列类型的操作方法** 。

像 `insert`/`remove`/`sort` 这样的方法，只是修改列表，没有返回值打印 - 这些方法默认返回 `None` 。这是 Pyhton 中所有可变数据结构的设计原则。

##### .sort ( ) 原地排序

sort (*, key=None, reverse=None) [¶](https://docs.python.org/3/library/stdtypes.html#list.sort)

通过使用列表的`sort` 方法排序列表。重点需要理解的是，该方法影响列表本身，而不是返回一个修改后的列表 - 这不同于字符串的工作方式。这就是所谓的列表是可变的，而字符串是不可变的。
In-place sorting 原地排序时，原有顺序会丢失。

##### sorted( ) 复制排序

sorted(*iterable[, key][, reverse]*) 是 BIF

Return a new sorted list from the items in *iterable*.

Has two optional arguments which must be specified as keyword arguments.

*key* specifies a function of one argument that is used to extract a comparison key from each list element: `key=str.lower`. The default value is `None` (compare the elements directly).

*reverse* is a boolean value. If set to `True`, then the list elements are sorted as if each comparison were reversed.

Use [`functools.cmp_to_key()`](functools.html#functools.cmp_to_key) to convert an old-style *cmp* function to a *key* function.

The built-in [`sorted()`](#sorted) function is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal — this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade).

For sorting examples and a brief sorting tutorial, see [Sorting HOW TO](../howto/sorting.html#sortinghowto).

Copied sorting 复制排序，会返回新的数据副本。



#### 列表与堆栈

Using Lists as Stacks

堆栈 stack 遵循 “last-in, first-out”  原则。
使用 `.append()` 向堆栈顶部追加元素，使用 `.pop()` 从堆栈顶部取回元素。

```
>>> stack = [3, 4, 5]
>>> stack.append(6)
>>> stack.append(7)
>>> stack
[3, 4, 5, 6, 7]
>>> stack.pop()
7
>>> stack
[3, 4, 5, 6]
```

#### 列表与队列

Using Lists as Queues

队列 queues 遵循 “first-in, first-out” 原则。
列表作为队列使用时，其效率很低。
虽然在列表尾部执行 `append` 和 `pop` 很快，但是在列表的开头执行插入和弹出操作却很慢。这是因为在列表头部进行操作时，其后的所有元素都会被注意移动。

队列可使用 [`deque`](https://docs.python.org/3/library/collections.html#collections.deque) objects 实现，该类可从两端快速添加或删除。

```
>>> from collections import deque
>>> queue = deque(["Eric", "John", "Michael"])
>>> queue.append("Terry")           # Terry arrives
>>> queue.append("Graham")          # Graham arrives
>>> queue.popleft()                 # The first to arrive now leaves
'Eric'
>>> queue.popleft()                 # The second to arrive now leaves
'John'
>>> queue                           # Remaining queue in order of arrival
deque(['Michael', 'Terry', 'Graham'])
```

#### 列表与枚举 enumerate

参看 0x06 高级特性 > 2. 迭代 Iteration > 枚举 enumerate

### tuple [¶](https://docs.python.org/3/library/stdtypes.html#tuples)

元组作为不可变序列不能使用 **可变序列类型的操作方法**[¶](https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types) ，但可以使用 **通用序列操作** 。不能为元组中单独的项赋值，但是可以创建包含可变对象的元组。
正是因为元组的不可变性，相较于可变序列，使用元组会让代码更加安全。
另外，程序在创建小列表时(包含的项少于12个)，会浪费一些内存。因为系统会为列表稍微多分配一些内存，以优化添加新项时的操作性能。而元组是不可变的，所以它们的表示更为紧凑，不会占据额外的内存空间。

```
>>> t = 12345, 54321, 'hello!'
>>> t[0]
12345
>>> t
(12345, 54321, 'hello!')
>>> # Tuples may be nested:
... u = t, (1, 2, 3, 4, 5)
>>> u
((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))
>>> # Tuples are immutable:元组是不可变的
... t[0] = 88888
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
>>> # but they can contain mutable objects:
... v = ([1, 2, 3], [3, 2, 1])
>>> v
([1, 2, 3], [3, 2, 1])
```

#### 序列拆封

尽管元祖表面上类似于列表，但常被用于不同的用途。
列表通常包含同构元素序列，以迭代的方式访问，更加方便。
元组通常包含异构元素序列，通过 unpacking 或索引的方法更好。
如果是 [namedtuples](https://docs.python.org/3/library/collections.html#collections.namedtuple) ，甚至可通过属性访问其中的元素。

```
In [62]: from collections import namedtuple

In [63]: Point = namedtuple('Point', ['x', 'y'])

In [64]: p = Point(11, y=22)

In [65]: p.x
Out[65]: 11

In [66]: p.y
Out[66]: 22

In [67]: p
Out[67]: Point(x=11, y=22)

In [68]: a, b = p #解包unpacking操作

In [69]: a,b
Out[69]: (11, 22)
```

注意：执行序列拆封 *sequence unpacking* 时，等号右侧可以是任何序列。
拆封时，要求左侧变量的数目和右侧序列中元素的个数相同。
多重赋值(multiple assignment) 实际上就是序列封装和拆封的应用。

```
>>> x, y, z = t

>>> list_ = [(1,2,3),(4,5,6)]
>>> for a,b,c in list_:
	print(a,b,c)

	
1 2 3
4 5 6
```

嵌套的元组也可一次性拆封

```python
>>> rgb = (1,2,3)
>>> rgb = ("red" ,"green", "blue")
>>> hexString = 0xFF
>>> rgbTuple = (rgb, hexString)
>>> ((r, g, b), hexStr) = rgbTuple
```



#### 定义空元组

`a = ()`

#### 定义单元素元组

```
In [75]: a  = (1)

In [76]: a #此时a是一个整数
Out[76]: 1

In [77]: b = (1,)#需要附加逗号

In [78]: b
Out[78]: (1,)
```

#### 包含可变对象的元组

元组虽是不可变序列，但是可以创建包含可变对象的元组。

```
>>> t = ('a', 'b', ['A', 'B'])
>>> t[2][0] = 'X'
>>> t[2][1] = 'Y'
>>> t
('a', 'b', ['X', 'Y'])

```

从表面上看，元组中的元素发生了改变。
但是变化的并非是 tuple，而是 list 中的元素。
所谓的不可变序列，是指 tuple 中每个元素的指向永远不变。
即，指向 `a ` 便不能改为 `c` ；指向 list_a ，同样也不能改为 list_b，但是 list_a 本身是可变的。所以说变化是 list 而非 tuple。



## 2. 映射类型 - dict

Mapping Types — [`dict`](https://docs.python.org/3/library/stdtypes.html#dict)[¶](https://docs.python.org/3/library/stdtypes.html#mapping-types-dict)

[mapping](https://docs.python.org/3/glossary.html#term-mapping) 对象会将 [hashable](https://docs.python.org/3/glossary.html#term-hashable) 值映射到任意对象。
mappings 是可变对象。
目前只有一种标准的映射类型，即 dictionary。
 (对于其它 containers 请查看 built-in[`list`](https://docs.python.org/3/library/stdtypes.html#list), [`set`](https://docs.python.org/3/library/stdtypes.html#set), and [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple) classes, and the [`collections`](https://docs.python.org/3/library/collections.html#module-collections) module.)

在别的编程语言中 dict 也被称作 联合内存(associative memories) 或联合数组(associative arrays)。

-   key ：是 [hashable](https://docs.python.org/3/glossary.html#term-hashable) 值。包含列表、字典或其它可变类型的值，不能用作 key。用作 key 的 Numeric 类型，遵循数字比较的一般规则：如果两个数相等，那么在引用相同字典条目时，可互换（例如1和1.0）。（注意：由于计算机将浮点数存储为近似值，因此将浮点数用于 key 是不明智的做法。

### 创建字典

在字典中每个 键值 对被称作一个条目(entry)

Dictionaries can be created by placing a comma-separated list of `key: value` pairs within braces, for example: `{'jack': 4098, 'sjoerd': 4127}` or `{4098: 'jack', 4127: 'sjoerd'}`, or by the [`dict`](https://docs.python.org/3/library/stdtypes.html#dict)constructor.

`dict()` BIF 是用于构建字典的工厂函数。

`class dict(**kwarg)`
`class dict(mapping, **kwarg)`
`class dict(iterable, **kwarg)`

Return a new dictionary initialized from an optional positional argument and a possibly empty set of keyword arguments.

If no positional argument is given, an empty dictionary is created. If a positional argument is given and it is a mapping object, a dictionary is created with the same key-value pairs as the mapping object. Otherwise, the positional argument must be an [iterable](https://docs.python.org/3/glossary.html#term-iterable) object. Each item in the iterable must itself be an iterable with exactly two objects. The first object of each item becomes a key in the new dictionary, and the second object the corresponding value. If a key occurs more than once, the last value for that key becomes the corresponding value in the new dictionary.

If keyword arguments are given, the keyword arguments and their values are added to the dictionary created from the positional argument. If a key being added is already present, the value from the keyword argument replaces the value from the positional argument.

To illustrate, the following examples all return a dictionary equal to `{"one": 1, "two": 2,"three": 3}`:

```
>>> a = dict(one=1, two=2, three=3)
>>> b = {'one': 1, 'two': 2, 'three': 3}
>>> c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))
>>> d = dict([('two', 2), ('one', 1), ('three', 3)])
>>> e = dict({'three': 3, 'one': 1, 'two': 2})
>>> a == b == c == d == e
True
```

roviding keyword arguments as in the first example only works for keys that are valid Python identifiers. Otherwise, any valid keys can be used.

字典推导式被用于从任意 key 和 value 表达式中创建字典：

```
>>> {x: x**2 for x in (2, 4, 6)}
{2: 4, 4: 16, 6: 36}
```

创建空字典：

```
a = {} 
b = dict()
```



### 操作字典的方法

以下是字典支持的操作，自定义映射类型也应该会支持这些操作。

-   `len(d)`

    Return the number of items in the dictionary *d*.


-   `d[key]`

    Return the item of *d* with key *key*. Raises a [`KeyError`](https://docs.python.org/3/library/exceptions.html#KeyError) if *key* is not in the map.If a subclass of dict defines a method [`__missing__()`](https://docs.python.org/3/reference/datamodel.html#object.__missing__) and *key* is not present, the `d[key]`operation calls that method with the key *key* as argument. The `d[key]` operation then returns or raises whatever is returned or raised by the `__missing__(key)` call. No other operations or methods invoke [`__missing__()`](https://docs.python.org/3/reference/datamodel.html#object.__missing__). If [`__missing__()`](https://docs.python.org/3/reference/datamodel.html#object.__missing__) is not defined, [`KeyError`](https://docs.python.org/3/library/exceptions.html#KeyError) is raised. [`__missing__()`](https://docs.python.org/3/reference/datamodel.html#object.__missing__) must be a method; it cannot be an instance variable:

    ```
    >>> class Counter(dict):
    ...     def __missing__(self, key):
    ...         return 0
    >>> c = Counter()
    >>> c['red']
    0
    >>> c['red'] += 1
    >>> c['red']
    1
    ```


    The example above shows part of the implementation of [`collections.Counter`](https://docs.python.org/3/library/collections.html#collections.Counter). A different `__missing__` method is used by [`collections.defaultdict`](https://docs.python.org/3/library/collections.html#collections.defaultdict).

-   `d[key] = value`

    Set `d[key]` to *value*.


-   `del d[key]`

    Remove `d[key]` from *d*. Raises a [`KeyError`](https://docs.python.org/3/library/exceptions.html#KeyError) if *key* is not in the map.


-   `key in d`

    Return `True` if *d* has a key *key*, else `False`.


-   `key not in d`

    Equivalent to `not key in d`.


-   `iter(d)`

    Return an iterator over the keys of the dictionary. This is a shortcut for `iter(d.keys())`.


-   `clear`()

    Remove all items from the dictionary.


-   `copy`()

    Return a shallow copy of the dictionary.


-   *classmethod *`fromkeys`(*seq*[, *value*])

    Create a new dictionary with keys from *seq* and values set to *value*.[`fromkeys()`](https://docs.python.org/3/library/stdtypes.html#dict.fromkeys) is a class method that returns a new dictionary. *value* defaults to `None`.


-   `get`(*key*[, *default*])

    Return the value for *key* if *key* is in the dictionary, else *default*. If *default* is not given, it defaults to `None`, so that this method never raises a [`KeyError`](https://docs.python.org/3/library/exceptions.html#KeyError).


-   `items`() 访问键值对

    Return a new view of the dictionary’s items (`(key, value)` pairs). See the [documentation of view objects](https://docs.python.org/3/library/stdtypes.html#dict-views).


-   `keys`()

    Return a new view of the dictionary’s keys. See the [documentation of view objects](https://docs.python.org/3/library/stdtypes.html#dict-views). 
    该视图支持成员测试、迭代等操作。但其内容并不是独立于原始字典的。

    `list(d.keys())`  返回 keys 组成的无序列表

    `sorted(d.keys())` 返回排序后的列表


-   `pop`(*key*[, *default*])

    If *key* is in the dictionary, remove it and return its value, else return *default*. If *default* is not given and *key* is not in the dictionary, a [`KeyError`](https://docs.python.org/3/library/exceptions.html#KeyError) is raised.


-   `popitem`()

    Remove and return an arbitrary `(key, value)` pair from the dictionary.[`popitem()`](https://docs.python.org/3/library/stdtypes.html#dict.popitem) is useful to destructively iterate over a dictionary, as often used in set algorithms. If the dictionary is empty, calling [`popitem()`](https://docs.python.org/3/library/stdtypes.html#dict.popitem) raises a [`KeyError`](https://docs.python.org/3/library/exceptions.html#KeyError).


-   `setdefault`(*key*[, *default*])

    If *key* is in the dictionary, return its value. If not, insert *key* with a value of *default* and return *default*. *default* defaults to `None`.


-   `update`([*other*])

    Update the dictionary with the key/value pairs from *other*, overwriting existing keys. Return `None`.[`update()`](https://docs.python.org/3/library/stdtypes.html#dict.update) accepts either another dictionary object or an iterable of key/value pairs (as tuples or other iterables of length two). If keyword arguments are specified, the dictionary is then updated with those key/value pairs: `d.update(red=1, blue=2)`.


-   `values`()

    Return a new view of the dictionary’s values. See the [documentation of view objects](https://docs.python.org/3/library/stdtypes.html#dict-views).

Dictionaries compare equal if and only if they have the same `(key, value)` pairs. Order comparisons (‘<’, ‘<=’, ‘>=’, ‘>’) raise [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError).

See also：

[`types.MappingProxyType`](https://docs.python.org/3/library/types.html#types.MappingProxyType) can be used to create a read-only view of a [`dict`](https://docs.python.org/3/library/stdtypes.html#dict).




```
>>> tel = {'jack': 4098, 'sape': 4139}
>>> tel['guido'] = 4127
>>> tel
{'sape': 4139, 'guido': 4127, 'jack': 4098}
>>> tel['jack']
4098
>>> del tel['sape']
>>> tel['irv'] = 4127
>>> tel
{'guido': 4127, 'irv': 4127, 'jack': 4098}
>>> list(tel.keys())
['irv', 'guido', 'jack']
>>> sorted(tel.keys())
['guido', 'irv', 'jack']
>>> 'guido' in tel
True
>>> 'jack' not in tel
False
```



### dict vs list

和list比较，dict有以下几个特点：

1.  查找和插入的速度极快，不会随着key的增加而变慢；
2.  需要占用大量的内存，内存浪费多。

而list相反：

1.  查找和插入的时间随着元素的增加而增加；
2.  占用空间小，浪费内存很少。

所以，dict 是用空间来换取时间的一种方法。

dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict 非常重要，需要牢记的第一条就是dict 的 key 必须是**不可变对象**。

这是因为dict 根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过 key 计算位置的算法称为哈希算法（Hash）。

要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key：

```
>>> key = [1, 2, 3]
>>> d[key] = 'a list'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'
```



## 3. 集合类型 - set

Set Types — [`set`](https://docs.python.org/3/library/stdtypes.html#set), [`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset)[¶](https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset)

set 对象是不同的 hashable 对象的无序集合。
常见用途：1. 成员测试；2. 从序列中删除重复元素；3. 处理数学运算，如交集/并集/差集/对称差集。 
(For other containers see the built-in [`dict`](https://docs.python.org/3/library/stdtypes.html#dict), [`list`](https://docs.python.org/3/library/stdtypes.html#list), and [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple) classes, and the [`collections`](https://docs.python.org/3/library/collections.html#module-collections) module.)

类似于其它集合 collections ，set 支持 `x in set`, `len(set)`, 和 `for x in set` 。作为无序集合，set 不会记录元素的位置或插入顺序。因此集合不支持索引、切片或其它类似序列的行为。

目前有两种内置 set 类型：set 和 frozenset。set 类型是可变的——可以使用像 `add()` 和 `remove()` 这样的方法更改内容。由于 set 是可变，因此没有 hash 值，所以不能被用作字典的键值 或是作为另一个 set 中的元素。frozenset type 不可变且可被 hashable —— 其内容在创建后便不可以改变；因此它可以用作字典的键值或是另一 set 中的元素。

set 和 dict 的唯一区别仅在于没有存储对应的 value。但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证 se t内部“不会有重复元素”。若把 list 放入set，则会报错。

set 会自动过滤掉重复元素：

```
>>> s = set([1, 1, 2, 2, 3, 3])
>>> s
{1, 2, 3}
```

### 创建集合

Non-empty sets (not frozensets) can be created by placing a comma-separated list of elements within braces, for example: `{'jack', 'sjoerd'}`, in addition to the [`set`](https://docs.python.org/3/library/stdtypes.html#set) constructor.

The constructors for both classes work the same:

-   class set([iterable])

-   class frozenset([iterable])

Return a new set or frozenset object whose elements are taken from *iterable*. The elements of a set must be [hashable](https://docs.python.org/3/glossary.html#term-hashable). To represent sets of sets, the inner sets must be [`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset) objects. If *iterable* is not specified, a new empty set is returned.

创建空集，必须使用  `set()` 。如果试图使用 `{}` 创建空集，则会创建一个空字典。

```
>>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
>>> print(basket)                      # show that duplicates have been removed
{'orange', 'banana', 'pear', 'apple'}
>>> 'orange' in basket                 # fast membership testing 
True
>>> 'crabgrass' in basket
False

>>> # Demonstrate set operations on unique letters from two words
...
>>> a = set('abracadabra')
>>> b = set('alacazam')
>>> a                                  # unique letters in a 
{'a', 'r', 'b', 'c', 'd'}
>>> a - b                              # letters in a but not in b
{'r', 'd', 'b'}
>>> a | b                              # letters in either a or b
{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}
>>> a & b                              # letters in both a and b
{'a', 'c'}
>>> a ^ b                              # letters in a or b but not both
{'r', 'd', 'b', 'm', 'z', 'l'}
```

类似于列表推导 [list comprehensions](#tut-listcomps)，也支持集合推导：

```
>>> a = {x for x in 'abracadabra' if x not in 'abc'}
>>> a
{'r', 'd'}
```

若使用 `set()` 构造函数，需要提供一个 list 作为输入集合。
`set()` BIF 是一个工厂函数 factory function 

```
>>> s = set([1, 2, 3])
>>> s
{1, 2, 3}
```

### 操作集合的方法

-   `len(s)`

    Return the number of elements in set *s* (cardinality of *s*).


-   `x in s`

    Test *x* for membership in *s*.


-   `x not in s`

    Test *x* for non-membership in *s*.


-   `isdisjoint`(*other*)

    Return `True` if the set has no elements in common with *other*. Sets are disjoint if and only if their intersection is the empty set.


-   `issubset`(*other*)

-   `set <= other`

    Test whether every element in the set is in *other*.


-   `set < other`

    Test whether the set is a proper subset of *other*, that is, `set <= other and set != other`.


-   `issuperset`(*other*)

-   `set >= other`

    Test whether every element in *other* is in the set.


-   `set > other`

    Test whether the set is a proper superset of *other*, that is, `set >= other and set != other`.


-   `union`(**others*)

-   `set | other | ...`

    Return a new set with elements from the set and all others.


-   `intersection`(**others*)

-   `set & other & ...`

    Return a new set with elements common to the set and all others.


-   `difference`(**others*)

-   `set - other - ...`

    Return a new set with elements in the set that are not in the others.


-   `symmetric_difference`(*other*)

-   `set ^ other`

    Return a new set with elements in either the set or *other* but not both.


-   `copy`()

    Return a new set with a shallow copy of *s*.

Note, the non-operator versions of [`union()`](https://docs.python.org/3/library/stdtypes.html#set.union), [`intersection()`](https://docs.python.org/3/library/stdtypes.html#set.intersection), [`difference()`](https://docs.python.org/3/library/stdtypes.html#set.difference), and [`symmetric_difference()`](https://docs.python.org/3/library/stdtypes.html#set.symmetric_difference), [`issubset()`](https://docs.python.org/3/library/stdtypes.html#set.issubset), and [`issuperset()`](https://docs.python.org/3/library/stdtypes.html#set.issuperset) methods will accept any iterable as an argument. In contrast, their operator based counterparts require their arguments to be sets. This precludes error-prone constructions like `set('abc') & 'cbs'` in favor of the more readable `set('abc').intersection('cbs')`.

Both [`set`](https://docs.python.org/3/library/stdtypes.html#set) and [`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset) support set to set comparisons. Two sets are equal if and only if every element of each set is contained in the other (each is a subset of the other). A set is less than another set if and only if the first set is a proper subset of the second set (is a subset, but is not equal). A set is greater than another set if and only if the first set is a proper superset of the second set (is a superset, but is not equal).

Instances of [`set`](https://docs.python.org/3/library/stdtypes.html#set) are compared to instances of [`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset) based on their members. For example, `set('abc') == frozenset('abc')` returns `True` and so does `set('abc') inset([frozenset('abc')])`.

The subset and equality comparisons do not generalize to a total ordering function. For example, any two nonempty disjoint sets are not equal and are not subsets of each other, so *all* of the following return `False`: `a<b`, `a==b`, or `a>b`.

Since sets only define partial ordering (subset relationships), the output of the [`list.sort()`](https://docs.python.org/3/library/stdtypes.html#list.sort)method is undefined for lists of sets.

Set elements, like dictionary keys, must be [hashable](https://docs.python.org/3/glossary.html#term-hashable).

Binary operations that mix [`set`](https://docs.python.org/3/library/stdtypes.html#set) instances with [`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset) return the type of the first operand. For example: `frozenset('ab') | set('bc')` returns an instance of [`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset).

The following table lists operations available for [`set`](https://docs.python.org/3/library/stdtypes.html#set) that do not apply to immutable instances of [`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset):

-   `update`(**others*)

-   `set |= other | ...`

    Update the set, adding elements from all others. 
    `a = t | s` 并集


-   `intersection_update`(**others*)

-   `set &= other & ...`

    Update the set, keeping only elements found in it and all others.
    `a = t & s` 交集


-   `difference_update`(**others*)

-   `set -= other | ...`

    Update the set, removing elements found in others.
    `a = t - s` 求差集，求在 t 中，但不在 s 中的项


-   `symmetric_difference_update`(*other*)

-   `set ^= other`

    Update the set, keeping only elements found in either set, but not in both.
    `a = t ^ s` 对称差集，求在 t 或 s 中，但不同时出现在两者中的项


-   `add`(*elem*)

    将 *elem* 元素添加到集合中。


-   `remove`(*elem*)

    Remove element *elem* from the set. Raises [`KeyError`](https://docs.python.org/3/library/exceptions.html#KeyError) if *elem* is not contained in the set.删除某项


-   `discard`(*elem*)

    Remove element *elem* from the set if it is present.


-   `pop`()

    Remove and return an arbitrary element from the set. Raises [`KeyError`](https://docs.python.org/3/library/exceptions.html#KeyError) if the set is empty.


-   `clear`()

    Remove all elements from the set.

Note, the non-operator versions of the [`update()`](https://docs.python.org/3/library/stdtypes.html#set.update), [`intersection_update()`](https://docs.python.org/3/library/stdtypes.html#set.intersection_update), [`difference_update()`](https://docs.python.org/3/library/stdtypes.html#set.difference_update), and [`symmetric_difference_update()`](https://docs.python.org/3/library/stdtypes.html#set.symmetric_difference_update) methods will accept any iterable as an argument.

Note, the *elem* argument to the [`__contains__()`](https://docs.python.org/3/reference/datamodel.html#object.__contains__), [`remove()`](https://docs.python.org/3/library/stdtypes.html#set.remove), and [`discard()`](https://docs.python.org/3/library/stdtypes.html#set.discard) methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from *elem*.

```
>>> bri = set(['brazil', 'russia', 'india'])
>>> 'india' in bri
True
>>> 'usa' in bri
False
>>> bric = bri.copy()
>>> bric.add('china')
 #.issuperset方法测试bric是否为bri的超集
>>> bric.issuperset(bri)
True
>>> bri.remove('russia')
#.intersection 交集
>>> bri & bric # OR bri.intersection(bric)
{'brazil', 'india'}
```



## 4. 比较序列和其它类型

Comparing Sequences and Other Types

序列对象可以与具有相同序列类型的其他对象进行比较。 
比较使用词典 *lexicographical* 顺序：

-   首先比较前两个项目，如果它们不同，即可得出比较结果；如果它们相等，则比较接下来的两个项目，以此类推，直到任一序列被耗尽。

-   如果要比较的两个项本身是相同类型的序列，则递归地执行词典性比较。 如果两个序列的所有项目比较相等，则认为序列相等。 

-   如果一个序列是另一个序列的初始子序列，则较短的序列小于较长的序列。

字符串的词典 Lexicographical 排序使用 Unicode 代码标记单个字符排序的序号。相同类型的序列之间的比较的一些实例：

```
(1, 2, 3)              < (1, 2, 4)
[1, 2, 3]              < [1, 2, 4]
'ABC' < 'C' < 'Pascal' < 'Python' # 并不是字符越多越大
(1, 2, 3, 4)           < (1, 2, 4)
(1, 2)                 < (1, 2, -1)
(1, 2, 3)             == (1.0, 2.0, 3.0)
(1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)
```

注意：使用 `<` 或 `>` 比较两个不同类型的对象时，只要这些对象具有适当的比较方法，这种比较就是合法的。例如，混合数字类型根据其数值进行比较，因此 0 等于 0.0 。否则，解释器将抛出 `TypeError` 异常。

## 5. 补充

### del 语句

The [`del`](https://docs.python.org/3/reference/simple_stmts.html#del) statement

`del` 语句可以从列表中按给定的索引而不是值来删除一个子项。
`pop()` 方法有返回值。
`del` 还可用于从列表中删除切片或清空整个列表。
（通过为切片分配空列表，同样可以删除或清空整个列表）

```
>>> a = [-1, 1, 66.25, 333, 333, 1234.5]
>>> del a[0]
>>> a
[1, 66.25, 333, 333, 1234.5]
>>> del a[2:4]
>>> a
[1, 66.25, 1234.5]
>>> del a[:]
>>> a
[]
```

`del` 也可用于删除整个变量。删除后，若再引用此变量，就会引发错误。

```
>>> del a
```



### dir()

列出当前作用域中的全部名称