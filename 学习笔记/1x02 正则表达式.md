# 正则表达式

Regular Expression

[TOC]

## 1. 简介

在 re 中被搜索的 patterns 和 strings 可以是 Unicode strings，也可以是 8-bit strings。但是， Unicode 字符串和 8-bit 字符串不能混用：不能将 Unicode 字符串同 bytes pattern 进行匹配，反之亦然；在进行替换时，用于替换的字符串也必须与 pattern 和 search 的字符串具有相同的类型。
注意：re 本身也是字符串。

re 有两个主要的应用场景：

-   检查 strings 是否同 pattern 相匹配（例如检查 Email 地址的格式是否正确）
-   在字符串中执行替换操作（例如将所有美国拼写改为英国拼写）

re 使用转义字符 `\` 表示特殊的格式，或用 `\` 屏蔽特殊字符串的含义。但其使用方式和 string literals 中的用法会有些不同。比如，在匹配 literal backslash 时，由于 re 中不允许存在单独的 `\` ( 必须被表示为 `\\` ) ，所以必须写作 `\\\\` ；而在常规的 string literal 中 `\` 可被表示为 `\\` 。

为了避免上述问题，建议使用 raw string notation 作为 re patterns。
因为在原始字符串中 `\` 不会表示特殊含义（如，  `r"\n"` 表示 `\` + `n` ，而不会被视作一个换行符。），但是同样不能单独使用 `\` 。

所以，通常情况下在 Python 代码中会使用 raw string notation 表示 patterns。

```
In [15]: re.match('\\','\')
  File "<ipython-input-15-19740b6ac65a>", line 1
    re.match('\\','\')
                      ^
SyntaxError: EOL while scanning string literal


In [16]: re.match('\\\\','\\')
Out[16]: <_sre.SRE_Match object; span=(0, 1), match='\\'>

In [17]: re.match('A\\B','A\\B')

In [18]: re.match(r'A\\B','A\\B')
Out[18]: <_sre.SRE_Match object; span=(0, 3), match='A\\B'>

In [22]: re.match(r'\b','\b')
```

>   It is important to note that most regular expression operations are available as module-level functions and methods on [compiled regular expressions](https://docs.python.org/3/library/re.html#re-objects). The functions are shortcuts that don’t require you to compile a regex object first, but miss some fine-tuning parameters.
>

注意：大多数 re 操作可在 [compiled regular expressions](https://docs.python.org/3/library/re.html#re-objects) 中用作模块级的函数和方法。这些函数不需要预先便宜正则表达式对象，但是会丢失一些微调参数。

See also：第三方库 [regex](https://pypi.python.org/pypi/regex/) 模块，提供了与标准库中 [`re`](https://docs.python.org/3/library/re.html#module-re) 模块兼容的 API，但是提供了额外的功能，并对 Unicode 提供了更全面的支持。



## 2. 正则表达式语法

6.2.1. Regular Expression Syntax[¶](https://docs.python.org/3/library/re.html#regular-expression-syntax)

本章中 re 被写作 `style` ，不使用引号。字符串则被写作 `'style'` 。

正则表达式 RE 指定了一组与之匹配的字符串；此模块中的函数可以检查特定的字符串是否和给定的 re 相匹配（又或说，给定的 re 是否和特定的字符串相匹配）。

re 可以被连接，以形成新的 re。如果 A 和 B 都是 re，那么 AB 也是 re。通常情况下，如果字符串 *p* 匹配 *A* ，字符串 *q* 匹配 *B* ，那么字符串 *pq* 将匹配 AB。除非 *A* 或 *B* 包含了低优先级操作，或 *A* 和 *B* 间存在边界条件，或 have numbered group references。

下面是有关 re 格式的简要说明。更多细节请阅读 [Regular Expression HOWTO](https://docs.python.org/3/howto/regex.html#regex-howto).

re 可以包含特殊字符和普通字符。
由普通字符（如 `'A'` / `'a'` / `'0'` ）构成的 re 仅和其自身匹配。比如 `last` 仅和 `'last'` 匹配。

特殊字符串（like `'|'` or `'('` ），可表示某一类普通字符，或用于解释 re 的构成关系。
re pattern 字符串不能包含 null bytes，但是可以使用 `\number` 标记法指定 null byte（如，`'\x00'` ）

Repetition qualifiers (`*`, `+`, `?`, `{m,n}`, etc) **cannot be directly nested**. This avoids ambiguity歧义 with the non-greedy非贪婪 modifier suffix `?`, and with other modifiers in other implementations. To apply a second repetition to an inner repetition, parentheses may be used. For example, the expression `(?:a{6})*` matches any multiple of six `'a'` characters.

### 特殊字符

The special characters are

像是 `.` / `^` / `$` 这样有特殊功能的字符，又被称作 Metacharacters
使用元字符的字面值时，需要在其前方添加 `\` 。

-   `'.'` 

    (Dot.) In the default mode, this **matches any character** except a newline. If the [`DOTALL`](https://docs.python.org/3/library/re.html#re.DOTALL) flag has been specified, this matches any character including a newline.

    ```
    pattern = r"gr.y"

    if re.match(pattern, "grey"):
       print("Match 1")

    if re.match(pattern, "gray"):
       print("Match 2")

    if re.match(pattern, "blue"):
       print("Match 3")
       
    >>>
    Match 1
    Match 2
    >>>
    ```

-   `'^'`

    (Caret.) Matches the start of the string, and in [`MULTILINE`](https://docs.python.org/3/library/re.html#re.MULTILINE) mode also matches immediately after each newline. `^\d`表示必须以数字开头。同 `[]` 一起使用时，有特别含义。

-   `'$'`

    Matches the end of the string or just before the newline at the end of the string, and in [`MULTILINE`](https://docs.python.org/3/library/re.html#re.MULTILINE) mode also matches before a newline. `foo` matches both ‘foo’ and ‘foobar’, while the regular expression `foo$` matches only ‘foo’. More interestingly, searching for `foo.$` in `'foo1\nfoo2\n'` matches ‘foo2’ normally, but ‘foo1’ in [`MULTILINE`](https://docs.python.org/3/library/re.html#re.MULTILINE) mode; searching for a single `$`in `'foo\n'` will find two (empty) matches: one just before the newline, and one at the end of the string. 

    `\d$` 表示必须以数字结束

-   `'*'`
    Causes the resulting RE to match **0 or more** repetitions重复的 of the preceding RE, as many repetitions as are possible. `ab*` will match ‘a’, ‘ab’, or ‘a’ followed by any number of ‘b’s. 表示任意个字符( 包括 0 个)

-   `'+'`
    Causes the resulting RE to **match 1 or more** repetitions of the preceding RE. `ab+` will match ‘a’ followed by any non-zero number of ‘b’s; it will not match just ‘a’. 表示至少一个字符

-   `'?'`
    Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. `ab?` will match either ‘a’ or ‘ab’. 表示 0 或 1 个字符。

-   `*?`, `+?`, `??` **非贪婪匹配**

    The `'*'`, `'+'`, and `'?'` qualifiers修饰符 are all *greedy* 贪婪的 ; they match as much text as possible. Sometimes this behaviour行为 isn’t desired; if the RE `<.*>` is matched against针对 `<a> b <c>`, it will match the entire string, and not just `<a>`. Adding `?` after the qualifier makes it perform执行 the match in *non-greedy* or *minimal* fashion; as *few* characters as possible will be matched. Using the RE `<.*?>` will match only `<a>`.

-   `{m}`
    Specifies that exactly *m* copies of the previous RE should be matched; fewer matches cause the entire RE not to match. For example, `a{6}` will match exactly six `'a'` characters, but not five. 表示 m 个字符

-   `{m,n}`
    Causes the resulting RE to match from *m* to *n* repetitions of the preceding RE, attempting to match as many repetitions as possible. For example, `a{3,5}` will match from 3 to 5 `'a'`characters. Omitting *m* specifies a lower bound of zero, and omitting *n* specifies an infinite upper bound. As an example, `a{4,}b` will match `aaaab` or a thousand `'a'` characters followed by a `b`, but not `aaab`. The comma may not be omitted or the modifier would be confused with the previously described form. `{n,m}` 表示 n~m 个字符

-   `{m,n}?`
    Causes the resulting RE to match from *m* to *n* repetitions of the preceding RE, attempting to match as *few* repetitions as possible. This is the non-greedy version of the previous qualifier. For example, on the 6-character string `'aaaaaa'`, `a{3,5}` will match 5 `'a'` characters, while `a{3,5}?` will only match 3 characters.

-   `'\'`
    Either escapes special characters (permitting you to match characters like `'*'`, `'?'`, and so forth), or signals a special sequence; special sequences are discussed below. 特殊字符需要用 `\` 转义，如`'-'`是特殊字符，需要转义为`\-` 

    If you’re not using a raw string to express the pattern, remember that Python also uses the backslash as an escape sequence in string literals; if the escape sequence isn’t recognized by Python’s parser, the backslash and subsequent character are included in the resulting string. However, if Python would recognize the resulting sequence, the backslash should be repeated twice. This is complicated and hard to understand, so it’s highly recommended that you use raw strings for all but the simplest expressions.


-   `[]` 

    Used to indicate a set of characters. In a set:
    用于在一组特定字符中匹配某个字符。

    -   Characters can be listed individually, e.g. `[amk]` will match `'a'`, `'m'`, or `'k'`.
    -   Ranges of characters can be indicated by giving two characters and separating them by a `'-'`, for example `[a-z]` will match any lowercase ASCII letter, `[0-5][0-9]` will match all the two-digits numbers from `00` to `59`, and `[0-9A-Fa-f]` will match any hexadecimal digit. If `-` is escaped (e.g. `[a\-z]`) or if it’s placed as the first or last character (e.g. `[a-]`), it will match a literal `'-'`.
    -   Special characters lose their special meaning inside sets. For example, `[(+*)]` will match any of the literal characters `'('`, `'+'`, `'*'`, or `')'`.
    -   Character classes such as `\w` or `\S` (defined below) are also accepted inside a set, although the characters they match depends on whether [`ASCII`](https://docs.python.org/3/library/re.html#re.ASCII) or [`LOCALE`](https://docs.python.org/3/library/re.html#re.LOCALE) mode is in force.
    -   Characters that are not within a range can be matched by *complementing* the set. If the first character of the set is `'^'`, all the characters that are *not* in the set will be matched. For example, `[^5]` will match any character except `'5'`, and `[^^]` will match any character except `'^'`. `^` has no special meaning if it’s not the first character in the set. 其它的元字符（`$` / `.` 等）在 `[]` 中没有别的含义。
    -   To match a literal `']'` inside a set, precede it with a backslash, or place it at the beginning of the set. For example, both `[()[\]{}]` and `[]()[{}]` will both match a parenthesis.

    `[a-zA-Z\_][0-9a-zA-Z\_]{0, 19}` 更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。

-   `'|'`
    `A|B`, where A and B can be arbitrary REs, creates a regular expression that will match either A or B. An arbitrary number of REs can be separated by the `'|'` in this way. This can be used inside groups (see below) as well. As the target string is scanned, REs separated by `'|'` are tried from left to right. When one pattern completely matches, that branch is accepted. This means that once `A` matches, `B` will not be tested further, even if it would produce a longer overall match. In other words, the `'|'` operator is never greedy. To match a literal `'|'`, use `\|`, or enclose it inside a character class, as in `[|]`. 

    ```
    import re

    pattern = r"gr(a|e)y"

    match = re.match(pattern, "gray")
    if match:
       print ("Match 1")

    match = re.match(pattern, "grey")
    if match:
       print ("Match 2")    

    match = re.match(pattern, "griy")
    if match:
        print ("Match 3")
    ```


-   `(...)`
    Matches whatever regular expression is inside the parentheses, and indicates the start and end of a group; the contents of a group can be retrieved after a match has been performed, and can be matched later in the string with the `\number` special sequence, described below. To match the literals `'('` or `')'`, use `\(` or `\)`, or enclose them inside a character class: `[(] [)]`. `()` 表示要提取的分组(Group)

### 特殊序列

special sequences

-   `\A`

    Matches only at the start of the string.
    The sequences **\A** and **\Z** match the beginning and end of a string, respectively. 

-   `\b`

    Matches the empty string, but only at the beginning or end of **a word**. A word is defined as a sequence of Unicode alphanumeric or underscore characters, so the end of a word is indicated by whitespace or a non-alphanumeric, non-underscore Unicode character. Note that formally, `\b` is defined as the boundary between a `\w` and a `\W` character (or vice versa), or between `\w` and the beginning/end of the string. This means that `r'\bfoo\b'` matches `'foo'`, `'foo.'`, `'(foo)'`, `'bar foo baz'` but not `'foobar'` or `'foo3'`.

    By default Unicode alphanumerics are the ones used, but this can be changed by using the [`ASCII`](https://docs.python.org/3/library/re.html#re.ASCII) flag. Inside a character range, `\b` represents the backspace character, for compatibility with Python’s string literals.

    ```
    pattern = r"\b(cat)\b"
    # "\b(cat)\b" basically matches the word "cat" surrounded by word boundaries.
    match = re.search(pattern, "The cat sat!")
    if match:
       print ("Match 1")

    match = re.search(pattern, "We s>cat<tered?")
    if match:
       print ("Match 2")

    match = re.search(pattern, "We scattered.")
    if match:
       print ("Match 3")
       
    >>>
    Match 1
    Match 2
    >>>
    ```

-   `\B`

    Matches the empty string, but only when it is *not* at the beginning or end of a word. This means that `r'py\B'` matches `'python'`, `'py3'`, `'py2'`, but not `'py'`, `'py.'`, or `'py!'`. `\B` is just the opposite of `\b`, so word characters are Unicode alphanumerics or the underscore, although this can be changed by using the [`ASCII`](https://docs.python.org/3/library/re.html#re.ASCII) flag.

-   `\d` 

    -   For Unicode (str) patterns:

        Matches any **Unicode decimal digit** (that is, any character in Unicode character category [Nd]). This includes `[0-9]`, and also many other digit characters. If the [`ASCII`](https://docs.python.org/3/library/re.html#re.ASCII) flag is used only `[0-9]` is matched (but the flag affects the entire regular expression, so in such cases using an explicit `[0-9]` may be a better choice).

    -   For 8-bit (bytes) patterns:

        Matches any decimal digit; this is equivalent to `[0-9]`.

-   `\D`

    Matches any character which is not a Unicode decimal digit. This is the **opposite**相反的 of `\d`. If the [`ASCII`](https://docs.python.org/3/library/re.html#re.ASCII) flag is used this becomes the equivalent of `[^0-9]` (but the flag affects the entire regular expression, so in such cases using an explicit `[^0-9]` may be a better choice).

-   `\s`

    -   For Unicode (str) patterns:

        Matches Unicode whitespace characters (which includes `[ \t\n\r\f\v]`, and also many other characters, for example the non-breaking spaces mandated by typography rules in many languages). If the [`ASCII`](https://docs.python.org/3/library/re.html#re.ASCII) flag is used, only `[ \t\n\r\f\v]` is matched (but the flag affects the entire regular expression, so in such cases using an explicit `[ \t\n\r\f\v]`may be a better choice).

    -   For 8-bit (bytes) patterns:

        Matches characters considered whitespace in the ASCII character set; this is equivalent to `[ \t\n\r\f\v]`.

-   `\S`

    Matches any character which is not a Unicode whitespace character. This is the **opposite** of `\s`. If the [`ASCII`](https://docs.python.org/3/library/re.html#re.ASCII) flag is used this becomes the equivalent of `[^ \t\n\r\f\v]` (but the flag affects the entire regular expression, so in such cases using an explicit `[^ \t\n\r\f\v]` may be a better choice).

-   `\w`

    -   For Unicode (str) patterns:

        Matches **Unicode word characters**; this includes most characters that can be part of a word in any language, as well as numbers and the underscore. If the [`ASCII`](https://docs.python.org/3/library/re.html#re.ASCII) flag is used, only `[a-zA-Z0-9_]` is matched (but the flag affects the entire regular expression, so in such cases using an explicit `[a-zA-Z0-9_]` may be a better choice).

    -   For 8-bit (bytes) patterns:

        Matches characters considered alphanumeric in the ASCII character set; this is equivalent to `[a-zA-Z0-9_]`.

-   `\W`
  Matches any character which is **not a Unicode word character**. This is the **opposite** of `\w`. If the [`ASCII`](https://docs.python.org/3/library/re.html#re.ASCII) flag is used this becomes the equivalent of `[^a-zA-Z0-9_]` (but the flag affects the entire regular expression, so in such cases using an explicit `[^a-zA-Z0-9_]` may be a better choice).

-   `\Z`

  Matches only at the end of the string.



`re` 模块包含了所有正则表达式的功能。



## 3. Module Contents[¶](https://docs.python.org/3/library/re.html#module-contents)

6.2.2. Module Contents[¶](https://docs.python.org/3/library/re.html#module-contents)

### re.match( )

re.match(*pattern*, *string*, *flags=0*)

If zero or more characters **at the beginning of** *string* match the regular expression *pattern*, return a corresponding [match object](https://docs.python.org/3/library/re.html#match-objects). Return `None` if the string does not match the pattern; note that this is different from a zero-length match.

Note that even in [`MULTILINE`](https://docs.python.org/3/library/re.html#re.MULTILINE) mode, [`re.match()`](https://docs.python.org/3/library/re.html#re.match) will only match at the beginning of the string and not at the beginning of each line.

If you want to locate定位 a match anywhere in *string*, use [`search()`](https://docs.python.org/3/library/re.html#re.search) instead (see also [search() vs. match()](https://docs.python.org/3/library/re.html#search-vs-match)).

```
>>> import re
>>> re.match(r'^\d{3}\-\d{3,8}$', '010-12345')
<_sre.SRE_Match object; span=(0, 9), match='010-12345'>
>>> re.match(r'^\d{3}\-\d{3,8}$', '010 12345')
>>>
```

常见用法：

```
test = '用户输入的字符串'
if re.match(r'正则表达式', test):
    print('ok')
else:
    print('failed')
```

### re.search( )

re.search(*pattern*, *string*, *flags=0*)

Scan through *string* looking for the **first location** where the regular expression *pattern* produces a match, and return a corresponding [match object](https://docs.python.org/3/library/re.html#match-objects). Return `None` if no position in the string matches the pattern; note that this is different from finding a zero-length match at some point in the string.

### re.findall( )

re.findall(*pattern*, *string*, *flags=0*)

Return all non-overlapping非重叠 matches of *pattern* in *string*, as a list of strings. The *string* is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result unless they touch the beginning of another match.

### re.finditer( )

re.finditer(*pattern*, *string*, *flags=0*)

Return an [iterator](https://docs.python.org/3/glossary.html#term-iterator) yielding [match objects](https://docs.python.org/3/library/re.html#match-objects) over all non-overlapping matches for the RE *pattern*in *string*. The *string* is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result unless they touch the beginning of another match.
The function **re.finditer** does the same thing as **re.findall** , except it returns an iterator, rather than a list.

### re.sub( )

This method replaces all occurrences出现 of the **pattern **in string with **repl**, substituting all occurrences, unless **max** provided. This method returns the modified string. 

```
import re

str = "My name is David. Hi David."
pattern = r"David"
newstr = re.sub(pattern, "Amy", str)
print(newstr)

>>>
My name is Amy. Hi Amy.
>>>
```

re.sub(*pattern*, *repl*, *string*, *count=0*, *flags=0*)

Return the string obtained by replacing the leftmost non-overlapping occurrences of *pattern* in *string* by the replacement *repl*. If the pattern isn’t found, *string* is returned unchanged. *repl* can be a string or a function; if it is a string, any backslash escapes in it are processed. That is, `\n`is converted to a single newline character, `\r` is converted to a carriage return, and so forth. Unknown escapes such as `\&` are left alone. Backreferences, such as `\6`, are replaced with the substring matched by group 6 in the pattern. For example:

```
re.sub(r'def\s+([a-zA-Z_][a-zA-Z_0-9]*)\s*\(\s*\):',
       r'static PyObject*\npy_\1(void)\n{',
       'def myfunc():')
>>> 'static PyObject*\npy_myfunc(void)\n{'
```

### re.split()

-   re.split(pattern, string, maxsplit=0, flags=0)

    Split *string* by the occurrences of *pattern*. 

    If capturing捕获 parentheses are used in *pattern* ( `'(\W+)'` ), then the text of all groups in the pattern are also returned as part of the resulting list. 

    If *maxsplit* is nonzero, at most *maxsplit* splits occur发生, and the remainder剩余的 of the string is returned as the final element of the list.
    注意：实例中列表末尾的空字符串。

    ```
    >>> re.split('\W+', 'Words, words, words.')
    ['Words', 'words', 'words', '']
    >>> re.split('(\W+)', 'Words, words, words.')
    ['Words', ', ', 'words', ', ', 'words', '.', '']
    >>> re.split('\W+', 'Words, words, words.', 1)
    ['Words', 'words, words.']
    >>> re.split('[a-f]+', '0a3B9', flags=re.IGNORECASE)
    ['0', '3', '9']
    ```


    If there are capturing groups in the separator分离器 and it matches at the start of the string, the result will start with an empty string. The same holds for the end of the string:

    ​```
    >>> re.split('(\W+)', '...words, words...')
    ['', '...', 'words', ', ', 'words', '...', '']
    ​```

使用 regex 的分拆字符串比使用字符串方法更灵活：

```
# 字符串方法：无法识别连续空格
>>> 'a b   c'.split(' ')
['a', 'b', '', '', 'c']
# regex：
>>> re.split(r'\s+', 'a b   c')
['a', 'b', 'c']

>>> re.split(r'[\s\,]+', 'a,b, c  d')
['a', 'b', 'c', 'd']

>>> re.split(r'[\s\,\;]+', 'a,b;; c  d')
['a', 'b', 'c', 'd']
```



## 4. Match Objects

6.2.4. Match Objects[¶](https://docs.python.org/3/library/re.html#match-objects)

Match objects always have a boolean value of `True`. Since [`match()`](https://docs.python.org/3/library/re.html#re.regex.match) and [`search()`](https://docs.python.org/3/library/re.html#re.regex.search) return `None` when there is no match, you can test whether there was a match with a simple `if` statement:

```
match = re.search(pattern, string)
if match:
    process(match)
```

Match objects support the following methods and attributes:

These methods include **group** which returns the string matched, **start **and **end** which return the start and ending positions of the first match, and **span**  which returns the start and end positions of the first match as a tuple.

```
import re

pattern = r"pam"

match = re.search(pattern, "eggspamsausage")
if match:
   print(match.group())
   print(match.start())
   print(match.end())
   print(match.span())
```

Result:

```
>>>
pam
4
7
(4, 7)
>>>
```

### match.group

match.group([*group1*, *...*])[¶](https://docs.python.org/3/library/re.html#re.match.group)

用括号包裹 regex 便可创建分组，提取子串。
group 可以同元字符一起使用。

```
>>> m = re.match(r"(\w+) (\w+)", "Isaac Newton, physicist")
>>> m.group(0)       # The entire match
'Isaac Newton'
>>> m.group(1)       # The first parenthesized subgroup.
'Isaac'
>>> m.group(2)       # The second parenthesized subgroup.
'Newton'
>>> m.group(1, 2)    # Multiple arguments give us a tuple.
('Isaac', 'Newton')
```

-   **named groups** : 格式为 ` (?P<name>...)` ，`name` 表示 group 的名称，`...` 表示 group 的内容。被命名后的 group 可通过名称或序号进行访问。

-   **Non-capturing groups** : 格式为 `(?:...)` ，这样的 group 不能通过组方法进行访问。如果将其插入到现有的 regex 中，并不会破坏现有的 group 的顺序。

    ```
    In [48]: pattern = r"(?P<first>abc)(?:...)(ghi)"

    In [49]: match = re.match(pattern, "abcdefghi")

    In [50]: match.group(1)
    Out[50]: 'abc'

    In [51]: match.group(2)
    Out[51]: 'ghi'

    In [52]: match.group()
    Out[52]: 'abcdefghi'

    In [54]: match.groups(0)
    Out[54]: ('abc', 'ghi')
    ```

### match.groups

match.groups(*default=None*)

Return a tuple containing all the subgroups of the match, from 1 up to however many groups are in the pattern. The *default* argument is used for groups that did not participate in the match; it defaults to `None`.

```
>>> m = re.match(r"(\d+)\.(\d+)", "24.1632")
>>> m.groups()
('24', '1632')
```

提取子串非常有用。来看一个更凶残的例子：

```
>>> t = '19:05:30'
>>> m = re.match(r'^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$', t)
>>> m.groups()
('19', '05', '30')
```

这个正则表达式可以直接识别合法的时间。
但是有些时候，用正则表达式也无法做到完全验证，比如识别日期：

```
'^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$'
```

对于`'2-30'`，`'4-31'`这样的非法日期，用正则还是识别不了，或者说写出来非常困难，这时就需要程序配合识别了。

## 5. 预编译正则表达式

当我们在Python中使用正则表达式时，re模块内部会干两件事情：

1.  编译正则表达式，如果正则表达式的字符串本身不合法，会报错；
2.  用编译后的正则表达式去匹配字符串。

如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：

```
>>> import re
# 编译:
>>> re_telephone = re.compile(r'^(\d{3})-(\d{3,8})$')
# 使用：
>>> re_telephone.match('010-12345').groups()
('010', '12345')
>>> re_telephone.match('010-8086').groups()
('010', '8086')
```

编译后生成 Regular Expression Objects[¶](https://docs.python.org/3/library/re.html#regular-expression-objects) 。
regex 对象也拥有相应的方法和属性，这方法和属性与 Module Contents 中介绍的方法类似。但是在调用时，无需再次给出 regex。

## 6. 贪婪匹配

正则匹配默认是贪婪匹配，会匹配尽可能多的字符。
举例如下，匹配出数字后面的`0`：

```
>>> re.match(r'^(\d+)(0*)$', '102300').groups()
('102300', '')
```

 `\d+` 采用贪婪匹配，会直接把后面的`0`全部匹配，导致 `0*` 只能匹配空字符串。
此时需要采用非贪婪匹配，加个 `?` 就可以让`\d+`采用非贪婪匹配：

```
>>> re.match(r'^(\d+?)(0*)$', '102300').groups()
('1023', '00')
```







