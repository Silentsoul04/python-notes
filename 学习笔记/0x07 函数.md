# 0x07 函数

[TOC]





## 1. 定义函数

函数定义语法：

```
def <function name> (<list of paramaters>):
	<sequence of statements>
```

函数调用只能位于函数定义之后

```python
# first() 这里的调用会抛出异常

def first():
    # 这里似乎是在second定义之前对其进行了调用，
    # 而实际上要等到first被调用时，才会真正调用second，
    second() 
    print("first")

def second():
    print("second") 
       
first()
```



### 函数"别名"

函数名其实就是指向一个函数对象的引用，因此完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：

```
>>> a = abs # 变量a指向abs函数
>>> a(-1) # 所以也可以通过a调用abs函数
1
```

### return 语句

`return` 被用于从一个函数返回，即跳出正在执行的函数。

- `return None`

    如果没有 `return` 语句，函数执行完毕后会自动返回 `None`。
    `return None` 可以简写为 `return`。当返回值为 `None` 时，需要使用 `print` 函数才能正常显示。

- 返回多个值
    在这种情况下，返回值实际上是 tuple，只是在语法上，返回一个 tuple 可以省略括号。因此，“返回多个值”只是一种假象，实际上返回的仍是单一值，只是值的类型是 tuple。获取返回值后，再对 tuple 解包，便得到了多个值。

    ```
    import math
    
    def move(x, y, step, angle=0):
        nx = x + step * math.cos(angle)
        ny = y - step * math.sin(angle)
        return nx, ny
        
    >>> x, y = move(100, 100, 60, math.pi / 6)
    >>> print(x, y)
    151.96152422706632 70.0
    
    >>> r = move(100, 100, 60, math.pi / 6)
    >>> print(r)
    (151.96152422706632, 70.0)
    ```

### pass 语句

如果想定义一个什么事也不做的空函数，可以用`pass`语句：

```
def nop():
    pass

```

-   用于创建最小类

  ```
  >>> class MyEmptyClass:
  ...     pass
  ...
  ```

-   作为函式或条件体的占位符：当你在编写新代码时，可以让你在更抽象的级别上思考。

-   `pass` 还可以用在其他语句里，比如：

    ```
    if age >= 18:
        pass
    ```



### 参数检查

在编写函数时，要进行参数检查，以避免用户输入错误的参数。

-   参数个数错误，Py 自动检测。
-   参数类型错误：可使用`isinstance()` 检查实例类型，然后 `raise` 抛出错误。

#### isinstance() 

>   isinstance(obj, class_or_tuple, /)
>
>   Return whether an object is an instance of a class or of a subclass thereof.
>
>   A tuple, as in ``isinstance(x, (A, B, ...))``, may be given as the target to check against. This is equivalent to ``isinstance(x, A) or isinstance(x, B)or ...`` etc.

```
def my_abs(x):
    if not isinstance(x, (int, float)):
        raise TypeError('bad operand type')
    if x >= 0:
        return x
    else:
        return -x
```

输出结果：

```
>>> my_abs('A')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 3, in my_abs
TypeError: bad operand type
```



## 2. 参数

https://docs.python.org/3.7/glossary.html#term-argument

定义函数时，一旦把参数的名称和位置确定下来，函数接口的定义就完成了。
对于函数的调用者，只需要知道如何传递正确的参数，以及返回值的类型就够了。函数内部的复杂逻辑被封装起来，调用者无需了解。

Python 中函数定义非常简单，但灵活度却很大。除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。

在调用标准函数和 Python 的库函数时，它们会检查其参数的类型。程序员定义的函数可以接受任意类型的参数，包括函数和类型自身。

### 形参和实参

-   形参 *parameters* ：在函数定义中给出的名称。
-   实参 *arguments* ：在函数调用中提供的值。

实参是在函数调用的过程中，被引入到目标函数的局部符号表的。
因此，实参在传递的过程中使用 **传值调用** call by value。
即，实参实际上引用的是原对象的值的副本，而非是直接使用原对象。

另外，当一个函数调用另一个函数时，同样会创建一个新的符号表。

### 局部变量/作用域/符号表

Local Variables

定义函数时，在函数体内部声明的变量被称作局部变量(Local Variables) 。
局部变量与函数外部的同名变量没有任何联系，只在函数调用的生命周期内有效，且对其它的函数或外围程序不可见。这被称作变量的**作用域 scope**。所有变量都具有相应的作用域，作用域从名称被定义的地方开始。

函数执行时会引入一个新的**符号表**，该表用于函数的本地变量。
函数中所有变量的分配关系都是存储在本地符号表中的值。
变量引用时的查找顺序：local symbol table > local symbol tables of enclosing functions > global symbol table >the table of built-in names。
因此，在函数内部不能直接为全局变量赋值 (除非使用 `global` 语句)，但可以在函数内部引用全局变量的值。

注意：如果函数将列表作为参数，那么在函数中对 list 所做修改是全局性的。如果不想修改 list，则需要向函数传递 list 的副本，比如 list_name[:]。

Example (save as `function_local.py`):

```
x = 50

def func(x):
    print('x is', x) 
    x = 2 # x是函数的本地变量
    print('Changed local x to', x)
func(x)
print('x is still', x)
```

Output:

```
$ python function_local.py
x is 50
Changed local x to 2
x is still 50
```

如果没有将全局变量作为参数传递给函数，并且在函数内部赋值前尝试调用，则会报错：

```
name = 'hello'
def test():
    """"""
    print (name) #试图打印时，便会报错
    name = name+' lily'

test()
```



#### global 语句

The `global` statement

如果想要给一个位于程序最外层的名称赋值（i.e. 该名称不属于任何类型的作用域，如函数/类），便需要使用 `global` 语句。
使用 `global` 语句可以清楚地表明变量是在最外面的块被定义的。
使用同一个 `global` 语句可以指定多个全局变量，例如 `global x,y,z`。

Example (save as `function_global.py`):

```
x = 50


def func():
    global x

    print('x is', x)
    x = 2
    print('Changed global x to', x)


func()
print('Value of x is', x)
```

Output:

```
$ python function_global.py
x is 50
Changed global x to 2
Value of x is 2
```



### 位置实参

```
def power(x, n):
    s = 1
    while n > 0:
        n = n - 1
        s = s * x
    return s
```

`x` 和 `n` 便是位置参数。
位置函数在调用时必须被传入，且需要按照顺序传入。

### 默认实参值

Default Argument Values

默认参数值应为不可变对象。

```
def power(x, n=2):
    s = 1
    while n > 0:
        n = n - 1
        s = s * x
    return s
    
>>> power(5)
25
>>> power(5, 2)
25
```

此处的 `n=2` 采用了默认参数值。

参数列表需满足：位置参数在前，默认参数在后，否则Python的解释器会报错。



当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。既减少了函数的调用难度，由保证了函数调用的灵活性。



```
def enroll(name, gender, age=6, city='Beijing'):
    print('name:', name)
    print('gender:', gender)
    print('age:', age)
    print('city:', city)
```



#### 默认实参值估算点

默认参数的值，在函数定义处被确定。

```
i = 5

def f(arg=i):
    print(arg)

i = 6
f()

>>> 5
```

**Important warning:** 

默认参数值一旦确定，就不会再被修改。
当默认参数值是可变对象时（list, dictionary,部分可变类实例），便会产生不同的效果。

```
def f(a, L=[]):
    L.append(a)
    return L

print(f(1))
print(f(2))
print(f(3))
```

output：

```
[1]
[1, 2]
[1, 2, 3]
```

如果不想在之后的调用中用到之前的可变默认参数，可使用如下定义方式：

```
def f(a, L=None):
    if L is None:
        L = []
    L.append(a)
    return L
```

所以**默认参数必须指向不变对象！** 因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。



### 可变参数 

VarArgs parameters

`*args` 表示可变参数，此时传入实参的数量是可变。
本质上是将 list/tuple 作为实参传递给函数。

-   可直接传入参数：`func(1, 2, 3)` 
-   也可接受组装好的 list/tuple：`func(*(1, 2, 3))` / `func(*[1, 2, 3])`

 `*args` 和 `**kw` 是惯用写法，虽然可以修改，但是建议保持。

示例：

```
>>> def calc(*numbers):
...     sum = 0
...     for n in numbers:
...         sum = sum + n * n
...     return sum
...
>>> calc(1, 2)
5
>>> calc(*[1, 2])
5
>>> calc([1, 2])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 4, in calc
TypeError: can't multiply sequence by non-int of type 'list'

# 没有参数也行
>>> calc()
0

# 在可变参数中对已有列表进行调用：
>>> nums = [1, 2, 3]
>>> calc(nums[0], nums[1], nums[2])
14
>>> calc(*nums)
14
>>> print(*nums)
1 2 3
>>> print(nums)
[1, 2, 3]
```

在函数内部，参数 `numbers` 会接收到一个tuple。



#### 参数列表分拆

Unpacking Argument Lists

有时实参已被打包到 list / tuple 中，但在调用函数时，却需要分离的位置参数。
这是便需要对 list / tuple 进行解包。
在调用函数时，可使用`*` 号对打包到 list / tuple 中的参数进行解包。

```
>>> list(range(3, 6))            # normal call with separate arguments
[3, 4, 5]
>>> args = [3, 6]
>>> list(range(*args))            # call with arguments unpacked from a list
[3, 4, 5]
```

类似的，字典可以使用 `**` 运算符传递关键字参数：

```
>>> def parrot(voltage, state='a stiff', action='voom'):
...     print("-- This parrot wouldn't", action, end=' ')
...     print("if you put", voltage, "volts through it.", end=' ')
...     print("E's", state, "!")
...
>>> d = {"voltage": "four million", "state": "bleedin' demised", "action": "VOOM"}
>>> parrot(**d)
-- This parrot wouldn't VOOM if you put four million volts through it. E's bleedin' demised !
```

```python
n = (1, 2)
def func1(*args):
    print(args)
    
func1(*n, *n)
func1(n, n)
'''out:
(1, 2, 1, 2)
((1, 2), (1, 2))
'''
```



### 关键字参数

VarArgs parameters

`**kw` 表示关键字参数，本质上是将字典作为实参传递给函数。

-   可以直接传入：`func(a=1, b=2)` 
-   也可接受组装好的字典：`func(**{'a': 1, 'b': 2})`。

 `*args` 和 `**kw` 是惯用写法，虽然可以修改，但是建议保持。
关键字参数允许向函数传入任意数量的键-值对，这些键-值对在函数内部自动组装为一个字典。

```
>>> def person(name, age, **kw):
...     print('name:', name, 'age:', age, 'other:', kw)
...
# 只传入必选参数
>>> person('Michael', 30)
name: Michael age: 30 other: {}
# 同时传入关键字参数
>>> person('Adam', 45, gender='M', job='Engineer')
name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}

# 直接调用字典
>>> extra = {'city': 'Beijing', 'job': 'Engineer'}
>>> person('Jack', 24, city=extra['city'], job=extra['job'])
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}

>>> extra = {'city': 'Beijing', 'job': 'Engineer'}
>>> person('Jack', 24, **extra)
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
```

关键字参数可用于扩展函数的功能。比如注册时，收集必填项目以外的信息。

注意 `kw` 获得的dict是 `extra` 的一份拷贝，对 `kw` 的改动不会影响到函数外的`extra`。

#### 命名关键字参数

命名关键字参数

参考 https://segmentfault.com/a/1190000005173136

对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。
如果需要限制传入的关键字参数的名称，可以直接命名关键字参数。

“命名关键字参数” 在调用时，必须传入参数名。

例如：

```
# 只接受关键字参数 city和 job
def person(name, age, *, city, job):
    print(name, age, city, job)

# 调用时，必须包含关键字参数
>>> person('Jack', 24, city='Beijing', job='Engineer')
Jack 24 Beijing Engineer
```

“命名关键字参数”与“关键字参数 `**kw` ”的差异：

-   需要 `*` 分隔符，`*` 之后的部分被视为命名关键字参数
-   如果参数列表中已包含 “ 可变参数 `*args` ” ，则不需要 `*` 分隔符
-   如果缺少`*`，Python 会将“命名关键字参数”当作位置参数看待
-   “命名关键字参数” 可以有缺省值，从而简化调用：

```
def person(name, age, *, city='Beijing', job):
    print(name, age, city, job)

# 由于命名关键字参数 `city` 具有默认值，调用时，可不传入`city`参数
>>> person('Jack', 24, job='Engineer')
Jack 24 Beijing Engineer
```



### 参数组合使用

Python 中共有 5 种参数类型。
这 5 中参数类型的需按照如下顺序，从左到右依次定义：
位置参数 / 默认参数 / 可变参数 / 命名关键字参数 / 关键字参数 /

注意：“ 命名关键字参数 ” 独立于 “ 关键字参数 ” 在字典内部构成的字典。

```
def f1(a, b, c=0, *args, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)

def f2(a, b, c=0, *, d, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)
```

调用：

```
>>> f1(1, 2)
a = 1 b = 2 c = 0 args = () kw = {}
>>> f1(1, 2, c=3)
a = 1 b = 2 c = 3 args = () kw = {}
>>> f1(1, 2, 3, 'a', 'b')
a = 1 b = 2 c = 3 args = ('a', 'b') kw = {}
>>> f1(1, 2, 3, 'a', 'b', x=99)
a = 1 b = 2 c = 3 args = ('a', 'b') kw = {'x': 99}

>>> f2(1, 2, d=99, ext=None)
a = 1 b = 2 c = 0 d = 99 kw = {'ext': None}
```

通过 tuple / list / dict 进行调用：

```
>>> args = (1, 2, 3, 4)
>>> kw = {'d': 99, 'x': '#'}
>>> f1(*args, **kw)
a = 1 b = 2 c = 3 args = (4,) kw = {'d': 99, 'x': '#'}

In [83]: args = [1, 2, 3, 4]
In [84]: kw = {'d': 99, 'x': '#'}
In [85]: f1(*args, **kw)
a = 1 b = 2 c = 3 args = (4,) kw = {'d': 99, 'x': '#'}

>>> args = (1, 2, 3)
>>> kw = {'d': 88, 'x': '#'}
>>> f2(*args, **kw)
a = 1 b = 2 c = 3 d = 88 kw = {'x': '#'}
```

因此，对于任意函数，都可以通过类似 `func(*args, **kw)` 的形式调用。

**注意**：可变参数 `*args` 会尝试从位置参数的第一位起，为每个位置参数填充数值。

```
def f1(a, b=0, *args, **kw):
    print(a)
    print(b)
    print(args)
    print(kw)


kw = {'c': 1}
args = (1, 2, 3, 4)
f1(a='A', *args, **kw)

Traceback (most recent call last):
  File "c:/Users/iwhal/Desktop/learn_python/learn.py", line 15, in <module>
    f1(a='A', *args, **kw)
TypeError: f1() got multiple values for argument 'a'
```

可变参数 `*args` 会尝试从位置参数的第一位起，为每个位置参数填充数值。



## 3. 递归函数

在函数体内部对自身进行调用的函数，被称作递归函数。
使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。

以 `n! = 1 x 2 x 3 x ... x n` 阶乘计算为例，函数 `fact(n)` =n! 。
那么可做如下推导：
fact(n) = n! = 1 x 2 x 3 x ... x (n-1) x n = (n-1)! x n = fact(n-1) x n

所以，`fact(n)`可以表示为`n * fact(n-1)`，只有n=1时需要特殊处理。

```
def fact(n):
    if n==1:
        return 1
    return n * fact(n - 1)
```

上面就是一个递归函数。可以试试：

```
>>> fact(5)
120
```

如果我们计算`fact(5)`，可以根据函数定义看到计算过程如下：

```
===> fact(5)
===> 5 * fact(4)
===> 5 * (4 * fact(3))
===> 5 * (4 * (3 * fact(2)))
===> 5 * (4 * (3 * (2 * fact(1))))
===> 5 * (4 * (3 * (2 * 1)))
===> 5 * (4 * (3 * 2))
===> 5 * (4 * 6)
===> 5 * 24
===> 120
```

递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。

示例，利用递归函数，可以强制完成一次正确的输入：

```python
def safeIntegerInput(prompt):
    inputString = input(prompt)
    try:
        num = int(inputString)
        return num
    except ValueError as ex:
        print(ex.values)
        return safeIntegerInput(prompt)


if __name__ == '__main__':
    safeIntegerInput("输入整数值：")
```

### 栈溢出

使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试 `fact(1000)`：

```
>>> fact(1000)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 4, in fact
  ...
  File "<stdin>", line 4, in fact
RuntimeError: maximum recursion depth exceeded in comparison
```

解决递归调用栈溢出的方法是通过**尾递归**优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。

### 尾递归

**尾递归**是指，在函数返回的时候，调用自身本身，并且，return 语句**不能包含表达式**。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。

上面的`fact(n)`函数由于`return n * fact(n - 1)`引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：

```
def fact(n):
    return fact_iter(n, 1)

def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)
```

可以看到，`return fact_iter(num - 1, num * product)`仅返回递归函数本身，`num - 1`和`num * product`在函数调用前就会被计算，不影响函数调用。

`fact(5)`对应的`fact_iter(5, 1)`的调用如下：

```
===> fact_iter(5, 1)
===> fact_iter(4, 5)
===> fact_iter(3, 20)
===> fact_iter(2, 60)
===> fact_iter(1, 120)
===> 120

```

尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。

遗憾的是，大多数编程语言没有针对尾递归做优化，
Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。所以，即使把上面的`fact(n)`函数改成尾递归方式，也会导致栈溢出。

针对尾递归优化的语言可以通过尾递归防止栈溢出。

尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。



### 

