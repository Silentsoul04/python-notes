# 0x12 IO 编程

[TOC]

**本章的IO编程都是同步模式**

Input Stream：数据从外部（磁盘、网络）流进内存，
Output Stream：数据从内存流向外部。

CPU和内存的速度远高于外设，两者间存在速度严重不匹配的问题。
**同步 I/O**：在进行 I/O 操作时，必须等待 I/O 操作完成后，才能执行后续代码。 
**异步 I/O**：不必等待 I/O 操作完成，便可继续执行后续代码。
可见同步和异步 I/O 的区别主要在于是否等待 I/O 执行的结果。
显然使用异步 I/O 的程序，其性能会远高于同步 I/O，不过异步 I/O的编程模型也会更加复杂。

注意，操作 I/O 的能力都是由操作系统提供的，每种编程语言都会把操作系统提供的低级 C 接口进行封装，以方便使用。Python 也使用的这种方式。



## 1. Output / Input

### print( ) 

### input( )

## 2. 读写文件

对磁盘内文件的读写功能，都是由操作系统提供的。
现代操作系统不允许普通程序直接操作硬盘。
所以对文件进行读写，其实就是请求操作系统打开一个文件对象（通常称为文件描述符），然后通过操作系统提供的接口向该对象读/写数据。

### open( )

`open` (*file*, *mode='r'*, *buffering=-1*, *encoding=None*, *errors=None*, *newline=None*, *closefd=True*, *opener=None*)

Open *file* and return a corresponding [file object](https://docs.python.org/3/glossary.html#term-file-object). 
[file object](https://docs.python.org/3/glossary.html#term-file-object) 是可迭代对象。

```
>>> for line in f:
...     print(line, end='')
...
This is the first line of the file.
Second line of the file
```

If the file cannot be opened, an [`OSError`](https://docs.python.org/3/library/exceptions.html#OSError)is raised.

```
>>> f=open('/Users/michael/notfound.txt', 'r')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
FileNotFoundError: [Errno 2] No such file or directory: '/Users/michael/notfound.txt'
```

-   *file* is a [path-like object](https://docs.python.org/3/glossary.html#term-path-like-object) giving the **pathname** (absolute or relative to the current working directory) of the file to be opened or **an integer file descriptor of the file to be wrapped**. (If a file descriptor is given, it is closed when the returned I/O object is closed, unless *closefd* is set to `False`.)

    ` x 1>>> f = open('/Users/michael/test.txt', 'r')`


- *mode* is an optional string that specifies the mode in which the file is opened. 
    The **default mode** is `'r'` (open for reading text, synonym of `'rt'`). 
    The available modes are:



    For binary read-write access, the mode `'w+b'` opens and truncates the file to 0 bytes. `'r+b'` opens the file without truncation.

    ```
    # 读取二进制文件
    >>> f = open('/Users/michael/test.jpg', 'rb')
    >>> f.read()
    b'\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...' # 十六进制表示的字节
    ```

- *encoding* : In text mode, if *encoding* is not specified the encoding used is platform dependent: `locale.getpreferredencoding(False)` is called to get the current locale encoding. (For reading and writing raw bytes use binary mode and leave *encoding* unspecified.) 可实现编码转换。

- *errors* : 表示遇到编码错误的处理方式。

    ```
    >>> f = open('/Users/michael/gbk.txt', 'r', encoding='gbk', errors='ignore')
    ```

在文本模式下读取时，默认将平台特定的行末终止符 ( `\n` on Unix, `\r\n` on Windows ) 转换为 `\n` 。

在文本模式下写入时，默认将 `\n` 转换回平台特定的行末终止符。
对于行末终止符的修改会在幕后自动进行，这种方式对文本文件很友好，但是会破坏像 `JPEG` 或 `EXE` 等文件中的二进制数据。在读写此类二进制文件时，需要使用 binary mode。

#### 字符编码

读取非 UTF-8 编码的文本文件时，需要设置 `encoding` 。

```
#读取GBK编码的文件：
>>> f = open('/Users/michael/gbk.txt', 'r', encoding='gbk')
>>> f.read()
'测试'
```

遇到编码不规范的文件，可能会出现 `UnicodeDecodeError`，因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，`open()` 函数还接收一个 `errors` 参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略：

```
>>> f = open('/Users/michael/gbk.txt', 'r', encoding='gbk', errors='ignore')
```

编码转换：

```
# unicode 转 utf‐8
import io
f = io.open("abc.txt", "wt", encoding="utf‐8")
f.write(u"Imagine non‐English language here")
f.close()
text = io.open("abc.txt", encoding="utf‐8").read()
print(text)
使用io.open，并提供"encoding" 参数 "decoding"，来告诉 Python 我们使用unicode。
```

-   通过阅读下面的内容学习这个主题的更多知识点：
    -   ["The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets"](http://www.joelonsoftware.com/articles/Unicode.html)
    -   [Python Unicode Howto](http://docs.python.org/3/howto/unicode.html)
    -   [Pragmatic Unicode talk by Nat Batchelder](http://nedbatchelder.com/text/unipain.html)

#### file-like Object

类似 `open()` 返回的这种拥有 `read()` 方法的对象，被称为 file-like Object。
除 file 外，还可以是内存的字节流，网络流，自定义流等等。
file-like Object不要求从特定类继承，只要拥有 `read()` 方法就行。

`StringIO` 就是在内存中创建的file-like Object，常用作临时缓冲。




### close( )[¶](https://docs.python.org/3/library/io.html#io.IOBase.close)

Flush and close this stream. This method has no effect if the file is already closed. Once the file is closed, any operation on the file (e.g. reading or writing) will raise a [`ValueError`](https://docs.python.org/3/library/exceptions.html#ValueError).

As a convenience方便, it is allowed to call this method more than once; only the first call, however, will have an effect.

文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的：

```
>>> f.close()
```

文件读写时可能产生 `IOError` 异常，为保证 `close()` 的执行，有以下两种方式：

#### try ... finally

```
try:
    f = open('/path/to/file', 'r')
    print(f.read())
finally:
    if f:
        f.close()
```

#### with

8.5. The [`with`](https://docs.python.org/3/reference/compound_stmts.html#with) statement[¶](https://docs.python.org/3/reference/compound_stmts.html#the-with-statement)

参看 0x11 错误、调试和测试 > 2. 处理异常 > 预定义清理操作

```
with open("myfile.txt") as f:
    for line in f:
        print(line, end="")
```

#### closed

`True` if the stream is closed.

### read( )

#### read(*size*)[¶](https://docs.python.org/3/library/io.html#io.TextIOBase.read)

Read and return at most *size* characters from the stream as a single [`str`](https://docs.python.org/3/library/stdtypes.html#str). If *size* is negative or `None`, reads until EOF. EOFE - end of file 

```
>>> f.read()
'Hello, world!'
```

注意：`read()` 会一次性读取全部文件内容并返回，如果文件内容两倍于机器的内存，则会出现问题。
可使用 *size* 参数设置读取的字符数，避免此类问题。

`read()` 在文本模式下，会返回字符串；在二进制模式下，会返回字节对象。
如果已经位于文件的末尾，`read()` 将返回空字符串 (`''`) 。

```
>>> f.read()
'This is the entire file.\n'
>>> f.read()
''
```

#### readline (*size=-1*)

Read and return one line from the stream. 
If *size* is specified, at most *size* bytes will be read.

The line terminator is always `b'\n'` for binary files; for text files, the *newline* argument to [`open()`](https://docs.python.org/3/library/functions.html#open) can be used to select the line terminator(s) recognized.

字符串的末尾会保留 newline character (`\n`) 。
如果文件的最后一行不是以换行符结尾，在读取这一行时，不会添加换行符。

如果 `f.readline()` 返回一个空字符串，那么此时已到达了文件的末尾。

文件中使用 `\n` 表示空行时，此时返回的字符串也只会包含一个换行符。

```
>>> f.readline()
'This is the first line of the file.\n'
>>> f.readline()
'Second line of the file\n'
>>> f.readline()
''
```



#### readlines(*hint=-1*)[¶](https://docs.python.org/3/library/io.html#io.IOBase.readlines)

Read and return a list of lines from the stream. *hint* can be specified to control the number of lines read: no more lines will be read if the total size (in bytes/characters) of all lines so far exceeds *hint*.

等效于： `list(f)` 

Note that it’s already possible to iterate on file objects using `for line in file: ...` without calling `file.readlines()`.

```
>>> for line in f.readlines():
...     print(line, end='')    

# 等效于
>>> for line in f:
...     print(line, end='')
...
This is the first line of the file.
Second line of the file
```



-   Help on method_descriptor:

    strip(...)

    S.strip([chars]) -> str

    Return a copy of the string S with leading and trailing whitespace removed.If chars is given and not None, remove characters in chars instead.



### write( )

Write the string *s* to the stream and return the **number of characters written**.

注意设置 `open()` 函数的 *mode* 参数。

-   'w' open for writing, truncating the file first 
-   'b' binary mode 

```
>>> f = open('/Users/michael/test.txt', 'w')
>>> f.write('Hello, world!')
13
>>> f.close()
```

写文件时，操作系统通常不会立刻把数据写入磁盘，而是先将数据缓存到内存中，空闲的时候再慢慢写入。

只有当调用 `close()` 方法时，操作系统才保证把没有写入的数据全部写入磁盘(也被称作 flushing)。
如果没有调用 `close()` ，则很有可能会丢失数据。

需要写入特定编码的文本文件时，需要实现为 `open()` 传入相应的 `encoding` 参数。

Other types of objects need to be converted – either to a string (in text mode) or a bytes object (in binary mode) – before writing them:

```
>>> value = ('the answer', 42)
>>> s = str(value)  # convert the tuple to string
>>> f.write(s)
18
```

利用 `print()` 函数，也可将数据写入到文件。
` print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False)`
写入文件时，需要将 `file` 指向被写入的文件对象，就是用 `open()` 函数返回的文件对象。

### tell( )[¶](https://docs.python.org/3/library/io.html#io.TextIOBase.tell)

Return the current stream position.

-   in text mode：Return the current stream position as an opaque number. The number does not usually represent a number of bytes in the underlying binary storage. 将当前流位置返回为不透明数。 该数字通常不表示底层二进制存储器中的多个字节。

-   in binary mode ：表示从文件开头到指针处的字节数


```
In [21]: f = open('learn.txt',mode='w')

In [22]: f.write('Hello, world!')
Out[22]: 13

In [23]: f.tell()
Out[23]: 13
```

### seek( )

seek(*offset*[, *whence*])

-   I/O Base Classes -- 字节对象 [¶](https://docs.python.org/3/library/io.html#io.IOBase.seek)

    Change the stream position to the given byte *offset*. *offset* is interpreted relative to the position indicated by *whence*. The default value for *whence* is `SEEK_SET`. Values for *whence* are:

    -   `SEEK_SET` or `0` – start of the stream (the default); *offset* should be zero or positive
    -   `SEEK_CUR` or `1` – current stream position; *offset* may be negative
    -   `SEEK_END` or `2` – end of the stream; *offset* is usually negative

    Return the new absolute position.

    New in version 3.1: The `SEEK_*` constants.

    New in version 3.3: Some operating systems could support additional values, like`os.SEEK_HOLE` or `os.SEEK_DATA`. The valid values for a file could depend on it being open in text or binary mode.

    ```
    >>> f = open('workfile', 'rb+')
    >>> f.write(b'0123456789abcdef')
    16
    >>> f.seek(5)      # Go to the 6th byte in the file
    5
    >>> f.read(1)
    b'5'
    >>> f.seek(-3, 2)  # Go to the 3rd byte before the end
    13
    >>> f.read(1)
    b'd'
    ```


-   Text I/O -- 文本对象 [¶](https://docs.python.org/3/library/io.html#io.TextIOBase.seek)

    Change the stream position to the given *offset*. Behaviour行为 depends依赖 on the *whence* parameter. The default value for *whence* is `SEEK_SET`.

    -   `SEEK_SET` or `0`: seek from the start of the stream (the default); *offset* must either be a number returned by [`TextIOBase.tell()`](https://docs.python.org/3/library/io.html#io.TextIOBase.tell), or zero. Any other *offset* value produces undefined未定义 behaviour.
        从 `f.tell()` 返回的值是唯一有效的 *offset* ，或者是 0。其它任何偏移值都会产生未定义的行为。
    -   `SEEK_CUR` or `1`: “seek” to the current position; *offset* must be zero, which is a no-operation (all other values are unsupported).
    -   `SEEK_END` or `2`: seek to the end of the stream; *offset* must be zero (all other values are unsupported).

    Return the new absolute position as an opaque number.

    New in version 3.1: The `SEEK_*` constants.





## 3. StringIO和BytesIO

StringIO 和 BytesIO 是在内存中操作 `str` 和 `bytes` 的方法，拥有与文件读写相同的接口。同样需要使用 `close()` 关闭。

同样需要 close( ) 进行关闭。

### StringIO

*class* io.StringIO(*initial_value=''*, *newline='\n'*)[¶](https://docs.python.org/3/library/io.html#io.StringIO)

An **in-memory stream** for text I/O. The text buffer缓存区 is discarded丢弃 when the [`close()`](https://docs.python.org/3/library/io.html#io.IOBase.close) method is called.

The initial value of the buffer can be set by providing *initial_value*. If newline translation is enabled, newlines will be encoded as if by [`write()`](https://docs.python.org/3/library/io.html#io.TextIOBase.write). The stream is positioned at the start of the buffer.

The *newline* argument works like that of [`TextIOWrapper`](https://docs.python.org/3/library/io.html#io.TextIOWrapper). The default is to consider only `\n` characters as ends of lines and to do no newline translation. If *newline* is set to `None`, newlines are written as `\n` on all platforms, but universal通用 newline decoding is still performed when reading.

[`StringIO`](https://docs.python.org/3/library/io.html#io.StringIO) provides this method in addition to those from [`TextIOBase`](https://docs.python.org/3/library/io.html#io.TextIOBase) and its parents:

-   `getvalue`()

    Return a `str` containing the entire contents of the buffer. Newlines are decoded as if by [`read()`](https://docs.python.org/3/library/io.html#io.TextIOBase.read), although the stream position is not changed.

In-memory text streams are also available as [`StringIO`](https://docs.python.org/3/library/io.html#io.StringIO) objects:

```
f = io.StringIO("some initial text data")
```

Example usage:

```
import io

output = io.StringIO()
output.write('First line.\n')
print('Second line.', file=output)

# Retrieve file contents -- this will be
# 'First line.\nSecond line.\n'
contents = output.getvalue()

# Close object and discard memory buffer --
# .getvalue() will now raise an exception.
output.close()
```

读取 StringIO

```
>>> from io import StringIO
>>> f = StringIO('Hello!\nHi!\nGoodbye!')
>>> while True:
...     s = f.readline()
...     if s == '':
...         break
...     print(s.strip())
...
Hello!
Hi!
Goodbye!
```

### BytesIO

*class* io.`BytesIO`([*initial_bytes*])

A stream implementation using an **in-memory bytes buffer**. It inherits [`BufferedIOBase`](https://docs.python.org/3/library/io.html#io.BufferedIOBase). The buffer is discarded when the [`close()`](https://docs.python.org/3/library/io.html#io.IOBase.close) method is called.

The optional argument *initial_bytes* is a [bytes-like object](https://docs.python.org/3/glossary.html#term-bytes-like-object) that contains initial data.

[`BytesIO`](https://docs.python.org/3/library/io.html#io.BytesIO) provides or overrides these methods in addition to those from [`BufferedIOBase`](https://docs.python.org/3/library/io.html#io.BufferedIOBase)and [`IOBase`](https://docs.python.org/3/library/io.html#io.IOBase):

-   `getbuffer`()

    Return a readable and writable view over the contents of the buffer without copying them. Also, mutating the view will transparently update the contents of the buffer:>>>`>>> b = io.BytesIO(b"abcdef")>>> view = b.getbuffer()>>> view[2:4] = b"56">>> b.getvalue()b'ab56ef'`Note As long as the view exists, the [`BytesIO`](https://docs.python.org/3/library/io.html#io.BytesIO) object cannot be resized or closed.New in version 3.2.


-   `getvalue`()

    Return [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes) containing the entire contents of the buffer.


-   `read1`()

    In [`BytesIO`](https://docs.python.org/3/library/io.html#io.BytesIO), this is the same as `read()`.


-   `readinto1`()

    In [`BytesIO`](https://docs.python.org/3/library/io.html#io.BytesIO), this is the same as `readinto()`.New in version 3.5.

```
>>> from io import BytesIO
>>> f = BytesIO()
>>> f.write('中文'.encode('utf-8'))
6
>>> print(f.getvalue())
b'\xe4\xb8\xad\xe6\x96\x87'

>>> f.write('中文')
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-25-37d03170c78b> in <module>()
----> 1 f.write('中文')

TypeError: a bytes-like object is required, not 'str'
```

注意，写入的对象是进过 UTF-8 编码的 bytes。
如果直接写入 `str` 会抛出 TypeError 。

读取方式和文件相同：

```
>>> from io import BytesIO
>>> f = BytesIO(b'\xe4\xb8\xad\xe6\x96\x87')
>>> f.read()
b'\xe4\xb8\xad\xe6\x96\x87'
```



## 4. 操作文件和目录

在命令行中输入操作系统提供的命令，便可操作文件和目录。比如，`dir` / `cp` 。
其实这些命令只是简单的调用了操作系统提供的接口函数，Python 内置的 `os` 模块也可直接嗲用操作系统提供的接口函数。

如果只是想读写文件，请参阅 [`open()`](https://docs.python.org/3/library/functions.html#open) ；
如果想要操作路径，请参阅 [`os.path`](https://docs.python.org/3/library/os.path.html#module-os.path) 模块；
如果想要读取命令行中左右文件中的所有行，请参阅 [`fileinput`](https://docs.python.org/3/library/fileinput.html#module-fileinput) 模块。
如果想要创建临时文件和目录，请参阅 [`tempfile`](https://docs.python.org/3/library/tempfile.html#module-tempfile) 模块，
对于高级文件和目录处理，请参阅 [`shutil`](https://docs.python.org/3/library/shutil.html#module-shutil) 模块。

注意：操作文件和目录的函数在 `os` 和 `path` 模块中各有一部分。

### os 模块

[The Python Standard Library](https://docs.python.org/3/library/index.html) »16.1. [`os`](https://docs.python.org/3/library/os.html#module-os) — Miscellaneous operating system interfaces[¶](https://docs.python.org/3/library/os.html#module-os)

该模块提供了使用操作系统相关功能的便捷方式。
如果只是想读写文件，请参阅 [`open()`](https://docs.python.org/3/library/functions.html#open) ；
如果想要操作路径，请参阅 [`os.path`](https://docs.python.org/3/library/os.path.html#module-os.path) 模块；
如果想要读取命令行中左右文件中的所有行，请参阅 [`fileinput`](https://docs.python.org/3/library/fileinput.html#module-fileinput) 模块。
如果想要创建临时文件和目录，请参阅 [`tempfile`](https://docs.python.org/3/library/tempfile.html#module-tempfile) 模块，
对于高级文件和目录处理，请参阅 [`shutil`](https://docs.python.org/3/library/shutil.html#module-shutil) 模块。

#### os.name

The name of the operating system dependent module imported. The following names have currently been registered已注册: `'posix'`, `'nt'`, `'java'`.  `'posix'` 表示 Linux/Unix/MacOS；`'nt'` 表示 Windows。

See also
[`sys.platform`](https://docs.python.org/3/library/sys.html#sys.platform) has a finer granularity. [`os.uname()`](https://docs.python.org/3/library/os.html#os.uname) gives system-dependent version information.
The [`platform`](https://docs.python.org/3/library/platform.html#module-platform) module provides detailed checks for the system’s identity.

```
>>> import os
>>> os.name
'nt'
>>> import sys
>>> sys.platform
'win32'
```

#### os.uname()[¶](https://docs.python.org/3/library/os.html#os.uname)

Returns information identifying标识 the current operating system. The return value is an object with five attributes:

-   `sysname` - operating system name
-   `nodename` - name of machine on network (implementation-defined)
-   `release` - operating system release
-   `version` - operating system version
-   `machine` - hardware identifier标识符

For backwards compatibility, this object is also iterable, behaving like a five-tuple containing `sysname`, `nodename`, `release`, `version`, and `machine` in that order.

Some systems truncate `nodename` to 8 characters or to the leading component; a better way to get the hostname is [`socket.gethostname()`](https://docs.python.org/3/library/socket.html#socket.gethostname) or even`socket.gethostbyaddr(socket.gethostname())`.

Availability: recent flavors of Unix.

Changed in version 3.3: Return type changed from a tuple to a tuple-like object with named attributes.

`uname()` 用于获取当前系统的详细信息，只能用于 Unix。

```
>>> os.uname()
posix.uname_result(sysname='Darwin', nodename='MichaelMacPro.local', release='14.3.0', version='Darwin Kernel Version 14.3.0: Mon Mar 23 11:59:05 PDT 2015; root:xnu-2782.20.48~5/RELEASE_X86_64', machine='x86_64')
```

#### os.environ 环境变量 

os.environ[¶](https://docs.python.org/3/library/os.html#os.environ)

在操作系统中定义的环境变量，全部保存在`os.environ`这个变量中，可以直接查看：

```
>>> os.environ
environ({'VERSIONER_PYTHON_PREFER_32_BIT': 'no', 'TERM_PROGRAM_VERSION': '326', 'LOGNAME': 'michael', 'USER': 'michael', 'PATH': '/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/X11/bin:/usr/local/mysql/bin', ...})

```

要获取某个环境变量的值，可以调用`os.environ.get('key')`：

```
>>> os.environ.get('PATH')
'/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/X11/bin:/usr/local/mysql/bin'
>>> os.environ.get('x', 'default')
'default'
```

#### 重命名和删除

```
# 对文件重命名:
>>> os.rename('test.txt', 'test.py')
# 删掉文件:
>>> os.remove('test.py')
```

#### 文件筛选

列出当前目录下的所有目录：

```
>>> [x for x in os.listdir('.') if os.path.isdir(x)]
['.lein', '.local', '.m2', '.npm', '.ssh', '.Trash', '.vim', 'Applications', 'Desktop', ...]
```

列出所有 `.py` 文件：

```
>>> [x for x in os.listdir('.') if os.path.isfile(x) and os.path.splitext(x)[1]=='.py']
['apis.py', 'config.py', 'models.py', 'pymonitor.py', 'test_db.py', 'urls.py', 'wsgiapp.py']
```

### os.path 模块

[os.path](https://docs.python.org/3/library/os.path.html#module-os.path) — Common pathname manipulations[¶](https://docs.python.org/3/library/os.path.html#module-os.path)

`os` 模块提供了使用操作系统相关功能的的便捷方式。
而 [`os.path`](https://docs.python.org/3/library/os.path.html#module-os.path) 提供了操作路径的方法；

查看、创建和删除目录可以这么调用：

```
# 查看当前目录的绝对路径:
>>> os.path.abspath('.')
'/Users/michael'
# 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:
>>> os.path.join('/Users/michael', 'testdir')
'/Users/michael/testdir'
# 然后创建一个目录:
>>> os.mkdir('/Users/michael/testdir')
# 删掉一个目录:
>>> os.rmdir('/Users/michael/testdir')
```

注意：用于拆分/合并路径的函数，并不要求路径真实存在，仅仅是对给定的路径字符串进行操作。

#### os.path.join()

合成路径时，不要直接拼接字符串，要使用 `os.path.join()` 进行拼接。
因为这样可以正确处理不同操作系统中的路径分隔符。

```
# Linux/Unix/Mac 
>>> import os.path
>>> os.path.join('part-1','part-2')
'part-1/part-2'
```

```
# Windows
>>> import os.path
>>> os.path.join('part-1','part-2')
'part-1\\part-2'
```

#### os.path.split()

同理分拆路劲时，要使用 `os.path.split()` 函数。
该函数路径拆分为两部分，后一部分总是最后级别的目录或文件名：

```
>>> os.path.split('/Users/michael/testdir/file.txt')
('/Users/michael/testdir', 'file.txt')
```

#### os.path.splitext()

该函数可直接分拆出文件的扩展名。

```
>>> os.path.splitext('/path/to/file.txt')
('/path/to/file', '.txt')
```

### shutil 模块

11.10. [`shutil`](https://docs.python.org/3/library/shutil.html#module-shutil) — High-level file operations

The [`shutil`](https://docs.python.org/3/library/shutil.html#module-shutil) module offers a number of high-level operations on files and collections of files. In particular, functions are provided which **support file copying and removal**. For operations on individual files, see also the [`os`](https://docs.python.org/3/library/os.html#module-os) module.

因为操作系统不提供用于复制文件的系统调用，所以 os 模块中并没有提供用于复制文件的函数。虽然可以通过读写文件完成复制，但这会写很多代码。

`shutil` 模块中的 `copyfile()` 函数用于复制文件。
`shutil` 模块中含有很多使用函数，可作为 `os` 模块的补充。



## 5. 序列化

利用 `read()` 在文件中读写字符串非常简单。
如果从文件中读取数值则会稍显麻烦： `int(read(...))` 。
当试图读写更加复杂的数据类型时，这种手动解析和序列化的方式会变的很复杂。
为了避免这种情况，Python 允许使用 [JSON (JavaScript Object Notation)](http://json.org/) 和Pickle。

程序运行时，所有变量都位于内存中。
程序结束运行后，变量占用的内存会被操作系统全部回收。
例如，假设在源代码中定义了 `name = 'Bob'` ，若在程序运行时将 `name` 改为 `Lily` 。再次重新运行该程序，变量仍会被初始化为 `Bob` 。
如果想要把修改后的变量永久保存，便会用到序列化操作。

**序列化**是指，将内存中的变量变为可存储( 或可传输 ) 的对象的过程。

```python
# 将列表中的对象进行序列化和反序列化
import pickle

def main():
    aList = [60, "string", 1977]
    fileObj = open("items.dat", "wb")  # 以字节模式打开文件
    for item in aList:  # 也可以将aList对象直接序列化
        pickle.dump(item, fileObj)
    fileObj.close()


def minor():
    aList = []
    fileObj = open("items.dat", "rb")
    while True:
        try:
            # load()函数达到文件末尾时，会抛出EOFError，
            # 并且没有明确的方法来检查是否达到了文件末尾
            item = pickle.load(fileObj)
            aList.append(item)
        except EOFError:
            fileObj.close()
            break
    print(aList)


if __name__ == '__main__':
    main()
    minor()
```


### Pickle 模块

picking 由 `pickle` 模块实现。

picking 是 Python 中的序列化协议，在其它编程语言中被称作 serialization、marshalling 或 flattening 等。对象被序列化之后，便可被写入磁盘或通过网络传输。

picking 用于保存和加载对象，该术语源自把黄瓜变成腌菜以便在罐子里储存的过程。Python 中的任何对象都可以被封装(pickled)，然后再将其保存到文件中；从文件中读取对象并拆封(unpickled)后，便可将之前保存的对象读取到内存中。Python 会自动负责所有的转换细节。

如果在 pickle 的过程中发生异常，会抛出 `PickleError` 。

注意：是以二进制方式读写。

#### pickle.dump

pickle.dump(*obj*, *file*, *protocol=None*, \*, *fix_imports=True*)

Write a pickled representation of *obj* to the open [file object](https://docs.python.org/3/glossary.html#term-file-object) *file*. 
将 *obj* 经 pickle 后的表示形式写入到打开的 [file object](https://docs.python.org/3/glossary.html#term-file-object) 文件中。
This is equivalent to `Pickler(file, protocol).dump(obj)`.

-   The optional *protocol* argument, an integer, tells the pickler to use the given protocol; supported protocols are 0 to [`HIGHEST_PROTOCOL`](https://docs.python.org/3/library/pickle.html#pickle.HIGHEST_PROTOCOL). If not specified, the default is [`DEFAULT_PROTOCOL`](https://docs.python.org/3/library/pickle.html#pickle.DEFAULT_PROTOCOL). If a negative number is specified, [`HIGHEST_PROTOCOL`](https://docs.python.org/3/library/pickle.html#pickle.HIGHEST_PROTOCOL) is selected. 目前有 5 种不同的协议。
-   The *file* argument must have a **write() method** that accepts a single **bytes argument**. It can thus be an on-disk file opened for **binary writing**, an [`io.BytesIO`](https://docs.python.org/3/library/io.html#io.BytesIO) instance, or any other custom object that meets this interface.
-   If *fix_imports* is true and *protocol* is less than 3, pickle will try to map the new Python 3 names to the old module names used in Python 2, so that the pickle data stream is readable with Python 2.

#### pickle.dumps

pickle.dumps(*obj*, *protocol=None*, \*, *fix_imports=True*)

Return the pickled representation of the object as a [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes) object, instead of writing it to a file. 注意：序列化后的内容是 **字节对象**。

Arguments *protocol* and *fix_imports* have the same meaning as in [`dump()`](https://docs.python.org/3/library/pickle.html#pickle.dump).

#### pickle.load

pickle.load(*file*, \*, *fix_imports=True*, *encoding="ASCII"*, *errors="strict"*)

Read a pickled object representation from the open [file object](https://docs.python.org/3/glossary.html#term-file-object) *file* and return the reconstituted object hierarchy specified therein. 并返回其中指定的重构对象的层次结构。
This is equivalent to `Unpickler(file).load()`.

The protocol version of the pickle is detected automatically, so no protocol argument is needed. Bytes past the pickled object’s representation are ignored.  pickled 对象种用于表示该对象是 pickled 的字节部分会被忽略。

-   The argument *file* must have two methods, **a read()** method that takes an integer argument, and a **readline()** method that requires no arguments. Both methods should return bytes. Thus *file* can be an on-disk file opened for binary reading, an [`io.BytesIO`](https://docs.python.org/3/library/io.html#io.BytesIO)object, or any other custom object that meets this interface.
-   Optional keyword arguments are *fix_imports*, *encoding* and *errors*, which are used to control compatibility兼容性 support for pickle stream generated产生 by Python 2. 
    -   If *fix_imports* is true, pickle will try to map the old Python 2 names to the new names used in Python 3. 
    -   The *encoding* and *errors* tell pickle how to decode 8-bit string instances pickled by Python 2; these default to ‘ASCII’ and ‘strict’, respectively. The *encoding* can be ‘bytes’ to read these 8-bit string instances as bytes objects.

#### pickle.loads

pickle.loads(*bytes_object*, \*, *fix_imports=True*, *encoding="ASCII"*, *errors="strict"*)

Read a pickled object hierarchy from a [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes) object and return the reconstituted object hierarchy specified therein.

The protocol version of the pickle is detected automatically, so no protocol argument is needed. Bytes past the pickled object’s representation are ignored.

Optional keyword arguments are *fix_imports*, *encoding* and *errors*, which are used to control compatibility support for pickle stream generated by Python 2. If *fix_imports* is true, pickle will try to map the old Python 2 names to the new names used in Python 3. The *encoding* and *errors* tell pickle how to decode 8-bit string instances pickled by Python 2; these default to ‘ASCII’ and ‘strict’, respectively. The *encoding* can be ‘bytes’ to read these 8-bit string instances as bytes objects.

示例 1，序列化对象并写入文件：

```
>>> import pickle
>>> d = dict(name='Bob', age=20, score=88)
>>> pickle.dumps(d)
b'\x80\x03}q\x00(X\x03\x00\x00\x00ageq\x01K\x14X\x05\x00\x00\x00scoreq\x02KXX\x04\x00\x00\x00nameq\x03X\x03\x00\x00\x00Bobq\x04u.'
```

```
>>> f = open('dump.txt', 'wb')
>>> pickle.dump(d, f)
>>> f.close()
```

示例 2，反序列化：

也可先把内容读取到 `bytes` 对象种，然后在进行反序列化，

```
>>> f = open('dump.txt', 'rb')
>>> d = pickle.load(f)
>>> f.close()
>>> d
{'age': 20, 'score': 88, 'name': 'Bob'}
```

示例 1 和 2 种的变量虽有相同的内容，但并不是同一个对象，内存位置已经发生了改变。

pickle 是一种协议，它允许对 python 种任意复杂对象进行序列化，但是它只能用于 Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。如果数据由熟练的攻击者制作，反序列化来自不可信源的pickle 数据可以执行任意代码。

### JSON 模块

JSON 中的 "JS" 表示"JavaScript"，"ON" 表示"对象标记法"。基于文本格式，而 Pickle 基于二进制模式

 [`json`](https://docs.python.org/3/library/json.html#module-json) 模块可以获取 Python 数据的层次结构，并将该数据转换为字符串表示。
这种转换过程被称作序列化 *serializing* 。经序列化后，以字符串表示的数据对象可以被存储到文件中，或者通过网络进行传输。
从字符串中重构数据的过程，被称作反序列化 *deserializing* 。此时得到的数据类型和序列化之前的相同。

使用 json 将对象序列化为标准格式后，甚至可以在不同的编程语言读取。
JSON 作为标准格式，还可以直接在 Web 页面中读取。

JSON 表示的对象就是标准 JavaScript 语言的对象，JSON和Python内置的数据类型对应如下：

| JSON类型       | Python类型   |
| ------------ | ---------- |
| {} object    | dict       |
| [] array     | list       |
| "string"     | str        |
| number(int)  | int        |
| number(real) | float      |
| true/false   | True/False |
| null         | None       |

将 python 对象序列化为 JSON 字符串：

```
>>> import json
>>> d = dict(name='Bob', age=20, score=88)
>>> json.dumps(d)
'{"age": 20, "score": 88, "name": "Bob"}'
```

 [`dump()`](https://docs.python.org/3/library/json.html#json.dump) 方法可直接把 JSON 写入 `file-like Object` ，将对象序列化为文本文件。

```
x = [1, 'simple', 'list']
json.dump(x, f) #假设f是文件对象的实例
```

从`file-like Object`中读取字符串并反序列化：

```
x = json.load(f)
```

`loads()` ：

```
>>> json_str = '{"age": 20, "score": 88, "name": "Bob"}'
>>> json.loads(json_str)
{'age': 20, 'score': 88, 'name': 'Bob'}
```

JSON 标准规定 JSON 以 UTF-8 编码，所以 Python 的 `str` 和 JSON 字符串间总能正确的转换。

#### 序列化任意实例

Python的`dict`对象可以直接序列化为JSON的`{}`，不过，很多时候，我们更喜欢用`class`表示对象，比如定义`Student`类，然后序列化：

```
import json

class Student(object):
    def __init__(self, name, age, score):
        self.name = name
        self.age = age
        self.score = score

s = Student('Bob', 20, 88)
print(json.dumps(s))
```

运行代码，毫不留情地得到一个`TypeError`：

```
Traceback (most recent call last):
  ...
TypeError: <__main__.Student object at 0x10603cc50> is not JSON serializable
```

错误的原因是`Student`对象不是一个可序列化为JSON的对象。

如果连`class`的实例对象都无法序列化为JSON，这肯定不合理！

别急，我们仔细看看`dumps()`方法的参数列表，可以发现，除了第一个必须的`obj`参数外，`dumps()`方法还提供了一大堆的可选参数：

[https://docs.python.org/3/library/json.html#json.dumps](https://docs.python.org/3/library/json.html#json.dumps)

这些可选参数就是让我们来定制JSON序列化。前面的代码之所以无法把`Student`类实例序列化为JSON，是因为默认情况下，`dumps()`方法不知道如何将`Student`实例变为一个JSON的`{}`对象。

可选参数`default`就是把任意一个对象变成一个可序列为JSON的对象，我们只需要为`Student`专门写一个转换函数，再把函数传进去即可：（如果为 `student` 类增加一个方法，将需要的数据转换为一个字典，再把这个字典发给 JSON，也是可行的）

```
def student2dict(std):
    return {
        'name': std.name,
        'age': std.age,
        'score': std.score
    }
```

这样，`Student`实例首先被 `student2dict()`函数转换成`dict`，然后再被顺利序列化为JSON：

```
>>> print(json.dumps(s, default=student2dict))
{"age": 20, "name": "Bob", "score": 88}
```

不过，下次如果遇到一个`Teacher`类的实例，照样无法序列化为JSON。我们可以偷个懒，把任意`class`的实例变为`dict`：

```
print(json.dumps(s, default=lambda obj: obj.__dict__))
```

因为通常`class`的实例都有一个`__dict__`属性，它就是一个`dict`，用来存储实例变量。也有少数例外，比如定义了`__slots__`的class。

同样的道理，如果我们要把JSON反序列化为一个`Student`对象实例，`loads()`方法首先转换出一个`dict`对象，然后，我们传入的`object_hook`函数负责把`dict`转换为`Student`实例：

```
def dict2student(d):
    return Student(d['name'], d['age'], d['score'])
```

运行结果如下：

```
>>> json_str = '{"age": 20, "score": 88, "name": "Bob"}'
>>> print(json.loads(json_str, object_hook=dict2student))
<__main__.Student object at 0x10cd3c190>

```

打印出的是反序列化的 `Student` 实例对象。

Python语言特定的序列化模块是`pickle`，但如果要把序列化搞得更通用、更符合Web标准，就可以使用`json`模块。

`json` 模块的`dumps()`和`loads()`函数是定义得非常好的接口的典范。当我们使用时，只需要传入一个必须的参数。但是，当默认的序列化或反序列机制不满足我们的要求时，我们又可以传入更多的参数来定制序列化或反序列化的规则，既做到了接口简单易用，又做到了充分的扩展性和灵活性。

## 6. 标准输入输出流

想要用交互方式读取用户输入，可从文件 `sys.stdin` 中读取。
如果要将数据输出到屏幕上，可以写入文件 `sys.stdout` 中。`print` 在输出数据时，默认使用 `sys.stdout` 。

```
import sys
sys.stdout,write("Enter youe name:")
name = sys.stdin.readline()
```















